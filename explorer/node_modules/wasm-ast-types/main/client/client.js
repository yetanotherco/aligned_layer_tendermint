"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getWasmMethodArgs = exports.createWasmQueryMethod = exports.createWasmExecMethod = exports.createTypeOrInterface = exports.createTypeInterface = exports.createQueryInterface = exports.createQueryClass = exports.createPropertyFunctionWithObjectParamsForExec = exports.createPropertyFunctionWithObjectParams = exports.createExecuteInterface = exports.createExecuteClass = exports.FIXED_EXECUTE_PARAMS = exports.CONSTANT_EXEC_PARAMS = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var t = _interopRequireWildcard(require("@babel/types"));

var _case = require("case");

var _utils = require("../utils");

var _types2 = require("../utils/types");

var _babel = require("../utils/babel");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var CONSTANT_EXEC_PARAMS = [t.assignmentPattern((0, _babel.identifier)('fee', t.tsTypeAnnotation(t.tsUnionType([t.tSNumberKeyword(), t.tsTypeReference(t.identifier('StdFee')), t.tsLiteralType(t.stringLiteral('auto'))])), false), t.stringLiteral('auto')), (0, _babel.identifier)('memo', t.tsTypeAnnotation(t.tsStringKeyword()), true), (0, _babel.identifier)('funds', t.tsTypeAnnotation(t.tsArrayType(t.tsTypeReference(t.identifier('Coin')))), true)];
exports.CONSTANT_EXEC_PARAMS = CONSTANT_EXEC_PARAMS;
var FIXED_EXECUTE_PARAMS = [(0, _babel.identifier)('fee', t.tsTypeAnnotation(t.tsUnionType([t.tsNumberKeyword(), t.tsTypeReference(t.identifier('StdFee')), t.tsLiteralType(t.stringLiteral('auto'))])), true), (0, _babel.identifier)('memo', t.tsTypeAnnotation(t.tsStringKeyword()), true), (0, _babel.identifier)('funds', t.tsTypeAnnotation(t.tsArrayType(t.tsTypeReference(t.identifier('Coin')))), true)];
exports.FIXED_EXECUTE_PARAMS = FIXED_EXECUTE_PARAMS;

var createWasmQueryMethod = function createWasmQueryMethod(context, jsonschema) {
  var underscoreName = Object.keys(jsonschema.properties)[0];
  var methodName = (0, _case.camel)(underscoreName);
  var responseType = (0, _types2.getResponseType)(context, underscoreName);
  var obj = (0, _types2.createTypedObjectParams)(context, jsonschema.properties[underscoreName]);
  var args = getWasmMethodArgs(context, jsonschema.properties[underscoreName]);
  var actionArg = t.objectProperty(t.identifier(underscoreName), t.objectExpression(args));
  return t.classProperty(t.identifier(methodName), (0, _utils.arrowFunctionExpression)(obj ? [obj] : [], t.blockStatement([t.returnStatement(t.callExpression(t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier('client')), t.identifier('queryContractSmart')), [t.memberExpression(t.thisExpression(), t.identifier('contractAddress')), t.objectExpression([actionArg])]))]), t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Promise'), t.tsTypeParameterInstantiation([t.tSTypeReference(t.identifier(responseType))]))), true));
};

exports.createWasmQueryMethod = createWasmQueryMethod;

var createQueryClass = function createQueryClass(context, className, implementsClassName, queryMsg) {
  context.addUtil('CosmWasmClient');
  var propertyNames = (0, _utils.getMessageProperties)(queryMsg).map(function (method) {
    var _Object$keys;

    return (_Object$keys = Object.keys(method.properties)) === null || _Object$keys === void 0 ? void 0 : _Object$keys[0];
  }).filter(Boolean);
  var bindings = propertyNames.map(_case.camel).map(_utils.bindMethod);
  var methods = (0, _utils.getMessageProperties)(queryMsg).map(function (schema) {
    return createWasmQueryMethod(context, schema);
  });
  return t.exportNamedDeclaration((0, _utils.classDeclaration)(className, [// client
  (0, _utils.classProperty)('client', t.tsTypeAnnotation(t.tsTypeReference(t.identifier('CosmWasmClient')))), // contractAddress
  (0, _utils.classProperty)('contractAddress', t.tsTypeAnnotation(t.tsStringKeyword())), // constructor
  t.classMethod('constructor', t.identifier('constructor'), [(0, _utils.typedIdentifier)('client', t.tsTypeAnnotation(t.tsTypeReference(t.identifier('CosmWasmClient')))), (0, _utils.typedIdentifier)('contractAddress', t.tsTypeAnnotation(t.tsStringKeyword()))], t.blockStatement([// client/contract set
  t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.thisExpression(), t.identifier('client')), t.identifier('client'))), t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.thisExpression(), t.identifier('contractAddress')), t.identifier('contractAddress')))].concat((0, _toConsumableArray2["default"])(bindings))))].concat((0, _toConsumableArray2["default"])(methods)), [t.tSExpressionWithTypeArguments(t.identifier(implementsClassName))]));
};

exports.createQueryClass = createQueryClass;

var getWasmMethodArgs = function getWasmMethodArgs(context, jsonschema) {
  var _jsonschema$propertie;

  var keys = Object.keys((_jsonschema$propertie = jsonschema.properties) !== null && _jsonschema$propertie !== void 0 ? _jsonschema$propertie : {}); // only 1 degree $ref-lookup

  if (!keys.length && jsonschema.$ref) {
    var obj = context.refLookup(jsonschema.$ref);

    if (obj) {
      var _obj$properties;

      keys = Object.keys((_obj$properties = obj.properties) !== null && _obj$properties !== void 0 ? _obj$properties : {});
    }
  }

  var args = keys.map(function (prop) {
    return t.objectProperty(t.identifier(prop), t.identifier((0, _case.camel)(prop)), false, prop === (0, _case.camel)(prop));
  });
  return args;
};

exports.getWasmMethodArgs = getWasmMethodArgs;

var createWasmExecMethod = function createWasmExecMethod(context, jsonschema) {
  context.addUtil('ExecuteResult');
  context.addUtil('StdFee');
  context.addUtil('Coin');
  var underscoreName = Object.keys(jsonschema.properties)[0];
  var methodName = (0, _case.camel)(underscoreName);
  var obj = (0, _types2.createTypedObjectParams)(context, jsonschema.properties[underscoreName]);
  var args = getWasmMethodArgs(context, jsonschema.properties[underscoreName]);
  return t.classProperty(t.identifier(methodName), (0, _utils.arrowFunctionExpression)(obj ? [// props
  obj].concat(CONSTANT_EXEC_PARAMS) : CONSTANT_EXEC_PARAMS, t.blockStatement([t.returnStatement(t.awaitExpression(t.callExpression(t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier('client')), t.identifier('execute')), [t.memberExpression(t.thisExpression(), t.identifier('sender')), t.memberExpression(t.thisExpression(), t.identifier('contractAddress')), t.objectExpression([t.objectProperty(t.identifier(underscoreName), t.objectExpression((0, _toConsumableArray2["default"])(args)))]), t.identifier('fee'), t.identifier('memo'), t.identifier('funds')])))]), // return type
  t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Promise'), t.tsTypeParameterInstantiation([t.tSTypeReference(t.identifier('ExecuteResult'))]))), true));
};

exports.createWasmExecMethod = createWasmExecMethod;

var createExecuteClass = function createExecuteClass(context, className, implementsClassName, extendsClassName, execMsg) {
  context.addUtil('SigningCosmWasmClient');
  var propertyNames = (0, _utils.getMessageProperties)(execMsg).map(function (method) {
    var _Object$keys2;

    return (_Object$keys2 = Object.keys(method.properties)) === null || _Object$keys2 === void 0 ? void 0 : _Object$keys2[0];
  }).filter(Boolean);
  var bindings = propertyNames.map(_case.camel).map(_utils.bindMethod);
  var methods = (0, _utils.getMessageProperties)(execMsg).map(function (schema) {
    return createWasmExecMethod(context, schema);
  });
  var blockStmt = [];

  if (extendsClassName) {
    blockStmt.push( // super()
    t.expressionStatement(t.callExpression(t["super"](), [t.identifier('client'), t.identifier('contractAddress')])));
  }

  [].push.apply(blockStmt, [// client/contract set
  t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.thisExpression(), t.identifier('client')), t.identifier('client'))), t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.thisExpression(), t.identifier('sender')), t.identifier('sender'))), t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.thisExpression(), t.identifier('contractAddress')), t.identifier('contractAddress')))].concat((0, _toConsumableArray2["default"])(bindings)));
  var noImplicitOverride = context.options.client.noImplicitOverride && extendsClassName && context.options.client.execExtendsQuery;
  return t.exportNamedDeclaration((0, _utils.classDeclaration)(className, [// client
  (0, _utils.classProperty)('client', t.tsTypeAnnotation(t.tsTypeReference(t.identifier('SigningCosmWasmClient'))), false, false, noImplicitOverride), // sender
  (0, _utils.classProperty)('sender', t.tsTypeAnnotation(t.tsStringKeyword())), // contractAddress
  (0, _utils.classProperty)('contractAddress', t.tsTypeAnnotation(t.tsStringKeyword()), false, false, noImplicitOverride), // constructor
  t.classMethod('constructor', t.identifier('constructor'), [(0, _utils.typedIdentifier)('client', t.tsTypeAnnotation(t.tsTypeReference(t.identifier('SigningCosmWasmClient')))), (0, _utils.typedIdentifier)('sender', t.tsTypeAnnotation(t.tsStringKeyword())), (0, _utils.typedIdentifier)('contractAddress', t.tsTypeAnnotation(t.tsStringKeyword()))], t.blockStatement(blockStmt))].concat((0, _toConsumableArray2["default"])(methods)), [t.tSExpressionWithTypeArguments(t.identifier(implementsClassName))], extendsClassName ? t.identifier(extendsClassName) : null));
};

exports.createExecuteClass = createExecuteClass;

var createExecuteInterface = function createExecuteInterface(context, className, extendsClassName, execMsg) {
  var methods = (0, _utils.getMessageProperties)(execMsg).map(function (jsonschema) {
    var underscoreName = Object.keys(jsonschema.properties)[0];
    var methodName = (0, _case.camel)(underscoreName);
    return createPropertyFunctionWithObjectParamsForExec(context, methodName, 'ExecuteResult', jsonschema.properties[underscoreName]);
  });
  var extendsAst = extendsClassName ? [t.tSExpressionWithTypeArguments(t.identifier(extendsClassName))] : [];
  return t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier(className), null, extendsAst, t.tSInterfaceBody([// contract address
  t.tSPropertySignature(t.identifier('contractAddress'), t.tsTypeAnnotation(t.tsStringKeyword())), // contract address
  t.tSPropertySignature(t.identifier('sender'), t.tsTypeAnnotation(t.tsStringKeyword()))].concat((0, _toConsumableArray2["default"])(methods)))));
};

exports.createExecuteInterface = createExecuteInterface;

var createPropertyFunctionWithObjectParams = function createPropertyFunctionWithObjectParams(context, methodName, responseType, jsonschema) {
  var obj = (0, _types2.createTypedObjectParams)(context, jsonschema);
  var func = {
    type: 'TSFunctionType',
    typeAnnotation: (0, _utils.promiseTypeAnnotation)(responseType),
    parameters: obj ? [obj] : []
  };
  return t.tSPropertySignature(t.identifier(methodName), t.tsTypeAnnotation( // @ts-ignore:next-line
  func));
};

exports.createPropertyFunctionWithObjectParams = createPropertyFunctionWithObjectParams;

var createPropertyFunctionWithObjectParamsForExec = function createPropertyFunctionWithObjectParamsForExec(context, methodName, responseType, jsonschema) {
  context.addUtil('Coin');
  var obj = (0, _types2.createTypedObjectParams)(context, jsonschema);
  var func = {
    type: 'TSFunctionType',
    typeAnnotation: (0, _utils.promiseTypeAnnotation)(responseType),
    parameters: obj ? [obj].concat(FIXED_EXECUTE_PARAMS) : FIXED_EXECUTE_PARAMS
  };
  return t.tSPropertySignature(t.identifier(methodName), t.tsTypeAnnotation( // @ts-ignore:next-line
  func));
};

exports.createPropertyFunctionWithObjectParamsForExec = createPropertyFunctionWithObjectParamsForExec;

var createQueryInterface = function createQueryInterface(context, className, queryMsg) {
  var methods = (0, _utils.getMessageProperties)(queryMsg).map(function (jsonschema) {
    var underscoreName = Object.keys(jsonschema.properties)[0];
    var methodName = (0, _case.camel)(underscoreName);
    var responseType = (0, _types2.getResponseType)(context, underscoreName);
    return createPropertyFunctionWithObjectParams(context, methodName, responseType, jsonschema.properties[underscoreName]);
  });
  return t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier(className), null, [], t.tSInterfaceBody([t.tSPropertySignature(t.identifier('contractAddress'), t.tsTypeAnnotation(t.tsStringKeyword()))].concat((0, _toConsumableArray2["default"])(methods)))));
};

exports.createQueryInterface = createQueryInterface;

var createTypeOrInterface = function createTypeOrInterface(context, Type, jsonschema) {
  var _jsonschema$propertie2;

  if (jsonschema.type !== 'object') {
    if (!jsonschema.type) {
      return t.exportNamedDeclaration(t.tsTypeAliasDeclaration(t.identifier(Type), null, t.tsTypeReference(t.identifier(jsonschema.title))));
    }

    return t.exportNamedDeclaration(t.tsTypeAliasDeclaration(t.identifier(Type), null, (0, _types2.getType)(jsonschema.type)));
  }

  var props = Object.keys((_jsonschema$propertie2 = jsonschema.properties) !== null && _jsonschema$propertie2 !== void 0 ? _jsonschema$propertie2 : {}).map(function (prop) {
    var _getPropertyType = (0, _types2.getPropertyType)(context, jsonschema, prop),
        type = _getPropertyType.type,
        optional = _getPropertyType.optional;

    return (0, _babel.propertySignature)((0, _case.camel)(prop), t.tsTypeAnnotation(type), optional);
  });
  return t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier(Type), null, [], t.tsInterfaceBody( // @ts-ignore:next-line
  (0, _toConsumableArray2["default"])(props))));
};

exports.createTypeOrInterface = createTypeOrInterface;

var createTypeInterface = function createTypeInterface(context, jsonschema) {
  var Type = jsonschema.title;
  return createTypeOrInterface(context, Type, jsonschema);
};

exports.createTypeInterface = createTypeInterface;