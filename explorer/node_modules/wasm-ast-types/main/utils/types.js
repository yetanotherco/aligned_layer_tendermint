"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof3 = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getParamsTypeAnnotation = exports.detectType = exports.createTypedObjectParams = void 0;
exports.getPropertySignatureFromProp = getPropertySignatureFromProp;
exports.getPropertyType = void 0;
exports.getResponseType = getResponseType;
exports.getTypeInfo = exports.getTypeFromRef = exports.getType = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var t = _interopRequireWildcard(require("@babel/types"));

var _case = require("case");

var _babel = require("./babel");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function getResponseType(context, underscoreName) {
  var _context$contract$res, _context$contract, _context$contract$res2, _context$contract$res3;

  var methodName = (0, _case.camel)(underscoreName);
  return (0, _case.pascal)((_context$contract$res = (_context$contract = context.contract) === null || _context$contract === void 0 ? void 0 : (_context$contract$res2 = _context$contract.responses) === null || _context$contract$res2 === void 0 ? void 0 : (_context$contract$res3 = _context$contract$res2[underscoreName]) === null || _context$contract$res3 === void 0 ? void 0 : _context$contract$res3.title) !== null && _context$contract$res !== void 0 ? _context$contract$res : // after v1.1 is adopted, we can deprecate this and require the above response
  "".concat(methodName, "Response"));
}

;

var getTypeStrFromRef = function getTypeStrFromRef($ref) {
  if ($ref !== null && $ref !== void 0 && $ref.startsWith('#/definitions/')) {
    return $ref.replace('#/definitions/', '');
  }

  throw new Error('what is $ref: ' + $ref);
};

var getTypeFromRef = function getTypeFromRef($ref) {
  return t.tsTypeReference(t.identifier(getTypeStrFromRef($ref)));
};

exports.getTypeFromRef = getTypeFromRef;

var getArrayTypeFromRef = function getArrayTypeFromRef($ref) {
  return t.tsArrayType(getTypeFromRef($ref));
};

var getTypeOrRef = function getTypeOrRef(obj) {
  if (obj.type) {
    return getType(obj.type);
  }

  if (obj.$ref) {
    return getTypeFromRef(obj.$ref);
  }

  throw new Error('contact maintainers cannot find type for ' + obj);
};

var getArrayTypeFromItems = function getArrayTypeFromItems(items) {
  // passing in [{"type":"string"}]
  if (Array.isArray(items)) {
    return t.tsArrayType(t.tsArrayType(getTypeOrRef(items[0])));
  } // passing in {"items": [{"type":"string"}]}


  var detect = detectType(items.type);

  if (detect.type === 'array') {
    if (Array.isArray(items.items)) {
      return t.tsArrayType(t.tsArrayType(getTypeOrRef(items.items[0])));
    } else {
      return t.tsArrayType(getArrayTypeFromItems(items.items));
    }
  }

  return t.tsArrayType(getType(detect.type));
};

var detectType = function detectType(type) {
  var optional = false;
  var theType = '';

  if (Array.isArray(type)) {
    if (type.length !== 2) {
      throw new Error('[getType(array length)] case not handled by transpiler. contact maintainers.');
    }

    var _type = (0, _slicedToArray2["default"])(type, 2),
        nullableType = _type[0],
        nullType = _type[1];

    if (nullType !== 'null') {
      throw new Error('[getType(null)] case not handled by transpiler. contact maintainers.');
    }

    theType = nullableType;
    optional = true;
  } else {
    theType = type;
  }

  return {
    type: theType,
    optional: optional
  };
};

exports.detectType = detectType;

var getTypeInfo = function getTypeInfo(info) {
  var type = undefined;
  var optional = undefined;

  if (Array.isArray(info.anyOf)) {
    // assuming 2nd is null, but let's check to ensure
    if (info.anyOf.length !== 2) {
      throw new Error('case not handled by transpiler. contact maintainers.');
    }

    var _info$anyOf = (0, _slicedToArray2["default"])(info.anyOf, 2),
        nullableType = _info$anyOf[0],
        nullType = _info$anyOf[1];

    if ((nullType === null || nullType === void 0 ? void 0 : nullType.type) !== 'null') {
      throw new Error('[nullableType.type]: case not handled by transpiler. contact maintainers.');
    }

    if (!(nullableType !== null && nullableType !== void 0 && nullableType.$ref)) {
      if (nullableType.title) {
        type = t.tsTypeReference(t.identifier(nullableType.title));
      } else {
        throw new Error('[nullableType.title] case not handled by transpiler. contact maintainers.');
      }
    } else {
      type = getTypeFromRef(nullableType === null || nullableType === void 0 ? void 0 : nullableType.$ref);
    }

    optional = true;
  }

  if (typeof info.type === 'string') {
    if (info.type === 'array') {
      if ((0, _typeof2["default"])(info.items) === 'object' && !Array.isArray(info.items)) {
        if (info.items.$ref) {
          type = getArrayTypeFromRef(info.items.$ref);
        } else if (info.items.title) {
          type = t.tsArrayType(t.tsTypeReference(t.identifier(info.items.title)));
        } else if (info.items.type) {
          type = getArrayTypeFromItems(info.items);
        } else {
          throw new Error('[info.items] case not handled by transpiler. contact maintainers.');
        }
      } else {
        throw new Error('[info.items] case not handled by transpiler. contact maintainers.');
      }
    } else {
      var detect = detectType(info.type);
      type = getType(detect.type);
      optional = detect.optional;
    }
  }

  if (Array.isArray(info.type)) {
    // assuming 2nd is null, but let's check to ensure
    if (info.type.length !== 2) {
      throw new Error('please report this to maintainers (field type): ' + JSON.stringify(info, null, 2));
    }

    var _info$type = (0, _slicedToArray2["default"])(info.type, 2),
        _nullableType = _info$type[0],
        _nullType = _info$type[1];

    if (_nullType !== 'null') {
      throw new Error('please report this to maintainers (field type): ' + JSON.stringify(info, null, 2));
    }

    if (_nullableType === 'array' && (0, _typeof2["default"])(info.items) === 'object' && !Array.isArray(info.items)) {
      if (info.items.type) {
        var _detect = detectType(info.items.type);

        if (_detect.type === 'array') {
          // wen recursion?
          type = t.tsArrayType(getArrayTypeFromItems(info.items));
        } else {
          type = t.tsArrayType(getType(_detect.type));
        }

        optional = _detect.optional;
      } else if (info.items.$ref) {
        type = getArrayTypeFromRef(info.items.$ref); // } else if (info.items.title) {
        //   type = t.tsArrayType(
        //     t.tsTypeReference(
        //       t.identifier(info.items.title)
        //     )
        //   );
      } else if (info.items.type) {
        type = getArrayTypeFromItems(info.items);
      } else {
        throw new Error('[info.items] case not handled by transpiler. contact maintainers.');
      }
    } else {
      var _detect2 = detectType(_nullableType);

      optional = _detect2.optional;

      if (_detect2.type === 'array') {
        type = getArrayTypeFromItems(info.items);
      } else {
        type = getType(_detect2.type);
      }
    }

    optional = true;
  }

  return {
    type: type,
    optional: optional
  };
};

exports.getTypeInfo = getTypeInfo;

var getType = function getType(type) {
  switch (type) {
    case 'string':
      return t.tsStringKeyword();

    case 'boolean':
      return t.tSBooleanKeyword();

    case 'integer':
      return t.tsNumberKeyword();

    default:
      throw new Error('contact maintainers [unknown type]: ' + type);
  }
};

exports.getType = getType;

var getPropertyType = function getPropertyType(context, schema, prop) {
  var _schema$properties, _schema$required, _schema$required2;

  var props = (_schema$properties = schema.properties) !== null && _schema$properties !== void 0 ? _schema$properties : {};
  var info = props[prop];
  var type = null;
  var optional = !((_schema$required = schema.required) !== null && _schema$required !== void 0 && _schema$required.includes(prop));

  if (info.allOf && info.allOf.length === 1) {
    info = info.allOf[0];
  }

  if (typeof info.$ref === 'string') {
    type = getTypeFromRef(info.$ref);
  }

  var typeInfo = getTypeInfo(info);

  if (typeof typeInfo.optional !== 'undefined') {
    optional = typeInfo.optional;
  }

  if (typeof typeInfo.type !== 'undefined') {
    type = typeInfo.type;
  }

  if (!type) {
    throw new Error('cannot find type for ' + JSON.stringify(info));
  }

  if ((_schema$required2 = schema.required) !== null && _schema$required2 !== void 0 && _schema$required2.includes(prop)) {
    optional = false;
  }

  return {
    type: type,
    optional: optional
  };
};

exports.getPropertyType = getPropertyType;

function getPropertySignatureFromProp(context, jsonschema, prop, camelize) {
  if (jsonschema.properties[prop].type === 'object') {
    if (jsonschema.properties[prop].title) {
      return (0, _babel.propertySignature)(camelize ? (0, _case.camel)(prop) : prop, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(jsonschema.properties[prop].title))));
    } else {
      throw new Error('getPropertySignatureFromProp() contact maintainer');
    }
  }

  if (Array.isArray(jsonschema.properties[prop].allOf)) {
    var _jsonschema$required;

    var isOptional = !((_jsonschema$required = jsonschema.required) !== null && _jsonschema$required !== void 0 && _jsonschema$required.includes(prop));
    var unionTypes = jsonschema.properties[prop].allOf.map(function (el) {
      if (el.title) return el.title;
      if (el.$ref) return getTypeStrFromRef(el.$ref);
      return el.type;
    }); // @ts-ignore:next-line

    var uniqUnionTypes = (0, _toConsumableArray2["default"])(new Set(unionTypes));

    if (uniqUnionTypes.length === 1) {
      return (0, _babel.propertySignature)(camelize ? (0, _case.camel)(prop) : prop, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(uniqUnionTypes[0]))), isOptional);
    } else {
      return (0, _babel.propertySignature)(camelize ? (0, _case.camel)(prop) : prop, t.tsTypeAnnotation(t.tsUnionType(uniqUnionTypes.map(function (typ) {
        return t.tsTypeReference(t.identifier(typ));
      }))), isOptional);
    }
  } else if (Array.isArray(jsonschema.properties[prop].oneOf)) {
    var _jsonschema$required2;

    var _isOptional = !((_jsonschema$required2 = jsonschema.required) !== null && _jsonschema$required2 !== void 0 && _jsonschema$required2.includes(prop));

    var _unionTypes = jsonschema.properties[prop].oneOf.map(function (el) {
      if (el.title) return el.title;
      if (el.$ref) return getTypeStrFromRef(el.$ref);
      return el.type;
    }); // @ts-ignore:next-line


    var _uniqUnionTypes = (0, _toConsumableArray2["default"])(new Set(_unionTypes));

    if (_uniqUnionTypes.length === 1) {
      return (0, _babel.propertySignature)(camelize ? (0, _case.camel)(prop) : prop, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(_uniqUnionTypes[0]))), _isOptional);
    } else {
      return (0, _babel.propertySignature)(camelize ? (0, _case.camel)(prop) : prop, t.tsTypeAnnotation(t.tsUnionType(_uniqUnionTypes.map(function (typ) {
        return t.tsTypeReference(t.identifier(typ));
      }))), _isOptional);
    }
  }

  try {
    getPropertyType(context, jsonschema, prop);
  } catch (e) {
    console.log(e);
    console.log(JSON.stringify(jsonschema, null, 2), prop);
  }

  var _getPropertyType = getPropertyType(context, jsonschema, prop),
      type = _getPropertyType.type,
      optional = _getPropertyType.optional;

  return (0, _babel.propertySignature)(camelize ? (0, _case.camel)(prop) : prop, t.tsTypeAnnotation(type), optional);
}

var getParamsTypeAnnotation = function getParamsTypeAnnotation(context, jsonschema) {
  var _jsonschema$propertie;

  var camelize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var keys = Object.keys((_jsonschema$propertie = jsonschema.properties) !== null && _jsonschema$propertie !== void 0 ? _jsonschema$propertie : {});

  if (!keys.length && jsonschema.$ref) {
    return t.tsTypeAnnotation(getTypeFromRef(jsonschema.$ref));
  }

  if (!keys.length) return undefined;
  var typedParams = keys.map(function (prop) {
    return getPropertySignatureFromProp(context, jsonschema, prop, camelize);
  });
  return t.tsTypeAnnotation(t.tsTypeLiteral( // @ts-ignore:next-line
  (0, _toConsumableArray2["default"])(typedParams)));
};

exports.getParamsTypeAnnotation = getParamsTypeAnnotation;

var createTypedObjectParams = function createTypedObjectParams(context, jsonschema) {
  var _jsonschema$propertie2;

  var camelize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var keys = Object.keys((_jsonschema$propertie2 = jsonschema.properties) !== null && _jsonschema$propertie2 !== void 0 ? _jsonschema$propertie2 : {});

  if (!keys.length) {
    // is there a ref?
    if (jsonschema.$ref) {
      var _obj = context.refLookup(jsonschema.$ref);

      if (_obj) {
        return createTypedObjectParams(context, _obj, camelize);
      }
    } // no results...


    return;
  }

  var params = keys.map(function (prop) {
    return t.objectProperty(camelize ? t.identifier((0, _case.camel)(prop)) : t.identifier(prop), camelize ? t.identifier((0, _case.camel)(prop)) : t.identifier(prop), false, true);
  });
  var obj = t.objectPattern((0, _toConsumableArray2["default"])(params));
  obj.typeAnnotation = getParamsTypeAnnotation(context, jsonschema, camelize);
  return obj;
};

exports.createTypedObjectParams = createTypedObjectParams;