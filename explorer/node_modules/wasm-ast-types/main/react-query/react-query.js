"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createReactQueryMutationHooks = exports.createReactQueryMutationHook = exports.createReactQueryMutationArgsInterface = exports.createReactQueryHooks = exports.createReactQueryHookInterface = exports.createReactQueryHook = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var t = _interopRequireWildcard(require("@babel/types"));

var _case = require("case");

var _utils = require("../utils");

var _babel = require("../utils/babel");

var _types2 = require("../utils/types");

var _client = require("../client");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var createReactQueryHooks = function createReactQueryHooks(_ref) {
  var context = _ref.context,
      queryMsg = _ref.queryMsg,
      contractName = _ref.contractName,
      QueryClient = _ref.QueryClient;
  var options = context.options.reactQuery;
  var genericQueryInterfaceName = "".concat((0, _case.pascal)(contractName), "ReactQuery");
  var underscoreNames = (0, _utils.getMessageProperties)(queryMsg).map(function (schema) {
    return Object.keys(schema.properties)[0];
  });
  var body = [];
  var queryKeysName = "".concat((0, _case.camel)(contractName), "QueryKeys");

  if (options.queryKeys) {
    body.push(createReactQueryKeys({
      context: context,
      queryKeysName: queryKeysName,
      camelContractName: (0, _case.camel)(contractName),
      underscoreNames: underscoreNames
    }));
  }

  var queryMsgs = (0, _utils.getMessageProperties)(queryMsg).map(function (schema) {
    // list_voters
    var underscoreName = Object.keys(schema.properties)[0]; // listVoters

    var methodName = (0, _case.camel)(underscoreName); // Cw3FlexMultisigListVotersQuery

    var hookParamsTypeName = "".concat((0, _case.pascal)(contractName)).concat((0, _case.pascal)(methodName), "Query"); // useCw3FlexMultisigListVotersQuery

    var hookName = "use".concat(hookParamsTypeName); // listVotersResponse

    var responseType = (0, _types2.getResponseType)(context, underscoreName); // cw3FlexMultisigListVoters

    var getterKey = (0, _case.camel)("".concat(contractName).concat((0, _case.pascal)(methodName)));
    var jsonschema = schema.properties[underscoreName];
    return {
      underscoreName: underscoreName,
      methodName: methodName,
      hookParamsTypeName: hookParamsTypeName,
      hookName: hookName,
      responseType: responseType,
      getterKey: getterKey,
      jsonschema: jsonschema
    };
  });
  var queryFactoryName = "".concat((0, _case.camel)(contractName), "Queries");

  if (options.queryFactory) {
    body.push(createReactQueryFactory({
      context: context,
      queryFactoryName: queryFactoryName,
      queryKeysName: queryKeysName,
      queryMsgs: queryMsgs
    }));
  }

  body.push(createReactQueryHookGenericInterface({
    context: context,
    QueryClient: QueryClient,
    genericQueryInterfaceName: genericQueryInterfaceName
  }));
  body.push.apply(body, (0, _toConsumableArray2["default"])(queryMsgs.reduce(function (m, _ref2) {
    var methodName = _ref2.methodName,
        hookParamsTypeName = _ref2.hookParamsTypeName,
        hookName = _ref2.hookName,
        responseType = _ref2.responseType,
        getterKey = _ref2.getterKey,
        jsonschema = _ref2.jsonschema;
    return [createReactQueryHookInterface({
      context: context,
      hookParamsTypeName: hookParamsTypeName,
      responseType: responseType,
      queryInterfaceName: genericQueryInterfaceName,
      QueryClient: QueryClient,
      jsonschema: jsonschema
    }), createReactQueryHook({
      context: context,
      methodName: methodName,
      hookName: hookName,
      hookParamsTypeName: hookParamsTypeName,
      queryKeysName: queryKeysName,
      responseType: responseType,
      hookKeyName: getterKey,
      jsonschema: jsonschema
    })].concat((0, _toConsumableArray2["default"])(m));
  }, [])));
  return body;
};

exports.createReactQueryHooks = createReactQueryHooks;

function buildQueryFn(methodName, jsonschema, options) {
  var _jsonschema$propertie;

  var keys = Object.keys((_jsonschema$propertie = jsonschema.properties) !== null && _jsonschema$propertie !== void 0 ? _jsonschema$propertie : {});
  var args = [];

  if (keys.length) {
    args = [t.objectExpression((0, _toConsumableArray2["default"])(keys.map(function (prop) {
      return t.objectProperty(t.identifier((0, _case.camel)(prop)), t.memberExpression(t.identifier('args'), t.identifier((0, _case.camel)(prop))));
    })))];
  }

  var rejectInvalidClient = t.callExpression(t.memberExpression(t.identifier('Promise'), t.identifier('reject')), [t.newExpression(t.identifier('Error'), [t.stringLiteral('Invalid client')])]);
  return t.arrowFunctionExpression([], (0, _babel.optionalConditionalExpression)(t.identifier('client'), t.callExpression(t.memberExpression(t.identifier('client'), t.identifier(methodName)), args), rejectInvalidClient, options.optionalClient), false);
}

var ENABLED_QUERY_OPTION = t.objectProperty(t.identifier('enabled'), t.logicalExpression('&&', t.unaryExpression('!', t.unaryExpression('!', t.identifier('client'))), t.conditionalExpression( // explicitly check for undefined
t.binaryExpression('!=', t.optionalMemberExpression(t.identifier('options'), t.identifier('enabled'), false, true), t.identifier('undefined')), t.memberExpression(t.identifier('options'), t.identifier('enabled')), t.booleanLiteral(true))));

function buildQueryOptions(options) {
  return options.optionalClient ? t.objectExpression([t.spreadElement(t.identifier('options')), t.objectProperty(t.identifier('enabled'), t.logicalExpression('&&', t.unaryExpression('!', t.unaryExpression('!', t.identifier('client'))), t.conditionalExpression( // explicitly check for undefined
  t.binaryExpression('!=', t.optionalMemberExpression(t.identifier('options'), t.identifier('enabled'), false, true), t.identifier('undefined')), t.memberExpression(t.identifier('options'), t.identifier('enabled')), t.booleanLiteral(true))))]) : t.identifier('options');
}

var createReactQueryHook = function createReactQueryHook(_ref3) {
  var _jsonschema$propertie2;

  var context = _ref3.context,
      hookName = _ref3.hookName,
      hookParamsTypeName = _ref3.hookParamsTypeName,
      responseType = _ref3.responseType,
      hookKeyName = _ref3.hookKeyName,
      queryKeysName = _ref3.queryKeysName,
      methodName = _ref3.methodName,
      jsonschema = _ref3.jsonschema;
  context.addUtil('useQuery');
  context.addUtil('UseQueryOptions');
  var options = context.options.reactQuery;
  var keys = Object.keys((_jsonschema$propertie2 = jsonschema.properties) !== null && _jsonschema$propertie2 !== void 0 ? _jsonschema$propertie2 : {});
  var props = ['client', 'options'];

  if (keys.length) {
    props = ['client', 'args', 'options'];
  }

  var selectResponseGenericTypeName = GENERIC_SELECT_RESPONSE_NAME;
  var queryFunctionDeclaration = t.functionDeclaration(t.identifier(hookName), [(0, _utils.tsObjectPattern)((0, _toConsumableArray2["default"])(props.map(function (prop) {
    return t.objectProperty(t.identifier(prop), t.identifier(prop), false, true);
  })), t.tsTypeAnnotation(t.tsTypeReference(t.identifier(hookParamsTypeName), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(selectResponseGenericTypeName))]))))], t.blockStatement([t.returnStatement((0, _utils.callExpression)(t.identifier('useQuery'), [generateUseQueryQueryKey({
    hookKeyName: hookKeyName,
    queryKeysName: queryKeysName,
    methodName: methodName,
    props: props,
    options: options
  }), buildQueryFn(methodName, jsonschema, options), buildQueryOptions(options)], t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(responseType)), t.tsTypeReference(t.identifier('Error')), t.tsTypeReference(t.identifier(selectResponseGenericTypeName))])))])); // Add the TData type parameters

  queryFunctionDeclaration.typeParameters = t.tsTypeParameterDeclaration([t.tsTypeParameter(undefined, t.tSTypeReference(t.identifier(responseType)), selectResponseGenericTypeName)]);
  return t.exportNamedDeclaration(queryFunctionDeclaration);
};

exports.createReactQueryHook = createReactQueryHook;

/**
 * Example:
```
export interface Cw4UpdateMembersMutation {
  client: Cw4GroupClient
  args: {
    tokenId: string
    remove: string[]
  }
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, Pick<Cw4UpdateMembersMutation, 'args'>>,
    'mutationFn'
  >
}
```
 */
var createReactQueryMutationArgsInterface = function createReactQueryMutationArgsInterface(_ref4) {
  var context = _ref4.context,
      ExecuteClient = _ref4.ExecuteClient,
      mutationHookParamsTypeName = _ref4.mutationHookParamsTypeName,
      useMutationTypeParameter = _ref4.useMutationTypeParameter,
      jsonschema = _ref4.jsonschema;
  var typedUseMutationOptions = t.tsTypeReference(t.identifier('UseMutationOptions'), useMutationTypeParameter);
  var body = [(0, _utils.tsPropertySignature)(t.identifier('client'), t.tsTypeAnnotation(t.tsTypeReference(t.identifier(ExecuteClient))), false)];
  var msgType = (0, _types2.getParamsTypeAnnotation)(context, jsonschema);

  if (msgType) {
    body.push(t.tsPropertySignature(t.identifier('msg'), msgType));
  }

  context.addUtil('StdFee');
  context.addUtil('Coin'); //  fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]

  var optionalArgs = t.tsPropertySignature(t.identifier('args'), t.tsTypeAnnotation( // @ts-ignore:next-line
  t.tsTypeLiteral(_client.FIXED_EXECUTE_PARAMS.map(function (param) {
    return (0, _babel.propertySignature)(param.name, // @ts-ignore:next-line
    param.typeAnnotation, param.optional);
  }))));
  optionalArgs.optional = true;
  body.push(optionalArgs);
  return t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier(mutationHookParamsTypeName), null, [], t.tsInterfaceBody(body)));
};

exports.createReactQueryMutationArgsInterface = createReactQueryMutationArgsInterface;

var createReactQueryMutationHooks = function createReactQueryMutationHooks(_ref5) {
  var context = _ref5.context,
      execMsg = _ref5.execMsg,
      contractName = _ref5.contractName,
      ExecuteClient = _ref5.ExecuteClient;
  // merge the user options with the defaults
  return (0, _utils.getMessageProperties)(execMsg).reduce(function (m, schema) {
    var _jsonschema$propertie3, _Object$keys;

    // update_members
    var execMethodUnderscoreName = Object.keys(schema.properties)[0]; // updateMembers

    var execMethodName = (0, _case.camel)(execMethodUnderscoreName); // Cw20UpdateMembersMutation

    var mutationHookParamsTypeName = "".concat((0, _case.pascal)(contractName)).concat((0, _case.pascal)(execMethodName), "Mutation"); // useCw20UpdateMembersMutation

    var mutationHookName = "use".concat(mutationHookParamsTypeName);
    var jsonschema = schema.properties[execMethodUnderscoreName];
    var properties = (_jsonschema$propertie3 = jsonschema.properties) !== null && _jsonschema$propertie3 !== void 0 ? _jsonschema$propertie3 : {}; // TODO: there should be a better way to do this

    var hasMsg = !!((_Object$keys = Object.keys(properties)) !== null && _Object$keys !== void 0 && _Object$keys.length || jsonschema !== null && jsonschema !== void 0 && jsonschema.$ref); // <ExecuteResult, Error, Cw4UpdateMembersMutation>

    var useMutationTypeParameter = generateMutationTypeParameter(context, mutationHookParamsTypeName);
    return [createReactQueryMutationArgsInterface({
      context: context,
      mutationHookParamsTypeName: mutationHookParamsTypeName,
      ExecuteClient: ExecuteClient,
      jsonschema: jsonschema,
      useMutationTypeParameter: useMutationTypeParameter
    }), createReactQueryMutationHook({
      context: context,
      execMethodName: execMethodName,
      mutationHookName: mutationHookName,
      mutationHookParamsTypeName: mutationHookParamsTypeName,
      hasMsg: hasMsg,
      useMutationTypeParameter: useMutationTypeParameter
    })].concat((0, _toConsumableArray2["default"])(m));
  }, []);
};
/**
 * Generates the mutation type parameter. If args exist, we use a pick. If not, we just return the params type.
 */


exports.createReactQueryMutationHooks = createReactQueryMutationHooks;

var generateMutationTypeParameter = function generateMutationTypeParameter(context, mutationHookParamsTypeName) {
  context.addUtil('ExecuteResult');
  return t.tsTypeParameterInstantiation([// Data
  t.tSTypeReference(t.identifier('ExecuteResult')), // Error
  t.tsTypeReference(t.identifier('Error')), // Variables
  t.tsTypeReference(t.identifier(mutationHookParamsTypeName))]);
};

/**
 *
 * Example:
```
export const useCw4UpdateMembersMutation = ({ client, options }: Omit<Cw4UpdateMembersMutation, 'args'>) =>
  useMutation<ExecuteResult, Error, Pick<Cw4UpdateMembersMutation, 'args'>>(
    ({ args }) => client.updateMembers(args),
    options
  )
```
 */
var createReactQueryMutationHook = function createReactQueryMutationHook(_ref6) {
  var context = _ref6.context,
      mutationHookName = _ref6.mutationHookName,
      mutationHookParamsTypeName = _ref6.mutationHookParamsTypeName,
      execMethodName = _ref6.execMethodName,
      useMutationTypeParameter = _ref6.useMutationTypeParameter,
      hasMsg = _ref6.hasMsg;
  context.addUtil('useMutation');
  context.addUtil('UseMutationOptions');
  var useMutationFunctionArgs = [(0, _babel.shorthandProperty)('client')];
  if (hasMsg) useMutationFunctionArgs.push((0, _babel.shorthandProperty)('msg'));
  useMutationFunctionArgs.push(t.objectProperty(t.identifier('args'), t.assignmentPattern(t.objectPattern(_client.FIXED_EXECUTE_PARAMS.map(function (param) {
    return (0, _babel.shorthandProperty)(param.name);
  })), t.objectExpression([]))));
  return t.exportNamedDeclaration(t.functionDeclaration(t.identifier(mutationHookName), [(0, _utils.identifier)('options', t.tsTypeAnnotation((0, _babel.omitTypeReference)(t.tsTypeReference(t.identifier('UseMutationOptions'), useMutationTypeParameter), 'mutationFn')), true)], t.blockStatement([t.returnStatement((0, _utils.callExpression)(t.identifier('useMutation'), [t.arrowFunctionExpression([t.objectPattern(useMutationFunctionArgs)], t.callExpression(t.memberExpression(t.identifier('client'), t.identifier(execMethodName)), (hasMsg ? [t.identifier('msg')] : []).concat(_client.FIXED_EXECUTE_PARAMS.map(function (param) {
    return t.identifier(param.name);
  }))), false // not async
  ), t.identifier('options')], useMutationTypeParameter))])));
};

exports.createReactQueryMutationHook = createReactQueryMutationHook;

function createReactQueryKeys(_ref7) {
  var context = _ref7.context,
      queryKeysName = _ref7.queryKeysName,
      camelContractName = _ref7.camelContractName,
      underscoreNames = _ref7.underscoreNames;
  var options = context.options.reactQuery;
  var contractAddressTypeAnnotation = t.tsTypeAnnotation(options.optionalClient ? t.tsUnionType([t.tsStringKeyword(), t.tsUndefinedKeyword()]) : t.tSStringKeyword());
  return t.exportNamedDeclaration(t.variableDeclaration('const', [t.variableDeclarator(t.identifier(queryKeysName), t.objectExpression([// 1: contract
  t.objectProperty(t.identifier('contract'), t.tSAsExpression(t.arrayExpression([t.objectExpression([t.objectProperty(t.identifier('contract'), t.stringLiteral(camelContractName))])]), t.tSTypeReference(t.identifier('const')))), // 2: address
  t.objectProperty(t.identifier('address'), t.arrowFunctionExpression([(0, _utils.identifier)('contractAddress', contractAddressTypeAnnotation)], t.tSAsExpression(t.arrayExpression([t.objectExpression([// 1
  t.spreadElement(t.memberExpression(t.memberExpression(t.identifier(queryKeysName), t.identifier('contract')), t.numericLiteral(0), true // computed
  )), t.objectProperty(t.identifier('address'), t.identifier('contractAddress'))])]), t.tSTypeReference(t.identifier('const')))))].concat((0, _toConsumableArray2["default"])(underscoreNames.map(function (underscoreMethodName) {
    return t.objectProperty( // key id is the camel method name
    t.identifier((0, _case.camel)(underscoreMethodName)), t.arrowFunctionExpression([(0, _utils.identifier)('contractAddress', contractAddressTypeAnnotation), (0, _utils.identifier)('args', // Record<string, unknown>
    t.tSTypeAnnotation(t.tsTypeReference(t.identifier('Record'), t.tsTypeParameterInstantiation([t.tsStringKeyword(), t.tsUnknownKeyword()]))), true // optional
    )], t.tSAsExpression(t.arrayExpression([t.objectExpression([//...cw3FlexMultisigQueryKeys.address(contractAddress)[0]
    t.spreadElement(t.memberExpression(t.callExpression(t.memberExpression(t.identifier(queryKeysName), t.identifier('address')), [t.identifier('contractAddress')]), t.numericLiteral(0), true // computed
    )), // method: list_voters
    t.objectProperty(t.identifier('method'), t.stringLiteral(underscoreMethodName)), // args
    (0, _babel.shorthandProperty)('args')])]), t.tSTypeReference(t.identifier('const')))));
  })))))]));
}

function createReactQueryFactory(_ref8) {
  var context = _ref8.context,
      queryFactoryName = _ref8.queryFactoryName,
      queryKeysName = _ref8.queryKeysName,
      queryMsgs = _ref8.queryMsgs;
  var options = context.options.reactQuery;
  return t.exportNamedDeclaration(t.variableDeclaration('const', [t.variableDeclarator(t.identifier(queryFactoryName), t.objectExpression((0, _toConsumableArray2["default"])(queryMsgs.map(function (_ref9) {
    var _jsonschema$propertie4;

    var methodName = _ref9.methodName,
        hookParamsTypeName = _ref9.hookParamsTypeName,
        responseType = _ref9.responseType,
        jsonschema = _ref9.jsonschema;
    var hasArgs = Object.keys((_jsonschema$propertie4 = jsonschema.properties) !== null && _jsonschema$propertie4 !== void 0 ? _jsonschema$propertie4 : {}).length > 0;
    var methodQueryOptionsFn = t.arrowFunctionExpression([(0, _utils.tsObjectPattern)([(0, _babel.shorthandProperty)('client')].concat((0, _toConsumableArray2["default"])(hasArgs ? [(0, _babel.shorthandProperty)('args')] : []), [(0, _babel.shorthandProperty)('options')]), t.tsTypeAnnotation(t.tsTypeReference(t.identifier(hookParamsTypeName), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(GENERIC_SELECT_RESPONSE_NAME))]))))], t.objectExpression([// 1: queryKey
    t.objectProperty(t.identifier('queryKey'), t.callExpression(t.memberExpression(t.identifier(queryKeysName), t.identifier(methodName)), [t.optionalMemberExpression(t.identifier('client'), t.identifier('contractAddress'), false, true)].concat((0, _toConsumableArray2["default"])(hasArgs ? [t.identifier('args')] : [])))), // 2: queryFn
    t.objectProperty(t.identifier('queryFn'), buildQueryFn(methodName, jsonschema, options)), // 3: spread options
    t.spreadElement(t.identifier('options')), // 4. enabled
    ENABLED_QUERY_OPTION]));
    methodQueryOptionsFn.typeParameters = t.tsTypeParameterDeclaration([t.tsTypeParameter(undefined, t.tsTypeReference(t.identifier(responseType)), GENERIC_SELECT_RESPONSE_NAME)]);
    methodQueryOptionsFn.returnType = t.tsTypeAnnotation(t.tsTypeReference(t.identifier('UseQueryOptions'), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(responseType)), t.tsTypeReference(t.identifier('Error')), t.tsTypeReference(t.identifier(GENERIC_SELECT_RESPONSE_NAME))])));
    return t.objectProperty( // key id is the camel method name
    t.identifier((0, _case.camel)(methodName)), methodQueryOptionsFn);
  }))))]));
}

var GENERIC_SELECT_RESPONSE_NAME = 'TData';

function createReactQueryHookGenericInterface(_ref10) {
  var context = _ref10.context,
      QueryClient = _ref10.QueryClient,
      genericQueryInterfaceName = _ref10.genericQueryInterfaceName;
  var options = context.options.reactQuery;
  var genericResponseTypeName = 'TResponse';
  context.addUtil('UseQueryOptions'); // UseQueryOptions<TResponse, Error, TData>,

  var typedUseQueryOptions = t.tsTypeReference(t.identifier('UseQueryOptions'), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(genericResponseTypeName)), t.tsTypeReference(t.identifier('Error')), t.tsTypeReference(t.identifier(GENERIC_SELECT_RESPONSE_NAME))]));
  var body = [(0, _utils.tsPropertySignature)(t.identifier('client'), t.tsTypeAnnotation(options.optionalClient ? t.tsUnionType([t.tsTypeReference(t.identifier(QueryClient)), t.tsUndefinedKeyword()]) : t.tsTypeReference(t.identifier(QueryClient))), false), (0, _utils.tsPropertySignature)(t.identifier('options'), t.tsTypeAnnotation(options.version === 'v4' ? t.tSIntersectionType([(0, _babel.omitTypeReference)(typedUseQueryOptions, "'queryKey' | 'queryFn' | 'initialData'"), t.tSTypeLiteral([t.tsPropertySignature(t.identifier('initialData?'), t.tsTypeAnnotation(t.tsUndefinedKeyword()))])]) : typedUseQueryOptions), true)];
  return t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier(genericQueryInterfaceName), t.tsTypeParameterDeclaration([// 1: TResponse
  t.tsTypeParameter(undefined, undefined, genericResponseTypeName), // 2: TData
  t.tsTypeParameter(undefined, t.tSTypeReference(t.identifier(genericResponseTypeName)), GENERIC_SELECT_RESPONSE_NAME)]), [], t.tSInterfaceBody(body)));
}

var createReactQueryHookInterface = function createReactQueryHookInterface(_ref11) {
  var context = _ref11.context,
      QueryClient = _ref11.QueryClient,
      hookParamsTypeName = _ref11.hookParamsTypeName,
      queryInterfaceName = _ref11.queryInterfaceName,
      responseType = _ref11.responseType,
      jsonschema = _ref11.jsonschema;
  // merge the user options with the defaults
  var options = context.options.reactQuery;
  var body = [];
  var props = getProps(context, jsonschema);

  if (props.length) {
    body.push(t.tsPropertySignature(t.identifier('args'), t.tsTypeAnnotation( // @ts-ignore:next-line
    t.tsTypeLiteral(props))));
  }

  return t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier(hookParamsTypeName), t.tsTypeParameterDeclaration([t.tSTypeParameter(undefined, undefined, GENERIC_SELECT_RESPONSE_NAME)]), [t.tSExpressionWithTypeArguments(t.identifier(queryInterfaceName), t.tsTypeParameterInstantiation([// 1: response
  t.tsTypeReference(t.identifier(responseType)), // 2: select generic
  t.tSTypeReference(t.identifier(GENERIC_SELECT_RESPONSE_NAME))]))], t.tsInterfaceBody(body)));
};

exports.createReactQueryHookInterface = createReactQueryHookInterface;

var getProps = function getProps(context, jsonschema) {
  var _jsonschema$propertie5;

  var keys = Object.keys((_jsonschema$propertie5 = jsonschema.properties) !== null && _jsonschema$propertie5 !== void 0 ? _jsonschema$propertie5 : {});
  if (!keys.length) return [];
  return keys.map(function (prop) {
    var _getPropertyType = (0, _types2.getPropertyType)(context, jsonschema, prop),
        type = _getPropertyType.type,
        optional = _getPropertyType.optional;

    return (0, _babel.propertySignature)(context.options.reactQuery.camelize ? (0, _case.camel)(prop) : prop, t.tsTypeAnnotation(type), optional);
  });
};

var generateUseQueryQueryKey = function generateUseQueryQueryKey(_ref12) {
  var hookKeyName = _ref12.hookKeyName,
      queryKeysName = _ref12.queryKeysName,
      methodName = _ref12.methodName,
      props = _ref12.props,
      options = _ref12.options;
  var optionalClient = options.optionalClient,
      queryKeys = options.queryKeys;
  var hasArgs = props.includes('args');
  var contractAddressExpression = t.optionalMemberExpression(t.identifier('client'), t.identifier('contractAddress'), false, optionalClient);

  if (queryKeys) {
    var callArgs = [contractAddressExpression];
    if (hasArgs) callArgs.push(t.identifier('args'));
    return t.callExpression(t.memberExpression(t.identifier(queryKeysName), t.identifier((0, _case.camel)(methodName))), callArgs);
  }

  var queryKey = [t.stringLiteral(hookKeyName), contractAddressExpression];

  if (hasArgs) {
    queryKey.push(t.callExpression(t.memberExpression(t.identifier('JSON'), t.identifier('stringify')), [t.identifier('args')]));
  }

  return t.arrayExpression(queryKey);
};