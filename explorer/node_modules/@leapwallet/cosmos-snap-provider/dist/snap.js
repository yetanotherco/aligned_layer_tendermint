"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.experimentalSuggestChain = exports.suggestChain = exports.isLocalSnap = exports.getKey = exports.requestSignAmino = exports.requestSignature = exports.getSnap = exports.connectSnap = exports.getSnaps = void 0;
const long_1 = __importDefault(require("long"));
const config_1 = require("./config");
/**
 * The fool proof version of getting the ethereum provider suggested by
 * https://github.com/Montoya/snap-connect-test/blob/0dad2dd53ab2ecbf4b4369230d3aaaeca08c6dae/index.html#L41
 *
 * @returns the ethereum provider which supports snaps
 */
const getProvider = async () => {
    let mmFound = false;
    if ('detected' in window.ethereum) {
        for (const provider of window.ethereum.detected) {
            try {
                // Detect snaps support
                await provider.request({
                    method: 'wallet_getSnaps',
                });
                // enforces MetaMask as provider
                window.ethereum.setProvider(provider);
                mmFound = true;
                return provider;
            }
            catch (_a) {
                // no-op
            }
        }
    }
    if (!mmFound && 'providers' in window.ethereum) {
        for (const provider of window.ethereum.providers) {
            try {
                // Detect snaps support
                await provider.request({
                    method: 'wallet_getSnaps',
                });
                window.ethereum = provider;
                mmFound = true;
                return provider;
            }
            catch (_b) {
                // no-op
            }
        }
    }
    return window.ethereum;
};
const sendReqToSnap = async (method, params) => {
    const provider = await getProvider();
    return provider.request({
        method: 'wallet_invokeSnap',
        params: {
            snapId: config_1.defaultSnapOrigin,
            request: {
                method,
                params,
            },
        },
    });
};
/**
 * Get the installed snaps in MetaMask.
 *
 * @returns The snaps installed in MetaMask.
 */
const getSnaps = async () => {
    const provider = await getProvider();
    return (await provider.request({
        method: 'wallet_getSnaps',
    }));
};
exports.getSnaps = getSnaps;
/**
 * Connect a snap to MetaMask.
 *
 * @param snapId - The ID of the snap.
 * @param params - The params to pass with the snap to connect.
 */
const connectSnap = async (snapId = config_1.defaultSnapOrigin, params = {}) => {
    const provider = await getProvider();
    return provider.request({
        method: 'wallet_requestSnaps',
        params: {
            [snapId]: params,
        },
    });
};
exports.connectSnap = connectSnap;
/**
 * Get the snap from MetaMask.
 *
 * @param version - The version of the snap to install (optional).
 * @returns The snap object returned by the extension.
 */
const getSnap = async (version) => {
    try {
        const snaps = await (0, exports.getSnaps)();
        return Object.values(snaps).find((snap) => snap.id === config_1.defaultSnapOrigin && (!version || snap.version === version));
    }
    catch (e) {
        console.log('Failed to obtain installed snap', e);
        return undefined;
    }
};
exports.getSnap = getSnap;
const requestSignature = async (chainId, signerAddress, signDoc) => {
    const signature = await sendReqToSnap('signDirect', {
        chainId,
        signerAddress,
        signDoc,
    });
    const { accountNumber } = signDoc;
    const modifiedAccountNumber = new long_1.default((accountNumber === null || accountNumber === void 0 ? void 0 : accountNumber.low) || 0, accountNumber === null || accountNumber === void 0 ? void 0 : accountNumber.high, accountNumber === null || accountNumber === void 0 ? void 0 : accountNumber.unsigned);
    const modifiedSignature = {
        signature: signature.signature,
        signed: Object.assign(Object.assign({}, signature.signed), { accountNumber: `${modifiedAccountNumber.toString()}`, authInfoBytes: new Uint8Array(Object.values(signature.signed.authInfoBytes)), bodyBytes: new Uint8Array(Object.values(signature.signed.bodyBytes)) }),
    };
    return modifiedSignature;
};
exports.requestSignature = requestSignature;
const requestSignAmino = async (chainId, signerAddress, signDoc, { isADR36 = false } = {}) => {
    const signResponse = (await sendReqToSnap('signAmino', {
        chainId,
        signerAddress,
        signDoc,
        isADR36,
    }));
    return signResponse;
};
exports.requestSignAmino = requestSignAmino;
const getKey = async (chainId) => {
    const accountData = await sendReqToSnap('getKey', {
        chainId,
    });
    if (!accountData) {
        throw new Error('No account data found');
    }
    accountData.pubkey = Uint8Array.from(Object.values(accountData.pubkey));
    return accountData;
};
exports.getKey = getKey;
const isLocalSnap = (snapId) => snapId.startsWith('local:');
exports.isLocalSnap = isLocalSnap;
const suggestChain = async (chainInfo) => {
    return await sendReqToSnap('suggestChain', {
        chainInfo,
    });
};
exports.suggestChain = suggestChain;
// For supporting existing providers.
exports.experimentalSuggestChain = exports.suggestChain;
//# sourceMappingURL=snap.js.map