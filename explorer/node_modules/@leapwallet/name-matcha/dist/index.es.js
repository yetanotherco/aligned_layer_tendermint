var z = Object.defineProperty;
var R = (e, r, t) => r in e ? z(e, r, { enumerable: !0, configurable: !0, writable: !0, value: t }) : e[r] = t;
var w = (e, r, t) => (R(e, typeof r != "symbol" ? r + "" : r, t), t);
import { CosmWasmClient as W } from "@cosmjs/cosmwasm-stargate";
var y = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", S = {};
for (var v = 0; v < y.length; v++) {
  var O = y.charAt(v);
  if (S[O] !== void 0)
    throw new TypeError(O + " is ambiguous");
  S[O] = v;
}
function l(e) {
  var r = e >> 25;
  return (e & 33554431) << 5 ^ -(r >> 0 & 1) & 996825010 ^ -(r >> 1 & 1) & 642813549 ^ -(r >> 2 & 1) & 513874426 ^ -(r >> 3 & 1) & 1027748829 ^ -(r >> 4 & 1) & 705979059;
}
function E(e) {
  for (var r = 1, t = 0; t < e.length; ++t) {
    var n = e.charCodeAt(t);
    if (n < 33 || n > 126)
      return "Invalid prefix (" + e + ")";
    r = l(r) ^ n >> 5;
  }
  for (r = l(r), t = 0; t < e.length; ++t) {
    var c = e.charCodeAt(t);
    r = l(r) ^ c & 31;
  }
  return r;
}
function $(e, r, t) {
  if (t = t || 90, e.length + 7 + r.length > t)
    throw new TypeError("Exceeds length limit");
  e = e.toLowerCase();
  var n = E(e);
  if (typeof n == "string")
    throw new Error(n);
  for (var c = e + "1", s = 0; s < r.length; ++s) {
    var o = r[s];
    if (o >> 5)
      throw new Error("Non 5-bit word");
    n = l(n) ^ o, c += y.charAt(o);
  }
  for (s = 0; s < 6; ++s)
    n = l(n);
  for (n ^= 1, s = 0; s < 6; ++s) {
    var a = n >> (5 - s) * 5 & 31;
    c += y.charAt(a);
  }
  return c;
}
function q(e, r) {
  if (r = r || 90, e.length < 8)
    return e + " too short";
  if (e.length > r)
    return "Exceeds length limit";
  var t = e.toLowerCase(), n = e.toUpperCase();
  if (e !== t && e !== n)
    return "Mixed-case string " + e;
  e = t;
  var c = e.lastIndexOf("1");
  if (c === -1)
    return "No separator character for " + e;
  if (c === 0)
    return "Missing prefix for " + e;
  var s = e.slice(0, c), o = e.slice(c + 1);
  if (o.length < 6)
    return "Data too short";
  var a = E(s);
  if (typeof a == "string")
    return a;
  for (var i = [], u = 0; u < o.length; ++u) {
    var m = o.charAt(u), A = S[m];
    if (A === void 0)
      return "Unknown character " + m;
    a = l(a) ^ A, !(u + 6 >= o.length) && i.push(A);
  }
  return a !== 1 ? "Invalid checksum for " + e : { prefix: s, words: i };
}
function V() {
  var e = q.apply(null, arguments);
  if (typeof e == "object")
    return e;
}
function P(e) {
  var r = q.apply(null, arguments);
  if (typeof r == "object")
    return r;
  throw new Error(r);
}
function x(e, r, t, n) {
  for (var c = 0, s = 0, o = (1 << t) - 1, a = [], i = 0; i < e.length; ++i)
    for (c = c << r | e[i], s += r; s >= t; )
      s -= t, a.push(c >> s & o);
  if (n)
    s > 0 && a.push(c << t - s & o);
  else {
    if (s >= r)
      return "Excess padding";
    if (c << t - s & o)
      return "Non-zero padding";
  }
  return a;
}
function T(e) {
  var r = x(e, 8, 5, !0);
  if (Array.isArray(r))
    return r;
}
function G(e) {
  var r = x(e, 8, 5, !0);
  if (Array.isArray(r))
    return r;
  throw new Error(r);
}
function K(e) {
  var r = x(e, 5, 8, !1);
  if (Array.isArray(r))
    return r;
}
function J(e) {
  var r = x(e, 5, 8, !1);
  if (Array.isArray(r))
    return r;
  throw new Error(r);
}
var f = {
  decodeUnsafe: V,
  decode: P,
  encode: $,
  toWordsUnsafe: T,
  toWords: G,
  fromWordsUnsafe: K,
  fromWords: J
}, h = /* @__PURE__ */ ((e) => (e.NETWORK = "network", e.NOT_FOUND = "not-found", e.UNREGISTERED_SERVICE = "unregistered-service", e.DUPLICATE_SERVICE = "duplicate-service", e.INVALID_ADDRESS = "invalid-address", e))(h || {});
class d extends Error {
  constructor(t, n) {
    super(t);
    w(this, "type");
    this.name = "MatchaError", this.type = n;
  }
}
const g = class {
};
let p = g;
w(p, "clients", {}), w(p, "getClient", async (r) => {
  let t = g.clients[r];
  return t === void 0 && (t = await W.connect(r), g.clients[r] = t), t;
});
class N {
  /**
   * @param network The network to use
   */
  getCosmWasmClient(r) {
    return p.getClient(r);
  }
}
const D = {
  mainnet: "https://rpc.cosmos.directory/osmosis",
  testnet: "https://rpc-test.osmosis.zone"
}, U = "icns";
class Q extends N {
  constructor() {
    super(...arguments);
    w(this, "serviceID", U);
    w(this, "chain", "osmosis");
    w(this, "contractAddress", {
      mainnet: "osmo1xk0s8xgktn9x5vwcgtjdxqzadg88fgn33p8u9cnpdxwemvxscvast52cdd",
      testnet: "osmo1q2qpencrnnlamwalxt6tac2ytl35z5jejn0v4frnp6jff7gwp37sjcnhu5"
    });
  }
  async resolve(t, n, c) {
    var i;
    const s = await this.getCosmWasmClient(D[n]), [o, a] = t.split(".");
    try {
      const u = await (s == null ? void 0 : s.queryContractSmart(
        this.contractAddress[n],
        {
          address: {
            name: o,
            bech32_prefix: a
          }
        }
      ));
      if (!(u != null && u.address) || ((i = c == null ? void 0 : c.icns) == null ? void 0 : i.indexOf(a)) === -1)
        throw new d("", h.NOT_FOUND);
      return u.address;
    } catch {
      throw new d("", h.NOT_FOUND);
    }
  }
  async lookup(t, n) {
    const c = await this.getCosmWasmClient(D[n]), s = {
      prefix: null,
      words: null
    };
    try {
      const { prefix: o, words: a } = f.decode(t);
      s.prefix = o, s.words = a;
    } catch {
      throw new d("", h.INVALID_ADDRESS);
    }
    try {
      const o = await (c == null ? void 0 : c.queryContractSmart(
        this.contractAddress[n],
        {
          primary_name: {
            address: t
          }
        }
      ));
      if (!(o != null && o.name))
        throw new d("", h.NOT_FOUND);
      return `${o.name}.${s.prefix}`;
    } catch {
      throw new d("", h.NOT_FOUND);
    }
  }
}
const _ = {
  mainnet: "https://rpc.cosmos.directory/juno",
  testnet: "https://rpc.uni.kingnodes.com"
}, I = "ibcDomains";
class X extends N {
  constructor() {
    super(...arguments);
    w(this, "serviceID", I);
    w(this, "chain", "juno");
    w(this, "contractAddress", {
      mainnet: "juno1ce7wjfsuk79t2mdvpdjtv8280pcc64yh9mh62qptuvxe64twt4pqa68z2a",
      testnet: "juno19al2ptpxz3xk6q8nl3eyvyslkz8g6nz25w48dfpaepwaxavq3mhqsjjqe5"
    });
  }
  async resolve(t, n, c) {
    var i;
    const s = await this.getCosmWasmClient(_[n]), [o, a] = t.split(".");
    try {
      const u = await (s == null ? void 0 : s.queryContractSmart(
        this.contractAddress[n],
        {
          owner_of: {
            token_id: o
          }
        }
      ));
      if (!(u != null && u.owner) || ((i = c == null ? void 0 : c.ibcDomains) == null ? void 0 : i.indexOf(a)) === -1)
        throw new d("", h.NOT_FOUND);
      try {
        const { words: m } = f.decode(u.owner);
        return f.encode(a, m);
      } catch {
        throw new d("", h.NOT_FOUND);
      }
    } catch {
      throw new d("", h.NOT_FOUND);
    }
  }
  async lookup(t, n) {
    const c = await this.getCosmWasmClient(_[n]), s = {
      prefix: null,
      words: null
    };
    try {
      const { prefix: a, words: i } = f.decode(t);
      s.prefix = a, s.words = i;
    } catch {
      throw new d("", h.INVALID_ADDRESS);
    }
    const o = f.encode("juno", s.words);
    try {
      const a = await (c == null ? void 0 : c.queryContractSmart(
        this.contractAddress[n],
        {
          primary_domain: {
            address: o
          }
        }
      ));
      if (!(a != null && a.domain))
        throw new d("", h.NOT_FOUND);
      return `${a.domain}.${s.prefix}`;
    } catch {
      throw new d("", h.NOT_FOUND);
    }
  }
}
const C = {
  mainnet: "https://rpc.cosmos.directory/stargaze",
  testnet: "https://rpc.elgafar-1.stargaze-apis.com"
}, b = "stargazeNames";
class Y extends N {
  constructor() {
    super(...arguments);
    w(this, "serviceID", b);
    w(this, "chain", "stargaze");
    w(this, "contractAddress", {
      mainnet: "stars1fx74nkqkw2748av8j7ew7r3xt9cgjqduwn8m0ur5lhe49uhlsasszc5fhr",
      testnet: "stars1rp5ttjvd5g0vlpltrkyvq62tcrdz949gjtpah000ynh4n2laz52qarz2z8"
    });
  }
  async resolve(t, n, c) {
    var i;
    const s = await this.getCosmWasmClient(C[n]), [o, a] = t.split(".");
    try {
      const u = await s.queryContractSmart(
        this.contractAddress[n],
        {
          associated_address: {
            name: o
          }
        }
      );
      if (!u || ((i = c == null ? void 0 : c.stargazeNames) == null ? void 0 : i.indexOf(a)) === -1)
        throw new d("", h.NOT_FOUND);
      try {
        const { words: m } = f.decode(u);
        return f.encode(a, m);
      } catch {
        throw new d("", h.NOT_FOUND);
      }
    } catch {
      throw new d("", h.NOT_FOUND);
    }
  }
  async lookup(t, n) {
    const c = await this.getCosmWasmClient(C[n]), s = {
      prefix: null,
      words: null
    };
    try {
      const { prefix: o, words: a } = f.decode(t);
      s.prefix = o, s.words = a;
    } catch {
      throw new d("", h.INVALID_ADDRESS);
    }
    try {
      return `${await c.queryContractSmart(
        this.contractAddress[n],
        {
          name: {
            address: t
          }
        }
      )}.${s.prefix}`;
    } catch {
      throw new d("", h.NOT_FOUND);
    }
  }
}
const j = {
  mainnet: "https://rpc.mainnet.archway.io",
  testnet: "https://rpc.constantine.archway.tech"
}, F = "archIds";
class Z extends N {
  constructor() {
    super(...arguments);
    w(this, "serviceID", F);
    w(this, "chain", "archway");
    w(this, "contractAddress", {
      mainnet: "archway1275jwjpktae4y4y0cdq274a2m0jnpekhttnfuljm6n59wnpyd62qppqxq0",
      testnet: "archway1lr8rstt40s697hqpedv2nvt27f4cuccqwvly9gnvuszxmcevrlns60xw4r"
    });
  }
  // reference: https://gist.github.com/drewstaylor/088af645dd36c013c02a2b4d05110479#file-archid-resolve-address-js
  async resolve(t, n, c) {
    var a;
    const s = await this.getCosmWasmClient(j[n]), [, o] = t.split(".");
    try {
      const i = await (s == null ? void 0 : s.queryContractSmart(
        this.contractAddress[n],
        {
          resolve_record: {
            name: t
          }
        }
      ));
      if (!(i != null && i.address) || ((a = c == null ? void 0 : c.archIds) == null ? void 0 : a.indexOf(o)) === -1)
        throw new d("", h.NOT_FOUND);
      return i.address;
    } catch {
      throw new d("", h.NOT_FOUND);
    }
  }
  // reference: https://gist.github.com/drewstaylor/088af645dd36c013c02a2b4d05110479#file-archid-check-domains-resolve-to-address-js
  async lookup(t, n) {
    var o;
    const c = await this.getCosmWasmClient(j[n]), s = {
      prefix: null,
      words: null
    };
    try {
      const { prefix: a, words: i } = f.decode(t);
      s.prefix = a, s.words = i;
    } catch {
      throw new d("", h.INVALID_ADDRESS);
    }
    try {
      const a = await (c == null ? void 0 : c.queryContractSmart(
        this.contractAddress[n],
        {
          resolve_address: {
            address: t
          }
        }
      ));
      if (!(a != null && a.names) || !((o = a == null ? void 0 : a.names) != null && o.length))
        throw new d("", h.NOT_FOUND);
      return a.names.join(", ");
    } catch {
      throw new d("", h.NOT_FOUND);
    }
  }
}
const k = [
  "agoric",
  "akash",
  "arkh",
  "axelar",
  "band",
  "bcna",
  "bitsong",
  "bostrom",
  "cerberus",
  "certik",
  "cheqd",
  "chihuahua",
  "chronic",
  "comdex",
  "cosmos",
  "crc",
  "cre",
  "cro",
  "cudos",
  "darc",
  "decentr",
  "desmos",
  "dig",
  "echelon",
  "emoney",
  "evmos",
  "fetch",
  "firma",
  "galaxy",
  "genesis",
  "gravity",
  "iaa",
  "inj",
  "ixo",
  "juno",
  "kava",
  "ki",
  "like",
  "logos",
  "lum",
  "mantle",
  "mars",
  "meme",
  "micro",
  "mythos",
  "nomic",
  "octa",
  "odin",
  "orai",
  "osmo",
  "panacea",
  "pb",
  "persistence",
  "regen",
  "rizon",
  "secret",
  "sent",
  "sif",
  "somm",
  "star",
  "stars",
  "swth",
  "terra",
  "thor",
  "umee",
  "vdl",
  "kujira",
  "sei",
  "stride",
  "jkl",
  "tori",
  "omniflix",
  "canto",
  "pasg",
  "archway",
  "quasar",
  "neutron",
  "testcore",
  "core",
  "quick",
  "migaloo",
  "kyve",
  "onomy",
  "noble",
  "plq",
  "nolus",
  "c4e",
  "gitopia",
  "nibi",
  "maya",
  "empower",
  "dydx"
], B = {
  icns: k,
  ibcDomains: k,
  stargazeNames: k,
  archIds: ["arch"]
}, rr = {
  icns: U,
  ibcDomains: I,
  stargazeNames: b,
  archIds: F
}, tr = B;
class H {
  constructor(r) {
    w(this, "services", {});
    this.network = r, this.network = r, this.registerService(new Q()), this.registerService(new X()), this.registerService(new Y()), this.registerService(new Z());
  }
  registerService(r) {
    if (this.services[r.serviceID])
      throw new d(
        "Service already registered",
        h.DUPLICATE_SERVICE
      );
    this.services[r.serviceID] = r;
  }
  getService(r) {
    const t = this.services[r];
    if (!t)
      throw new d(
        "Service not registered",
        h.UNREGISTERED_SERVICE
      );
    return t;
  }
  listServices() {
    return Object.keys(this.services);
  }
  setNetwork(r) {
    this.network = r;
  }
  getNetwork() {
    return this.network;
  }
  async resolve(r, t, n) {
    return this.getService(t).resolve(r, this.network, n);
  }
  async lookup(r, t) {
    return this.getService(t).lookup(r, this.network);
  }
  async resolveAll(r, t) {
    const n = {};
    return await Promise.all(
      Object.entries(this.services).map(async ([c, s]) => {
        try {
          const o = await s.resolve(
            r,
            this.network,
            t
          );
          n[c] = o;
        } catch {
          n[c] = null;
        }
      })
    ), n;
  }
  async lookupAll(r) {
    const t = {};
    return await Promise.all(
      Object.entries(this.services).map(async ([n, c]) => {
        try {
          const s = await c.lookup(r, this.network);
          t[n] = s;
        } catch {
          t[n] = null;
        }
      })
    ), t;
  }
}
const er = new H("mainnet");
export {
  tr as allowedTopLevelDomains,
  er as default,
  rr as services
};
//# sourceMappingURL=index.es.js.map
