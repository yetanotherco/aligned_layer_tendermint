import {
  __commonJS
} from "./chunk-2GTGKKMZ.js";

// node_modules/long/umd/index.js
var require_umd = __commonJS({
  "node_modules/long/umd/index.js"(exports, module) {
    var Long = function(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = void 0;
      var wasm = null;
      try {
        wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
      } catch (e) {
      }
      function Long2(low, high, unsigned) {
        this.low = low | 0;
        this.high = high | 0;
        this.unsigned = !!unsigned;
      }
      Long2.prototype.__isLong__;
      Object.defineProperty(Long2.prototype, "__isLong__", {
        value: true
      });
      function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
      }
      function ctz32(value) {
        var c = Math.clz32(value & -value);
        return value ? 31 - c : c;
      }
      Long2.isLong = isLong;
      var INT_CACHE = {};
      var UINT_CACHE = {};
      function fromInt(value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
          value >>>= 0;
          if (cache = 0 <= value && value < 256) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = fromBits(value, 0, true);
          if (cache)
            UINT_CACHE[value] = obj;
          return obj;
        } else {
          value |= 0;
          if (cache = -128 <= value && value < 128) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = fromBits(value, value < 0 ? -1 : 0, false);
          if (cache)
            INT_CACHE[value] = obj;
          return obj;
        }
      }
      Long2.fromInt = fromInt;
      function fromNumber(value, unsigned) {
        if (isNaN(value))
          return unsigned ? UZERO : ZERO;
        if (unsigned) {
          if (value < 0)
            return UZERO;
          if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
        } else {
          if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
          if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
        }
        if (value < 0)
          return fromNumber(-value, unsigned).neg();
        return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
      }
      Long2.fromNumber = fromNumber;
      function fromBits(lowBits, highBits, unsigned) {
        return new Long2(lowBits, highBits, unsigned);
      }
      Long2.fromBits = fromBits;
      var pow_dbl = Math.pow;
      function fromString(str, unsigned, radix) {
        if (str.length === 0)
          throw Error("empty string");
        if (typeof unsigned === "number") {
          radix = unsigned;
          unsigned = false;
        } else {
          unsigned = !!unsigned;
        }
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
          return unsigned ? UZERO : ZERO;
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        var p;
        if ((p = str.indexOf("-")) > 0)
          throw Error("interior hyphen");
        else if (p === 0) {
          return fromString(str.substring(1), unsigned, radix).neg();
        }
        var radixToPower = fromNumber(pow_dbl(radix, 8));
        var result = ZERO;
        for (var i = 0; i < str.length; i += 8) {
          var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
          if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
          } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
          }
        }
        result.unsigned = unsigned;
        return result;
      }
      Long2.fromString = fromString;
      function fromValue(val, unsigned) {
        if (typeof val === "number")
          return fromNumber(val, unsigned);
        if (typeof val === "string")
          return fromString(val, unsigned);
        return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
      }
      Long2.fromValue = fromValue;
      var TWO_PWR_16_DBL = 1 << 16;
      var TWO_PWR_24_DBL = 1 << 24;
      var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
      var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
      var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
      var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
      var ZERO = fromInt(0);
      Long2.ZERO = ZERO;
      var UZERO = fromInt(0, true);
      Long2.UZERO = UZERO;
      var ONE = fromInt(1);
      Long2.ONE = ONE;
      var UONE = fromInt(1, true);
      Long2.UONE = UONE;
      var NEG_ONE = fromInt(-1);
      Long2.NEG_ONE = NEG_ONE;
      var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
      Long2.MAX_VALUE = MAX_VALUE;
      var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
      Long2.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
      var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
      Long2.MIN_VALUE = MIN_VALUE;
      var LongPrototype = Long2.prototype;
      LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
      };
      LongPrototype.toNumber = function toNumber() {
        if (this.unsigned)
          return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
      };
      LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        if (this.isZero())
          return "0";
        if (this.isNegative()) {
          if (this.eq(MIN_VALUE)) {
            var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
          } else
            return "-" + this.neg().toString(radix);
        }
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
        var result = "";
        while (true) {
          var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero())
            return digits + result;
          else {
            while (digits.length < 6)
              digits = "0" + digits;
            result = "" + digits + result;
          }
        }
      };
      LongPrototype.getHighBits = function getHighBits() {
        return this.high;
      };
      LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
      };
      LongPrototype.getLowBits = function getLowBits() {
        return this.low;
      };
      LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
      };
      LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative())
          return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
          if ((val & 1 << bit) != 0)
            break;
        return this.high != 0 ? bit + 33 : bit + 1;
      };
      LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
      };
      LongPrototype.eqz = LongPrototype.isZero;
      LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
      };
      LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
      };
      LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
      };
      LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
      };
      LongPrototype.equals = function equals(other) {
        if (!isLong(other))
          other = fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
          return false;
        return this.high === other.high && this.low === other.low;
      };
      LongPrototype.eq = LongPrototype.equals;
      LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(
          /* validates */
          other
        );
      };
      LongPrototype.neq = LongPrototype.notEquals;
      LongPrototype.ne = LongPrototype.notEquals;
      LongPrototype.lessThan = function lessThan(other) {
        return this.comp(
          /* validates */
          other
        ) < 0;
      };
      LongPrototype.lt = LongPrototype.lessThan;
      LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) <= 0;
      };
      LongPrototype.lte = LongPrototype.lessThanOrEqual;
      LongPrototype.le = LongPrototype.lessThanOrEqual;
      LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(
          /* validates */
          other
        ) > 0;
      };
      LongPrototype.gt = LongPrototype.greaterThan;
      LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) >= 0;
      };
      LongPrototype.gte = LongPrototype.greaterThanOrEqual;
      LongPrototype.ge = LongPrototype.greaterThanOrEqual;
      LongPrototype.compare = function compare(other) {
        if (!isLong(other))
          other = fromValue(other);
        if (this.eq(other))
          return 0;
        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
          return -1;
        if (!thisNeg && otherNeg)
          return 1;
        if (!this.unsigned)
          return this.sub(other).isNegative() ? -1 : 1;
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
      };
      LongPrototype.comp = LongPrototype.compare;
      LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE))
          return MIN_VALUE;
        return this.not().add(ONE);
      };
      LongPrototype.neg = LongPrototype.negate;
      LongPrototype.add = function add(addend) {
        if (!isLong(addend))
          addend = fromValue(addend);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 65535;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 + b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend))
          subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
      };
      LongPrototype.sub = LongPrototype.subtract;
      LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero())
          return this;
        if (!isLong(multiplier))
          multiplier = fromValue(multiplier);
        if (wasm) {
          var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        if (multiplier.isZero())
          return this.unsigned ? UZERO : ZERO;
        if (this.eq(MIN_VALUE))
          return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE))
          return this.isOdd() ? MIN_VALUE : ZERO;
        if (this.isNegative()) {
          if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
          else
            return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
          return this.mul(multiplier.neg()).neg();
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
          return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 65535;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.mul = LongPrototype.multiply;
      LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor))
          divisor = fromValue(divisor);
        if (divisor.isZero())
          throw Error("division by zero");
        if (wasm) {
          if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
            return this;
          }
          var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high);
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        if (this.isZero())
          return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
          if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
              return MIN_VALUE;
            else if (divisor.eq(MIN_VALUE))
              return ONE;
            else {
              var halfThis = this.shr(1);
              approx = halfThis.div(divisor).shl(1);
              if (approx.eq(ZERO)) {
                return divisor.isNegative() ? ONE : NEG_ONE;
              } else {
                rem = this.sub(divisor.mul(approx));
                res = approx.add(rem.div(divisor));
                return res;
              }
            }
          } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
          if (this.isNegative()) {
            if (divisor.isNegative())
              return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
          } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
          res = ZERO;
        } else {
          if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
          if (divisor.gt(this))
            return UZERO;
          if (divisor.gt(this.shru(1)))
            return UONE;
          res = UZERO;
        }
        rem = this;
        while (rem.gte(divisor)) {
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
          var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
          while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
          }
          if (approxRes.isZero())
            approxRes = ONE;
          res = res.add(approxRes);
          rem = rem.sub(approxRem);
        }
        return res;
      };
      LongPrototype.div = LongPrototype.divide;
      LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor))
          divisor = fromValue(divisor);
        if (wasm) {
          var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(this.low, this.high, divisor.low, divisor.high);
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        return this.sub(this.div(divisor).mul(divisor));
      };
      LongPrototype.mod = LongPrototype.modulo;
      LongPrototype.rem = LongPrototype.modulo;
      LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
      };
      LongPrototype.countLeadingZeros = function countLeadingZeros() {
        return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
      };
      LongPrototype.clz = LongPrototype.countLeadingZeros;
      LongPrototype.countTrailingZeros = function countTrailingZeros() {
        return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
      };
      LongPrototype.ctz = LongPrototype.countTrailingZeros;
      LongPrototype.and = function and(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
      };
      LongPrototype.or = function or(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
      };
      LongPrototype.xor = function xor(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
      };
      LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
        else
          return fromBits(0, this.low << numBits - 32, this.unsigned);
      };
      LongPrototype.shl = LongPrototype.shiftLeft;
      LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
        else
          return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      };
      LongPrototype.shr = LongPrototype.shiftRight;
      LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        if (numBits < 32)
          return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
        if (numBits === 32)
          return fromBits(this.high, 0, this.unsigned);
        return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
      };
      LongPrototype.shru = LongPrototype.shiftRightUnsigned;
      LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
      LongPrototype.rotateLeft = function rotateLeft(numBits) {
        var b;
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        if (numBits === 32)
          return fromBits(this.high, this.low, this.unsigned);
        if (numBits < 32) {
          b = 32 - numBits;
          return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
        }
        numBits -= 32;
        b = 32 - numBits;
        return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
      };
      LongPrototype.rotl = LongPrototype.rotateLeft;
      LongPrototype.rotateRight = function rotateRight(numBits) {
        var b;
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        if (numBits === 32)
          return fromBits(this.high, this.low, this.unsigned);
        if (numBits < 32) {
          b = 32 - numBits;
          return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
        }
        numBits -= 32;
        b = 32 - numBits;
        return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
      };
      LongPrototype.rotr = LongPrototype.rotateRight;
      LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned)
          return this;
        return fromBits(this.low, this.high, false);
      };
      LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned)
          return this;
        return fromBits(this.low, this.high, true);
      };
      LongPrototype.toBytes = function toBytes(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
      };
      LongPrototype.toBytesLE = function toBytesLE() {
        var hi = this.high, lo = this.low;
        return [lo & 255, lo >>> 8 & 255, lo >>> 16 & 255, lo >>> 24, hi & 255, hi >>> 8 & 255, hi >>> 16 & 255, hi >>> 24];
      };
      LongPrototype.toBytesBE = function toBytesBE() {
        var hi = this.high, lo = this.low;
        return [hi >>> 24, hi >>> 16 & 255, hi >>> 8 & 255, hi & 255, lo >>> 24, lo >>> 16 & 255, lo >>> 8 & 255, lo & 255];
      };
      Long2.fromBytes = function fromBytes(bytes, unsigned, le) {
        return le ? Long2.fromBytesLE(bytes, unsigned) : Long2.fromBytesBE(bytes, unsigned);
      };
      Long2.fromBytesLE = function fromBytesLE(bytes, unsigned) {
        return new Long2(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
      };
      Long2.fromBytesBE = function fromBytesBE(bytes, unsigned) {
        return new Long2(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
      };
      var _default = Long2;
      exports2.default = _default;
      return "default" in exports2 ? exports2.default : exports2;
    }({});
    if (typeof define === "function" && define.amd)
      define([], function() {
        return Long;
      });
    else if (typeof module === "object" && typeof exports === "object")
      module.exports = Long;
  }
});

// node_modules/@leapwallet/cosmos-snap-provider/dist/config.js
var require_config = __commonJS({
  "node_modules/@leapwallet/cosmos-snap-provider/dist/config.js"(exports) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultSnapOrigin = void 0;
    exports.defaultSnapOrigin = (_a = process.env.SNAP_ORIGIN) !== null && _a !== void 0 ? _a : `npm:@leapwallet/metamask-cosmos-snap`;
  }
});

// node_modules/@leapwallet/cosmos-snap-provider/dist/snap.js
var require_snap = __commonJS({
  "node_modules/@leapwallet/cosmos-snap-provider/dist/snap.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.experimentalSuggestChain = exports.suggestChain = exports.isLocalSnap = exports.getKey = exports.requestSignAmino = exports.requestSignature = exports.getSnap = exports.connectSnap = exports.getSnaps = void 0;
    var long_1 = __importDefault(require_umd());
    var config_1 = require_config();
    var getProvider = async () => {
      let mmFound = false;
      if ("detected" in window.ethereum) {
        for (const provider of window.ethereum.detected) {
          try {
            await provider.request({
              method: "wallet_getSnaps"
            });
            window.ethereum.setProvider(provider);
            mmFound = true;
            return provider;
          } catch (_a) {
          }
        }
      }
      if (!mmFound && "providers" in window.ethereum) {
        for (const provider of window.ethereum.providers) {
          try {
            await provider.request({
              method: "wallet_getSnaps"
            });
            window.ethereum = provider;
            mmFound = true;
            return provider;
          } catch (_b) {
          }
        }
      }
      return window.ethereum;
    };
    var sendReqToSnap = async (method, params) => {
      const provider = await getProvider();
      return provider.request({
        method: "wallet_invokeSnap",
        params: {
          snapId: config_1.defaultSnapOrigin,
          request: {
            method,
            params
          }
        }
      });
    };
    var getSnaps = async () => {
      const provider = await getProvider();
      return await provider.request({
        method: "wallet_getSnaps"
      });
    };
    exports.getSnaps = getSnaps;
    var connectSnap = async (snapId = config_1.defaultSnapOrigin, params = {}) => {
      const provider = await getProvider();
      return provider.request({
        method: "wallet_requestSnaps",
        params: {
          [snapId]: params
        }
      });
    };
    exports.connectSnap = connectSnap;
    var getSnap = async (version) => {
      try {
        const snaps = await (0, exports.getSnaps)();
        return Object.values(snaps).find((snap) => snap.id === config_1.defaultSnapOrigin && (!version || snap.version === version));
      } catch (e) {
        console.log("Failed to obtain installed snap", e);
        return void 0;
      }
    };
    exports.getSnap = getSnap;
    var requestSignature = async (chainId, signerAddress, signDoc) => {
      const signature = await sendReqToSnap("signDirect", {
        chainId,
        signerAddress,
        signDoc
      });
      const { accountNumber } = signDoc;
      const modifiedAccountNumber = new long_1.default((accountNumber === null || accountNumber === void 0 ? void 0 : accountNumber.low) || 0, accountNumber === null || accountNumber === void 0 ? void 0 : accountNumber.high, accountNumber === null || accountNumber === void 0 ? void 0 : accountNumber.unsigned);
      const modifiedSignature = {
        signature: signature.signature,
        signed: Object.assign(Object.assign({}, signature.signed), { accountNumber: `${modifiedAccountNumber.toString()}`, authInfoBytes: new Uint8Array(Object.values(signature.signed.authInfoBytes)), bodyBytes: new Uint8Array(Object.values(signature.signed.bodyBytes)) })
      };
      return modifiedSignature;
    };
    exports.requestSignature = requestSignature;
    var requestSignAmino = async (chainId, signerAddress, signDoc, { isADR36 = false } = {}) => {
      const signResponse = await sendReqToSnap("signAmino", {
        chainId,
        signerAddress,
        signDoc,
        isADR36
      });
      return signResponse;
    };
    exports.requestSignAmino = requestSignAmino;
    var getKey = async (chainId) => {
      const accountData = await sendReqToSnap("getKey", {
        chainId
      });
      if (!accountData) {
        throw new Error("No account data found");
      }
      accountData.pubkey = Uint8Array.from(Object.values(accountData.pubkey));
      return accountData;
    };
    exports.getKey = getKey;
    var isLocalSnap = (snapId) => snapId.startsWith("local:");
    exports.isLocalSnap = isLocalSnap;
    var suggestChain = async (chainInfo) => {
      return await sendReqToSnap("suggestChain", {
        chainInfo
      });
    };
    exports.suggestChain = suggestChain;
    exports.experimentalSuggestChain = exports.suggestChain;
  }
});

// node_modules/@leapwallet/cosmos-snap-provider/dist/types.js
var require_types = __commonJS({
  "node_modules/@leapwallet/cosmos-snap-provider/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports, module) {
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: " ",
          // non-breaking space
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v, b) {
          var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
          if (!(x instanceof BigNumber2))
            return new BigNumber2(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++)
                  ;
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v)))
                return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            if ((i = str.search(/e/i)) > 0) {
              if (e < 0)
                e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {
              e = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber2(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0)
                return parseNumeric(x, str, isNum, b);
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e = i = 0;
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                if (c == ".") {
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            if ((e = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            else
              e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++)
            ;
          for (len = str.length; str.charCodeAt(--len) === 48; )
            ;
          if (str = str.slice(i, ++len)) {
            len -= i;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x.s * v);
            }
            if ((e = e - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE;
              if (e < 0)
                i += LOG_BASE;
              if (i < len) {
                if (i)
                  x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE; i < len; ) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }
                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str += "0")
                ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        BigNumber2.clone = clone;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object")
                  FORMAT = v;
                else
                  throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true)
            return false;
          if (!BigNumber2.DEBUG)
            return true;
          var i, n, c = v.c, e = v.e, s = v.s;
          out:
            if ({}.toString.call(c) == "[object Array]") {
              if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
                if (c[0] === 0) {
                  if (e === 0 && c.length === 1)
                    return true;
                  break out;
                }
                i = (e + 1) % LOG_BASE;
                if (i < 1)
                  i += LOG_BASE;
                if (String(c[0]).length == i) {
                  for (i = 0; i < c.length; i++) {
                    n = c[i];
                    if (n < 0 || n >= BASE || n !== mathfloor(n))
                      break out;
                  }
                  if (n !== 0)
                    return true;
                }
              }
            } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
              return true;
            }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, -1);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, 1);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
            if (dp == null)
              dp = DECIMAL_PLACES;
            else
              intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15)
                  c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--)
              ;
            if (i < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
                ;
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
                ;
              if (i < LOG_BASE)
                e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i < args.length; )
            sum = sum.plus(args[i++]);
          return sum;
        };
        convertBase = function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i = 0, len = str.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
                ;
              arr[0] += alphabet.indexOf(str.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null)
                    arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint(coeffToString(x.c), x.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop())
              ;
            if (!xc[0])
              return alphabet.charAt(0);
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d = e + dp + 1;
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; )
                ;
              for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
                ;
              str = toFixedPoint(str, e, alphabet.charAt(0));
            }
            return str;
          };
        }();
        div = function() {
          function multiply(x, k, base) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base;
            }
            if (carry)
              x = [carry].concat(x);
            return x;
          }
          function compare2(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1))
              ;
          }
          return function(x, y, dp, rm, base) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                  xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                )
              );
            }
            q = new BigNumber2(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base) {
              base = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++)
              ;
            if (yc[i] > (xc[i] || 0))
              e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0)
                ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2)
                yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL)
                    rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base)
                      n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL)
                    prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0])
                qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
                ;
              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format(n, i, rm, id) {
          var c0, e, ne, len, str;
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          if (!n.c)
            return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber2(n), i, rm);
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
              for (; len < i; str += "0", len++)
                ;
              str = toExponential(str, e);
            } else {
              i -= ne;
              str = toFixedPoint(str, e, "0");
              if (e + 1 > len) {
                if (--i > 0)
                  for (str += "."; i--; str += "0")
                    ;
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len)
                    str += ".";
                  for (; i--; str += "0")
                    ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, n) {
          var k, y, i = 1, x = new BigNumber2(args[0]);
          for (; i < args.length; i++) {
            y = new BigNumber2(args[i]);
            if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
              x = y;
            }
          }
          return x;
        }
        function normalise(n, c, e) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop())
            ;
          for (j = c[0]; j >= 10; j /= 10, i++)
            ;
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b) {
            var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base ? p1 : m;
                });
                if (b) {
                  base = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s)
                  return new BigNumber2(s, base);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
                ;
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = mathfloor(n / pows10[d - j - 1] % 10);
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0))
                      ;
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++)
                    ;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + d;
                  rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
                }
              }
              r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                      ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++)
                      ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE)
                        xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE)
                      break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop())
                ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        function valueOf(n) {
          var str, e = n.e;
          if (e === null)
            return n.toString();
          str = coeffToString(n.c);
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber2(this);
          if (x.s < 0)
            x.s = 1;
          return x;
        };
        P.comparedTo = function(y, b) {
          return compare(this, new BigNumber2(y, b));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c, n, v, x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(new BigNumber2(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c))
            return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v])
            for (; v % 10 == 0; v /= 10, n--)
              ;
          if (n < 0)
            n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b) {
          return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b) {
          return div(this, new BigNumber2(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m != null)
            m = new BigNumber2(m);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s)
              return new BigNumber2(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp)
              x = x.mod(m);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            if (x.e > -1)
              k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg)
              n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c)
                break;
              if (k) {
                if (y.c.length > k)
                  y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i) {
              i = mathfloor(i / 2);
              if (i === 0)
                break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i = +valueOf(n);
                if (i === 0)
                  break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k)
                x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp)
            return y;
          if (nIsNeg)
            y = ONE.div(y);
          return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n = new BigNumber2(this);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b) {
          return compare(this, new BigNumber2(y, b)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b) {
          var i, j, t, xLTy, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0))
              ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
          }
          b = (j = yc.length) - (i = xc.length);
          if (b > 0)
            for (; b--; xc[i++] = 0)
              ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b)
                ;
              --xc[i];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye)
            ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s, x = this;
          y = new BigNumber2(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber2(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1)
            y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i = xcL;
            xcL = ycL;
            ycL = i;
          }
          for (i = xcL + ycL, zc = []; i--; zc.push(0))
            ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P.negated = function() {
          var x = new BigNumber2(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function(y, b) {
          var t, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0])
              return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0))
              ;
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b = a;
          }
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c, n, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(new BigNumber2(x), sd, rm);
          }
          if (!(c = x.c))
            return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--)
              ;
            for (v = c[0]; v >= 10; v /= 10, n++)
              ;
          }
          if (sd && x.e + 1 > n)
            n = x.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0)
              n += "0";
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber2(n);
          } else {
            r = new BigNumber2(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3)
              s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e)
                  --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format2) {
          var str, x = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format2);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i = g1;
              g1 = g2;
              g2 = i;
              len -= i;
            }
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1)
                intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0)
                intPart += groupSeparator + intDigits.slice(i);
              if (isNeg)
                intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format2.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P.toFraction = function(md) {
          var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md != null) {
            n = new BigNumber2(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc)
            return new BigNumber2(x);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s = coeffToString(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1)
              break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
            div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null)
            intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };
        P.toString = function(b) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0)
                str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
            }
            if (s < 0 && n.c[0])
              str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null)
          BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s)
            ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; )
          ;
        return r.slice(0, j + 1 || 1);
      }
      function compare(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j)
          return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b)
          return a ? b ? 0 : -j : i;
        if (i != j)
          return i;
        a = i < 0;
        b = k == l;
        if (!xc || !yc)
          return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b)
          return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++)
          if (xc[i] != yc[i])
            return xc[i] > yc[i] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      function toFixedPoint(str, e, z) {
        var len, zs;
        if (e < 0) {
          for (zs = z + "."; ++e; zs += z)
            ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z)
              ;
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      BigNumber = clone();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports);
  }
});

// node_modules/@leapwallet/cosmos-snap-provider/dist/helper/gas.js
var require_gas = __commonJS({
  "node_modules/@leapwallet/cosmos-snap-provider/dist/helper/gas.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toSmall = exports.getGasPriceForChainName = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var defaultDecimals = 6;
    var getGasPriceForChainName = async (chainName, gasLevel = "average") => {
      var _a;
      const gasPriceRegistry = await fetch("https://assets.leapwallet.io/cosmos-registry/v1/gas/gas-prices.json");
      if (!gasPriceRegistry.ok) {
        throw new Error(`Failed to get Gas price ${gasPriceRegistry.status}`);
      }
      const gasPrices = await gasPriceRegistry.json();
      console.log(gasPrices, chainName, gasLevel);
      return (_a = gasPrices === null || gasPrices === void 0 ? void 0 : gasPrices[chainName]) === null || _a === void 0 ? void 0 : _a[gasLevel];
    };
    exports.getGasPriceForChainName = getGasPriceForChainName;
    function toSmall(quantity, decimals = defaultDecimals) {
      return new bignumber_js_1.default(quantity).times(Math.pow(10, decimals)).toFixed().toString();
    }
    exports.toSmall = toSmall;
  }
});

// node_modules/@leapwallet/cosmos-snap-provider/dist/constants/chainInfo.js
var require_chainInfo = __commonJS({
  "node_modules/@leapwallet/cosmos-snap-provider/dist/constants/chainInfo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Chains = {
      "eightball-1": {
        chainId: "eightball-1",
        chainName: "8ball",
        bech32Config: {
          bech32PrefixAccAddr: "8ball"
        },
        bip44: {
          coinType: 118
        },
        denom: "uebl",
        decimals: 6
      },
      "agoric-3": {
        chainId: "agoric-3",
        chainName: "agoric",
        bech32Config: {
          bech32PrefixAccAddr: "agoric"
        },
        bip44: {
          coinType: 564
        },
        denom: "ubld",
        decimals: 6
      },
      "akashnet-2": {
        chainId: "akashnet-2",
        chainName: "akash",
        bech32Config: {
          bech32PrefixAccAddr: "akash"
        },
        bip44: {
          coinType: 118
        },
        denom: "uakt",
        decimals: 6
      },
      "archway-1": {
        chainId: "archway-1",
        chainName: "archway",
        bech32Config: {
          bech32PrefixAccAddr: "archway"
        },
        bip44: {
          coinType: 118
        },
        denom: "aarch",
        decimals: 18
      },
      arkh: {
        chainId: "arkh",
        chainName: "arkh",
        bech32Config: {
          bech32PrefixAccAddr: "arkh"
        },
        bip44: {
          coinType: 118
        },
        denom: "arkh",
        decimals: 6
      },
      "xstaxy-1": {
        chainId: "xstaxy-1",
        chainName: "aura",
        bech32Config: {
          bech32PrefixAccAddr: "aura"
        },
        bip44: {
          coinType: 118
        },
        denom: "uaura",
        decimals: 6
      },
      "axelar-dojo-1": {
        chainId: "axelar-dojo-1",
        chainName: "axelar",
        bech32Config: {
          bech32PrefixAccAddr: "axelar"
        },
        bip44: {
          coinType: 118
        },
        denom: "uaxl",
        decimals: 6
      },
      "laozi-mainnet": {
        chainId: "laozi-mainnet",
        chainName: "bandchain",
        bech32Config: {
          bech32PrefixAccAddr: "band"
        },
        bip44: {
          coinType: 494
        },
        denom: "uband",
        decimals: 6
      },
      "beezee-1": {
        chainId: "beezee-1",
        chainName: "beezee",
        bech32Config: {
          bech32PrefixAccAddr: "bze"
        },
        bip44: {
          coinType: 118
        },
        denom: "ubze",
        decimals: 6
      },
      "bitcanna-1": {
        chainId: "bitcanna-1",
        chainName: "bitcanna",
        bech32Config: {
          bech32PrefixAccAddr: "bcna"
        },
        bip44: {
          coinType: 118
        },
        denom: "ubcna",
        decimals: 6
      },
      "bitsong-2b": {
        chainId: "bitsong-2b",
        chainName: "bitsong",
        bech32Config: {
          bech32PrefixAccAddr: "bitsong"
        },
        bip44: {
          coinType: 639
        },
        denom: "ubtsg",
        decimals: 6
      },
      "bluzelle-9": {
        chainId: "bluzelle-9",
        chainName: "bluzelle",
        bech32Config: {
          bech32PrefixAccAddr: "bluzelle"
        },
        bip44: {
          coinType: 483
        },
        denom: "ubnt",
        decimals: 6
      },
      bostrom: {
        chainId: "bostrom",
        chainName: "bostrom",
        bech32Config: {
          bech32PrefixAccAddr: "bostrom"
        },
        bip44: {
          coinType: 118
        },
        denom: "boot",
        decimals: 0
      },
      "carbon-1": {
        chainId: "carbon-1",
        chainName: "carbon",
        bech32Config: {
          bech32PrefixAccAddr: "swth"
        },
        bip44: {
          coinType: 118
        },
        denom: "swth",
        decimals: 8
      },
      "perun-1": {
        chainId: "perun-1",
        chainName: "chain4energy",
        bech32Config: {
          bech32PrefixAccAddr: "c4e"
        },
        bip44: {
          coinType: 4444
        },
        denom: "uc4e",
        decimals: 6
      },
      "cheqd-mainnet-1": {
        chainId: "cheqd-mainnet-1",
        chainName: "cheqd",
        bech32Config: {
          bech32PrefixAccAddr: "cheqd"
        },
        bip44: {
          coinType: 118
        },
        denom: "ncheq",
        decimals: 9
      },
      "morocco-1": {
        chainId: "morocco-1",
        chainName: "chronicnetwork",
        bech32Config: {
          bech32PrefixAccAddr: "chronic"
        },
        bip44: {
          coinType: 118
        },
        denom: "ucht",
        decimals: 6
      },
      "comdex-1": {
        chainId: "comdex-1",
        chainName: "comdex",
        bech32Config: {
          bech32PrefixAccAddr: "comdex"
        },
        bip44: {
          coinType: 118
        },
        denom: "ucmdx",
        decimals: 6
      },
      "commercio-3": {
        chainId: "commercio-3",
        chainName: "commercionetwork",
        bech32Config: {
          bech32PrefixAccAddr: "did:com:"
        },
        bip44: {
          coinType: 701
        },
        denom: "ucommercio",
        decimals: 6
      },
      "centauri-1": {
        chainId: "centauri-1",
        chainName: "composable",
        bech32Config: {
          bech32PrefixAccAddr: "centauri"
        },
        bip44: {
          coinType: 118
        },
        denom: "ppica",
        decimals: 12
      },
      "coreum-mainnet-1": {
        chainId: "coreum-mainnet-1",
        chainName: "coreum",
        bech32Config: {
          bech32PrefixAccAddr: "core"
        },
        bip44: {
          coinType: 990
        },
        denom: "ucore",
        decimals: 6
      },
      "cosmoshub-4": {
        chainId: "cosmoshub-4",
        chainName: "cosmoshub",
        bech32Config: {
          bech32PrefixAccAddr: "cosmos"
        },
        bip44: {
          coinType: 118
        },
        denom: "uatom",
        decimals: 6
      },
      "crescent-1": {
        chainId: "crescent-1",
        chainName: "crescent",
        bech32Config: {
          bech32PrefixAccAddr: "cre"
        },
        bip44: {
          coinType: 118
        },
        denom: "ucre",
        decimals: 6
      },
      "crypto-org-chain-mainnet-1": {
        chainId: "crypto-org-chain-mainnet-1",
        chainName: "cryptoorgchain",
        bech32Config: {
          bech32PrefixAccAddr: "cro"
        },
        bip44: {
          coinType: 394
        },
        denom: "basecro",
        decimals: 8
      },
      "cudos-1": {
        chainId: "cudos-1",
        chainName: "cudos",
        bech32Config: {
          bech32PrefixAccAddr: "cudos"
        },
        bip44: {
          coinType: 118
        },
        denom: "acudos",
        decimals: 18
      },
      "mainnet-3": {
        chainId: "mainnet-3",
        chainName: "decentr",
        bech32Config: {
          bech32PrefixAccAddr: "decentr"
        },
        bip44: {
          coinType: 118
        },
        denom: "udec",
        decimals: 6
      },
      "desmos-mainnet": {
        chainId: "desmos-mainnet",
        chainName: "desmos",
        bech32Config: {
          bech32PrefixAccAddr: "desmos"
        },
        bip44: {
          coinType: 852
        },
        denom: "udsm",
        decimals: 6
      },
      "dig-1": {
        chainId: "dig-1",
        chainName: "dig",
        bech32Config: {
          bech32PrefixAccAddr: "dig"
        },
        bip44: {
          coinType: 118
        },
        denom: "udig",
        decimals: 6
      },
      "dyson-mainnet-01": {
        chainId: "dyson-mainnet-01",
        chainName: "dyson",
        bech32Config: {
          bech32PrefixAccAddr: "dys"
        },
        bip44: {
          coinType: 118
        },
        denom: "dys",
        decimals: 0
      },
      "emoney-3": {
        chainId: "emoney-3",
        chainName: "emoney",
        bech32Config: {
          bech32PrefixAccAddr: "emoney"
        },
        bip44: {
          coinType: 118
        },
        denom: "ungm",
        decimals: 6
      },
      "empowerchain-1": {
        chainId: "empowerchain-1",
        chainName: "empowerchain",
        bech32Config: {
          bech32PrefixAccAddr: "empower"
        },
        bip44: {
          coinType: 118
        },
        denom: "umpwr",
        decimals: 6
      },
      "fetchhub-4": {
        chainId: "fetchhub-4",
        chainName: "fetchhub",
        bech32Config: {
          bech32PrefixAccAddr: "fetch"
        },
        bip44: {
          coinType: 118
        },
        denom: "afet",
        decimals: 18
      },
      "colosseum-1": {
        chainId: "colosseum-1",
        chainName: "firmachain",
        bech32Config: {
          bech32PrefixAccAddr: "firma"
        },
        bip44: {
          coinType: 7777777
        },
        denom: "ufct",
        decimals: 6
      },
      "galaxy-1": {
        chainId: "galaxy-1",
        chainName: "galaxy",
        bech32Config: {
          bech32PrefixAccAddr: "galaxy"
        },
        bip44: {
          coinType: 118
        },
        denom: "uglx",
        decimals: 6
      },
      "genesis_29-2": {
        chainId: "genesis_29-2",
        chainName: "genesisl1",
        bech32Config: {
          bech32PrefixAccAddr: "genesis"
        },
        bip44: {
          coinType: 118
        },
        denom: "el1",
        decimals: 18
      },
      gitopia: {
        chainId: "gitopia",
        chainName: "gitopia",
        bech32Config: {
          bech32PrefixAccAddr: "gitopia"
        },
        bip44: {
          coinType: 118
        },
        denom: "ulore",
        decimals: 6
      },
      "gravity-bridge-3": {
        chainId: "gravity-bridge-3",
        chainName: "gravitybridge",
        bech32Config: {
          bech32PrefixAccAddr: "gravity"
        },
        bip44: {
          coinType: 118
        },
        denom: "ugraviton",
        decimals: 6
      },
      Antora: {
        chainId: "Antora",
        chainName: "idep",
        bech32Config: {
          bech32PrefixAccAddr: "idep"
        },
        bip44: {
          coinType: 118
        },
        denom: "idep",
        decimals: 6
      },
      "ixo-5": {
        chainId: "ixo-5",
        chainName: "impacthub",
        bech32Config: {
          bech32PrefixAccAddr: "ixo"
        },
        bip44: {
          coinType: 118
        },
        denom: "uixo",
        decimals: 6
      },
      "irishub-1": {
        chainId: "irishub-1",
        chainName: "irisnet",
        bech32Config: {
          bech32PrefixAccAddr: "iaa"
        },
        bip44: {
          coinType: 118
        },
        denom: "uiris",
        decimals: 6
      },
      "jackal-1": {
        chainId: "jackal-1",
        chainName: "jackal",
        bech32Config: {
          bech32PrefixAccAddr: "jkl"
        },
        bip44: {
          coinType: 118
        },
        denom: "ujkl",
        decimals: 6
      },
      "juno-1": {
        chainId: "juno-1",
        chainName: "juno",
        bech32Config: {
          bech32PrefixAccAddr: "juno"
        },
        bip44: {
          coinType: 118
        },
        denom: "ujuno",
        decimals: 6
      },
      "kava_2222-10": {
        chainId: "kava_2222-10",
        chainName: "kava",
        bech32Config: {
          bech32PrefixAccAddr: "kava"
        },
        bip44: {
          coinType: 459
        },
        denom: "ukava",
        decimals: 6
      },
      "kichain-2": {
        chainId: "kichain-2",
        chainName: "kichain",
        bech32Config: {
          bech32PrefixAccAddr: "ki"
        },
        bip44: {
          coinType: 118
        },
        denom: "uxki",
        decimals: 6
      },
      "kaiyo-1": {
        chainId: "kaiyo-1",
        chainName: "kujira",
        bech32Config: {
          bech32PrefixAccAddr: "kujira"
        },
        bip44: {
          coinType: 118
        },
        denom: "ukuji",
        decimals: 6
      },
      "kyve-1": {
        chainId: "kyve-1",
        chainName: "kyve",
        bech32Config: {
          bech32PrefixAccAddr: "kyve"
        },
        bip44: {
          coinType: 118
        },
        denom: "ukyve",
        decimals: 6
      },
      "likecoin-mainnet-2": {
        chainId: "likecoin-mainnet-2",
        chainName: "likecoin",
        bech32Config: {
          bech32PrefixAccAddr: "like"
        },
        bip44: {
          coinType: 118
        },
        denom: "nanolike",
        decimals: 9
      },
      "loyal-main-02": {
        chainId: "loyal-main-02",
        chainName: "loyal",
        bech32Config: {
          bech32PrefixAccAddr: "loyal"
        },
        bip44: {
          coinType: 118
        },
        denom: "ulyl",
        decimals: 6
      },
      LumenX: {
        chainId: "LumenX",
        chainName: "lumenx",
        bech32Config: {
          bech32PrefixAccAddr: "lumen"
        },
        bip44: {
          coinType: 118
        },
        denom: "ulumen",
        decimals: 6
      },
      "lum-network-1": {
        chainId: "lum-network-1",
        chainName: "lumnetwork",
        bech32Config: {
          bech32PrefixAccAddr: "lum"
        },
        bip44: {
          coinType: 880
        },
        denom: "ulum",
        decimals: 6
      },
      "mars-1": {
        chainId: "mars-1",
        chainName: "mars",
        bech32Config: {
          bech32PrefixAccAddr: "mars"
        },
        bip44: {
          coinType: 118
        },
        denom: "umars",
        decimals: 6
      },
      "mayachain-mainnet-v1": {
        chainId: "mayachain-mainnet-v1",
        chainName: "mayachain",
        bech32Config: {
          bech32PrefixAccAddr: "maya"
        },
        bip44: {
          coinType: 931
        },
        denom: "cacao",
        decimals: 10
      },
      "meme-1": {
        chainId: "meme-1",
        chainName: "meme",
        bech32Config: {
          bech32PrefixAccAddr: "meme"
        },
        bip44: {
          coinType: 118
        },
        denom: "umeme",
        decimals: 6
      },
      "migaloo-1": {
        chainId: "migaloo-1",
        chainName: "migaloo",
        bech32Config: {
          bech32PrefixAccAddr: "migaloo"
        },
        bip44: {
          coinType: 118
        },
        denom: "uwhale",
        decimals: 6
      },
      mainnet: {
        chainId: "mainnet",
        chainName: "mises",
        bech32Config: {
          bech32PrefixAccAddr: "mises"
        },
        bip44: {
          coinType: 118
        },
        denom: "umis",
        decimals: 6
      },
      "mun-1": {
        chainId: "mun-1",
        chainName: "mun",
        bech32Config: {
          bech32PrefixAccAddr: "mun"
        },
        bip44: {
          coinType: 118
        },
        denom: "umun",
        decimals: 6
      },
      "neutron-1": {
        chainId: "neutron-1",
        chainName: "neutron",
        bech32Config: {
          bech32PrefixAccAddr: "neutron"
        },
        bip44: {
          coinType: 118
        },
        denom: "untrn",
        decimals: 6
      },
      "noble-1": {
        chainId: "noble-1",
        chainName: "noble",
        bech32Config: {
          bech32PrefixAccAddr: "noble"
        },
        bip44: {
          coinType: 118
        },
        denom: "ustake",
        decimals: 6
      },
      "nois-1": {
        chainId: "nois-1",
        chainName: "nois",
        bech32Config: {
          bech32PrefixAccAddr: "nois"
        },
        bip44: {
          coinType: 118
        },
        denom: "unois",
        decimals: 6
      },
      "pirin-1": {
        chainId: "pirin-1",
        chainName: "nolus",
        bech32Config: {
          bech32PrefixAccAddr: "nolus"
        },
        bip44: {
          coinType: 118
        },
        denom: "unls",
        decimals: 6
      },
      nyx: {
        chainId: "nyx",
        chainName: "nyx",
        bech32Config: {
          bech32PrefixAccAddr: "n"
        },
        bip44: {
          coinType: 118
        },
        denom: "unyx",
        decimals: 6
      },
      octa: {
        chainId: "octa",
        chainName: "octa",
        bech32Config: {
          bech32PrefixAccAddr: "octa"
        },
        bip44: {
          coinType: 118
        },
        denom: "uocta",
        decimals: 6
      },
      "odin-mainnet-freya": {
        chainId: "odin-mainnet-freya",
        chainName: "odin",
        bech32Config: {
          bech32PrefixAccAddr: "odin"
        },
        bip44: {
          coinType: 118
        },
        denom: "loki",
        decimals: 6
      },
      "omniflixhub-1": {
        chainId: "omniflixhub-1",
        chainName: "omniflixhub",
        bech32Config: {
          bech32PrefixAccAddr: "omniflix"
        },
        bip44: {
          coinType: 118
        },
        denom: "uflix",
        decimals: 6
      },
      "onomy-mainnet-1": {
        chainId: "onomy-mainnet-1",
        chainName: "onomy",
        bech32Config: {
          bech32PrefixAccAddr: "onomy"
        },
        bip44: {
          coinType: 118
        },
        denom: "anom",
        decimals: 18
      },
      Oraichain: {
        chainId: "Oraichain",
        chainName: "oraichain",
        bech32Config: {
          bech32PrefixAccAddr: "orai"
        },
        bip44: {
          coinType: 118
        },
        denom: "orai",
        decimals: 6
      },
      "osmosis-1": {
        chainId: "osmosis-1",
        chainName: "osmosis",
        bech32Config: {
          bech32PrefixAccAddr: "osmo"
        },
        bip44: {
          coinType: 118
        },
        denom: "uosmo",
        decimals: 6
      },
      "panacea-3": {
        chainId: "panacea-3",
        chainName: "panacea",
        bech32Config: {
          bech32PrefixAccAddr: "panacea"
        },
        bip44: {
          coinType: 371
        },
        denom: "umed",
        decimals: 6
      },
      "passage-2": {
        chainId: "passage-2",
        chainName: "passage",
        bech32Config: {
          bech32PrefixAccAddr: "pasg"
        },
        bip44: {
          coinType: 118
        },
        denom: "upasg",
        decimals: 6
      },
      "passage-1": {
        chainId: "passage-1",
        chainName: "passage1",
        bech32Config: {
          bech32PrefixAccAddr: "pasg"
        },
        bip44: {
          coinType: 118
        },
        denom: "upasg",
        decimals: 6
      },
      "core-1": {
        chainId: "core-1",
        chainName: "persistence",
        bech32Config: {
          bech32PrefixAccAddr: "persistence"
        },
        bip44: {
          coinType: 118
        },
        denom: "uxprt",
        decimals: 6
      },
      "pio-mainnet-1": {
        chainId: "pio-mainnet-1",
        chainName: "provenance",
        bech32Config: {
          bech32PrefixAccAddr: "pb"
        },
        bip44: {
          coinType: 505
        },
        denom: "nhash",
        decimals: 9
      },
      "quasar-1": {
        chainId: "quasar-1",
        chainName: "quasar",
        bech32Config: {
          bech32PrefixAccAddr: "quasar"
        },
        bip44: {
          coinType: 118
        },
        denom: "uqsr",
        decimals: 6
      },
      "quicksilver-2": {
        chainId: "quicksilver-2",
        chainName: "quicksilver",
        bech32Config: {
          bech32PrefixAccAddr: "quick"
        },
        bip44: {
          coinType: 118
        },
        denom: "uqck",
        decimals: 6
      },
      "qwoyn-1": {
        chainId: "qwoyn-1",
        chainName: "qwoyn",
        bech32Config: {
          bech32PrefixAccAddr: "qwoyn"
        },
        bip44: {
          coinType: 118
        },
        denom: "uqwoyn",
        decimals: 6
      },
      "reb_1111-1": {
        chainId: "reb_1111-1",
        chainName: "rebus",
        bech32Config: {
          bech32PrefixAccAddr: "rebus"
        },
        bip44: {
          coinType: 118
        },
        denom: "arebus",
        decimals: 18
      },
      "regen-1": {
        chainId: "regen-1",
        chainName: "regen",
        bech32Config: {
          bech32PrefixAccAddr: "regen"
        },
        bip44: {
          coinType: 118
        },
        denom: "uregen",
        decimals: 6
      },
      "titan-1": {
        chainId: "titan-1",
        chainName: "rizon",
        bech32Config: {
          bech32PrefixAccAddr: "rizon"
        },
        bip44: {
          coinType: 118
        },
        denom: "uatolo",
        decimals: 6
      },
      "secret-4": {
        chainId: "secret-4",
        chainName: "secretnetwork",
        bech32Config: {
          bech32PrefixAccAddr: "secret"
        },
        bip44: {
          coinType: 529
        },
        denom: "uscrt",
        decimals: 6
      },
      "pacific-1": {
        chainId: "pacific-1",
        chainName: "sei",
        bech32Config: {
          bech32PrefixAccAddr: "sei"
        },
        bip44: {
          coinType: 118
        },
        denom: "usei",
        decimals: 6
      },
      "sentinelhub-2": {
        chainId: "sentinelhub-2",
        chainName: "sentinel",
        bech32Config: {
          bech32PrefixAccAddr: "sent"
        },
        bip44: {
          coinType: 118
        },
        denom: "udvpn",
        decimals: 6
      },
      "ShareRing-VoyagerNet": {
        chainId: "ShareRing-VoyagerNet",
        chainName: "shareledger",
        bech32Config: {
          bech32PrefixAccAddr: "shareledger"
        },
        bip44: {
          coinType: 118
        },
        denom: "nshr",
        decimals: 9
      },
      "shentu-2.2": {
        chainId: "shentu-2.2",
        chainName: "shentu",
        bech32Config: {
          bech32PrefixAccAddr: "certik"
        },
        bip44: {
          coinType: 118
        },
        denom: "uctk",
        decimals: 6
      },
      "sommelier-3": {
        chainId: "sommelier-3",
        chainName: "sommelier",
        bech32Config: {
          bech32PrefixAccAddr: "somm"
        },
        bip44: {
          coinType: 118
        },
        denom: "usomm",
        decimals: 6
      },
      "stafihub-1": {
        chainId: "stafihub-1",
        chainName: "stafihub",
        bech32Config: {
          bech32PrefixAccAddr: "stafi"
        },
        bip44: {
          coinType: 118
        },
        denom: "ufis",
        decimals: 6
      },
      "stargaze-1": {
        chainId: "stargaze-1",
        chainName: "stargaze",
        bech32Config: {
          bech32PrefixAccAddr: "stars"
        },
        bip44: {
          coinType: 118
        },
        denom: "ustars",
        decimals: 6
      },
      "iov-mainnet-ibc": {
        chainId: "iov-mainnet-ibc",
        chainName: "starname",
        bech32Config: {
          bech32PrefixAccAddr: "star"
        },
        bip44: {
          coinType: 234
        },
        denom: "uiov",
        decimals: 6
      },
      "stride-1": {
        chainId: "stride-1",
        chainName: "stride",
        bech32Config: {
          bech32PrefixAccAddr: "stride"
        },
        bip44: {
          coinType: 118
        },
        denom: "ustrd",
        decimals: 6
      },
      "teritori-1": {
        chainId: "teritori-1",
        chainName: "teritori",
        bech32Config: {
          bech32PrefixAccAddr: "tori"
        },
        bip44: {
          coinType: 118
        },
        denom: "utori",
        decimals: 6
      },
      "columbus-5": {
        chainId: "columbus-5",
        chainName: "terra",
        bech32Config: {
          bech32PrefixAccAddr: "terra"
        },
        bip44: {
          coinType: 330
        },
        denom: "uluna",
        decimals: 6
      },
      "phoenix-1": {
        chainId: "phoenix-1",
        chainName: "terra2",
        bech32Config: {
          bech32PrefixAccAddr: "terra"
        },
        bip44: {
          coinType: 330
        },
        denom: "uluna",
        decimals: 6
      },
      "tgrade-mainnet-1": {
        chainId: "tgrade-mainnet-1",
        chainName: "tgrade",
        bech32Config: {
          bech32PrefixAccAddr: "tgrade"
        },
        bip44: {
          coinType: 118
        },
        denom: "utgd",
        decimals: 6
      },
      "umee-1": {
        chainId: "umee-1",
        chainName: "umee",
        bech32Config: {
          bech32PrefixAccAddr: "umee"
        },
        bip44: {
          coinType: 118
        },
        denom: "uumee",
        decimals: 6
      },
      "FUND-MainNet-2": {
        chainId: "FUND-MainNet-2",
        chainName: "unification",
        bech32Config: {
          bech32PrefixAccAddr: "und"
        },
        bip44: {
          coinType: 5555
        },
        denom: "nund",
        decimals: 9
      },
      "ununifi-beta-v1": {
        chainId: "ununifi-beta-v1",
        chainName: "ununifi",
        bech32Config: {
          bech32PrefixAccAddr: "ununifi"
        },
        bip44: {
          coinType: 118
        },
        denom: "uguu",
        decimals: 6
      },
      "vidulum-1": {
        chainId: "vidulum-1",
        chainName: "vidulum",
        bech32Config: {
          bech32PrefixAccAddr: "vdl"
        },
        bip44: {
          coinType: 370
        },
        denom: "uvdl",
        decimals: 6
      }
    };
    exports.default = Chains;
  }
});

// node_modules/@leapwallet/cosmos-snap-provider/dist/cosmjs-offline-signer.js
var require_cosmjs_offline_signer = __commonJS({
  "node_modules/@leapwallet/cosmos-snap-provider/dist/cosmjs-offline-signer.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signArbitrary = exports.getOfflineSigner = exports.CosmjsOfflineSigner = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var snap_1 = require_snap();
    var gas_1 = require_gas();
    var chainInfo_1 = __importDefault(require_chainInfo());
    var CosmjsOfflineSigner = class {
      constructor(chainId) {
        this.chainId = chainId;
      }
      async getAccounts() {
        const key = await (0, snap_1.getKey)(this.chainId);
        return [
          {
            address: key.address,
            algo: "secp256k1",
            pubkey: key.pubkey
          }
        ];
      }
      async signDirect(signerAddress, signDoc) {
        if (this.chainId !== signDoc.chainId) {
          throw new Error("Chain ID does not match signer chain ID");
        }
        const accounts = await this.getAccounts();
        if (accounts.find((account) => account.address !== signerAddress)) {
          throw new Error("Signer address does not match wallet address");
        }
        return (0, snap_1.requestSignature)(this.chainId, signerAddress, signDoc);
      }
      // This has been added as a placeholder.
      async signAmino(signerAddress, signDoc, options) {
        if (this.chainId !== signDoc.chain_id) {
          throw new Error("Chain ID does not match signer chain ID");
        }
        const accounts = await this.getAccounts();
        if (accounts.find((account) => account.address !== signerAddress)) {
          throw new Error("Signer address does not match wallet address");
        }
        const chain = chainInfo_1.default[this.chainId];
        if (!(options === null || options === void 0 ? void 0 : options.preferNoSetFee) && chain && chain.denom) {
          const gasPriceFromRegistry = await (0, gas_1.getGasPriceForChainName)(chain.chainName);
          const gas = "gasLimit" in signDoc.fee ? signDoc.fee.gasLimit : signDoc.fee.gas;
          if (gasPriceFromRegistry) {
            const amount = [
              {
                amount: new bignumber_js_1.default(gasPriceFromRegistry).multipliedBy(new bignumber_js_1.default(gas)).decimalPlaces(0, 1).toString(),
                denom: chain.denom
              }
            ];
            signDoc.fee.amount = amount;
          }
        }
        return (0, snap_1.requestSignAmino)(this.chainId, signerAddress, signDoc);
      }
    };
    exports.CosmjsOfflineSigner = CosmjsOfflineSigner;
    function getOfflineSigner(chainId) {
      return new CosmjsOfflineSigner(chainId);
    }
    exports.getOfflineSigner = getOfflineSigner;
    async function signArbitrary(chainId, signer, data) {
      const { signDoc } = getADR36SignDoc(signer, data);
      const result = await (0, snap_1.requestSignAmino)(chainId, signer, signDoc, {
        isADR36: true
      });
      return result.signature;
    }
    exports.signArbitrary = signArbitrary;
    function getADR36SignDoc(signer, data) {
      let isADR36WithString = false;
      let b64Data = "";
      if (typeof data === "string") {
        b64Data = Buffer.from(data).toString("base64");
        isADR36WithString = true;
      } else {
        b64Data = Buffer.from(data).toString("base64");
      }
      const signDoc = {
        chain_id: "",
        account_number: "0",
        sequence: "0",
        fee: {
          gas: "0",
          amount: []
        },
        msgs: [
          {
            type: "sign/MsgSignData",
            value: {
              signer,
              b64Data
            }
          }
        ],
        memo: ""
      };
      return { signDoc, isADR36WithString };
    }
  }
});

// node_modules/@leapwallet/cosmos-snap-provider/dist/index.js
var require_dist = __commonJS({
  "node_modules/@leapwallet/cosmos-snap-provider/dist/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_snap(), exports);
    __exportStar(require_types(), exports);
    __exportStar(require_cosmjs_offline_signer(), exports);
  }
});
export default require_dist();
/*! Bundled license information:

long/umd/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=@leapwallet_cosmos-snap-provider.js.map
