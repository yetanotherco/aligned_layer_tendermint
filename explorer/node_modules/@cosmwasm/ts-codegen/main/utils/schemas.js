"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readSchemas = exports.findQueryMsg = exports.findExecuteMsg = exports.findAndParseTypes = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _glob = require("glob");

var _fs = require("fs");

var _cleanse = require("./cleanse");

var _jsonSchemaToTypescript = require("@pyramation/json-schema-to-typescript");

var _parse = require("./parse");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

;

var readSchemas = /*#__PURE__*/function () {
  var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(_ref) {
    var schemaDir, _ref$clean, clean, fn, files, schemas, idlObject, contract_name, contract_version, idl_version, responses, instantiate, execute, query, migrate, sudo;

    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            schemaDir = _ref.schemaDir, _ref$clean = _ref.clean, clean = _ref$clean === void 0 ? true : _ref$clean;
            fn = clean ? _cleanse.cleanse : function (str) {
              return str;
            };
            files = (0, _glob.sync)(schemaDir + '/**/*.json');
            schemas = files.map(function (file) {
              return JSON.parse((0, _fs.readFileSync)(file, 'utf-8'));
            });

            if (!(schemas.length > 1)) {
              _context.next = 6;
              break;
            }

            return _context.abrupt("return", {
              schemas: fn(schemas)
            });

          case 6:
            if (!(schemas.length === 0)) {
              _context.next = 8;
              break;
            }

            throw new Error('Error [too few files]: requires one schema file per contract');

          case 8:
            if (!(schemas.length !== 1)) {
              _context.next = 10;
              break;
            }

            throw new Error('Error [too many files]: CosmWasm v1.1 schemas supports one file');

          case 10:
            idlObject = schemas[0];
            contract_name = idlObject.contract_name, contract_version = idlObject.contract_version, idl_version = idlObject.idl_version, responses = idlObject.responses, instantiate = idlObject.instantiate, execute = idlObject.execute, query = idlObject.query, migrate = idlObject.migrate, sudo = idlObject.sudo;

            if (!(typeof idl_version !== 'string')) {
              _context.next = 14;
              break;
            }

            return _context.abrupt("return", {
              schemas: fn(schemas)
            });

          case 14:
            return _context.abrupt("return", {
              schemas: [].concat((0, _toConsumableArray2["default"])(Object.values(fn({
                instantiate: instantiate,
                execute: execute,
                query: query,
                migrate: migrate,
                sudo: sudo
              })).filter(Boolean)), (0, _toConsumableArray2["default"])(Object.values(fn(_objectSpread({}, responses))).filter(Boolean))),
              responses: responses,
              idlObject: idlObject
            });

          case 15:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function readSchemas(_x) {
    return _ref2.apply(this, arguments);
  };
}();

exports.readSchemas = readSchemas;

var findQueryMsg = function findQueryMsg(schemas) {
  var QueryMsg = schemas.find(function (schema) {
    return schema.title === 'QueryMsg';
  });
  return QueryMsg;
};

exports.findQueryMsg = findQueryMsg;

var findExecuteMsg = function findExecuteMsg(schemas) {
  var ExecuteMsg = schemas.find(function (schema) {
    return schema.title === 'ExecuteMsg' || schema.title === 'ExecuteMsg_for_Empty' || // if cleanse is used, this is never
    schema.title === 'ExecuteMsgForEmpty';
  });
  return ExecuteMsg;
};

exports.findExecuteMsg = findExecuteMsg;

var findAndParseTypes = /*#__PURE__*/function () {
  var _ref3 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(schemas) {
    var Types, allTypes, typ, _i, _Object$keys, key, result, typeHash;

    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            Types = schemas;
            allTypes = [];
            _context2.t0 = _regenerator["default"].keys(Types);

          case 3:
            if ((_context2.t1 = _context2.t0()).done) {
              _context2.next = 12;
              break;
            }

            typ = _context2.t1.value;

            if (Types[typ].definitions) {
              for (_i = 0, _Object$keys = Object.keys(Types[typ].definitions); _i < _Object$keys.length; _i++) {
                key = _Object$keys[_i];
                // set title
                Types[typ].definitions[key].title = key;
              }
            }

            _context2.next = 8;
            return (0, _jsonSchemaToTypescript.compile)(Types[typ], Types[typ].title);

          case 8:
            result = _context2.sent;
            allTypes.push(result);
            _context2.next = 3;
            break;

          case 12:
            typeHash = (0, _parse.parser)(allTypes);
            return _context2.abrupt("return", typeHash);

          case 14:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function findAndParseTypes(_x2) {
    return _ref3.apply(this, arguments);
  };
}();

exports.findAndParseTypes = findAndParseTypes;