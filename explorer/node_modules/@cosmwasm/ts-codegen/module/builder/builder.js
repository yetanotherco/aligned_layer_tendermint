import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
const _excluded = ["enabled"],
      _excluded2 = ["enabled"],
      _excluded3 = ["enabled"],
      _excluded4 = ["enabled"],
      _excluded5 = ["enabled"];
import { defaultOptions } from "wasm-ast-types";
import { header } from '../utils/header';
import { join } from "path";
import { writeFileSync } from 'fs';
import { sync as mkdirp } from "mkdirp";
import generateMessageComposer from '../generators/message-composer';
import generateTypes from '../generators/types';
import generateReactQuery from '../generators/react-query';
import generateRecoil from '../generators/recoil';
import generateClient from '../generators/client';
import { basename } from 'path';
import { readSchemas } from '../utils';
import deepmerge from 'deepmerge';
import { pascal } from "case";
import { createFileBundle, recursiveModuleBundle } from "../bundler";
import generate from '@babel/generator';
import * as t from '@babel/types';
const defaultOpts = {
  bundle: {
    enabled: true,
    scope: 'contracts',
    bundleFile: 'bundle.ts'
  }
};
;
;
;
export class TSBuilder {
  constructor({
    contracts,
    outPath,
    options
  }) {
    _defineProperty(this, "contracts", void 0);

    _defineProperty(this, "outPath", void 0);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "files", []);

    this.contracts = contracts;
    this.outPath = outPath;
    this.options = deepmerge(deepmerge(defaultOptions, defaultOpts), options ?? {});
  }

  getContracts() {
    return this.contracts.map(contractOpt => {
      if (typeof contractOpt === 'string') {
        const name = basename(contractOpt);
        const contractName = pascal(name);
        return {
          name: contractName,
          dir: contractOpt
        };
      }

      return {
        name: pascal(contractOpt.name),
        dir: contractOpt.dir
      };
    });
  }

  async renderTypes(contract) {
    const _this$options$types = this.options.types,
          {
      enabled
    } = _this$options$types,
          options = _objectWithoutProperties(_this$options$types, _excluded);

    if (!enabled) return;
    const contractInfo = await readSchemas({
      schemaDir: contract.dir
    });
    const files = await generateTypes(contract.name, contractInfo, this.outPath, options);
    [].push.apply(this.files, files);
  }

  async renderClient(contract) {
    const _this$options$client = this.options.client,
          {
      enabled
    } = _this$options$client,
          options = _objectWithoutProperties(_this$options$client, _excluded2);

    if (!enabled) return;
    const contractInfo = await readSchemas({
      schemaDir: contract.dir
    });
    const files = await generateClient(contract.name, contractInfo, this.outPath, options);
    [].push.apply(this.files, files);
  }

  async renderRecoil(contract) {
    const _this$options$recoil = this.options.recoil,
          {
      enabled
    } = _this$options$recoil,
          options = _objectWithoutProperties(_this$options$recoil, _excluded3);

    if (!enabled) return;
    const contractInfo = await readSchemas({
      schemaDir: contract.dir
    });
    const files = await generateRecoil(contract.name, contractInfo, this.outPath, options);
    [].push.apply(this.files, files);
  }

  async renderReactQuery(contract) {
    const _this$options$reactQu = this.options.reactQuery,
          {
      enabled
    } = _this$options$reactQu,
          options = _objectWithoutProperties(_this$options$reactQu, _excluded4);

    if (!enabled) return;
    const contractInfo = await readSchemas({
      schemaDir: contract.dir
    });
    const files = await generateReactQuery(contract.name, contractInfo, this.outPath, options);
    [].push.apply(this.files, files);
  }

  async renderMessageComposer(contract) {
    const _this$options$message = this.options.messageComposer,
          {
      enabled
    } = _this$options$message,
          options = _objectWithoutProperties(_this$options$message, _excluded5);

    if (!enabled) return;
    const contractInfo = await readSchemas({
      schemaDir: contract.dir
    });
    const files = await generateMessageComposer(contract.name, contractInfo, this.outPath, options);
    [].push.apply(this.files, files);
  }

  async build() {
    const contracts = this.getContracts();

    for (let c = 0; c < contracts.length; c++) {
      const contract = contracts[c];
      await this.renderTypes(contract);
      await this.renderClient(contract);
      await this.renderMessageComposer(contract);
      await this.renderReactQuery(contract);
      await this.renderRecoil(contract);
    }

    if (this.options.bundle.enabled) {
      this.bundle();
    }
  }

  async bundle() {
    const allFiles = this.files;
    const bundleFile = this.options.bundle.bundleFile;
    const bundleVariables = {};
    const importPaths = [];
    allFiles.forEach(file => {
      createFileBundle(`${this.options.bundle.scope}.${file.contract}`, file.localname, bundleFile, importPaths, bundleVariables);
    });
    const ast = recursiveModuleBundle(bundleVariables);
    let code = generate(t.program([...importPaths, ...ast])).code;
    mkdirp(this.outPath);
    if (code.trim() === '') code = 'export {};';
    writeFileSync(join(this.outPath, bundleFile), header + code);
  }

}