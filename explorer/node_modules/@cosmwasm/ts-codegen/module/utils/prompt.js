import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

import { filter } from 'fuzzy';
import { prompt as inquirerer } from 'inquirerer';
export const getFuzzySearch = list => {
  return (answers, input) => {
    input = input || '';
    return new Promise(function (resolve) {
      setTimeout(function () {
        const fuzzyResult = filter(input, list);
        resolve(fuzzyResult.map(function (el) {
          return el.original;
        }));
      }, 25);
    });
  };
};
export const getFuzzySearchNames = nameValueItemList => {
  const list = nameValueItemList.map(({
    name,
    value
  }) => name);
  return (answers, input) => {
    input = input || '';
    return new Promise(function (resolve) {
      setTimeout(function () {
        const fuzzyResult = filter(input, list);
        resolve(fuzzyResult.map(function (el) {
          return nameValueItemList.find(({
            name,
            value
          }) => el.original == name);
        }));
      }, 25);
    });
  };
};

const transform = questions => {
  return questions.map(q => {
    if (q.type === 'fuzzy') {
      const choices = q.choices;
      delete q.choices;
      return _objectSpread(_objectSpread({}, q), {}, {
        type: 'autocomplete',
        source: getFuzzySearch(choices)
      });
    } else if (q.type === 'fuzzy:objects') {
      const choices = q.choices;
      delete q.choices;
      return _objectSpread(_objectSpread({}, q), {}, {
        type: 'autocomplete',
        source: getFuzzySearchNames(choices)
      });
    } else {
      return q;
    }
  });
};

export const prompt = async (questions = [], argv = {}) => {
  questions = transform(questions);
  return await inquirerer(questions, argv);
};