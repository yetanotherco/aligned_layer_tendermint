"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeTemplateTagLegacy = exports.makeTemplateTag = exports.getUrlTemplateString = exports.createLCDClient = exports.createAggregatedLCDClient = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var t = _interopRequireWildcard(require("@babel/types"));
var _utils = require("../../../utils");
var _parser = require("@babel/parser");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
// this is the ONLY time ast uses babel/parser

var getAstFromString = function getAstFromString(str) {
  var plugins = ['objectRestSpread', 'classProperties', 'optionalCatchBinding', 'asyncGenerators', 'decorators-legacy', 'typescript', 'dynamicImport'];
  var ast = (0, _parser.parse)(str, {
    sourceType: 'module',
    // @ts-ignore
    plugins: plugins
  });
  return ast;
};
var getResponseTypeName = function getResponseTypeName(context, name) {
  return name + (context.options.useSDKTypes ? 'SDKType' : '');
};
var returnReponseType = function returnReponseType(context, name) {
  return t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Promise'), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(getResponseTypeName(context, name)))])));
};
var firstLower = function firstLower(s) {
  return s = s.charAt(0).toLowerCase() + s.slice(1);
};
var firstUpper = function firstUpper(s) {
  return s = s.charAt(0).toUpperCase() + s.slice(1);
};
var returnAwaitRequest = function returnAwaitRequest(context, responseType) {
  var hasOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var args = [t.identifier('endpoint')];
  // if (method === 'post') {
  //     args.push(t.identifier('body'));
  // }

  if (hasOptions) {
    args.push(t.identifier('options'));
  }
  return t.returnStatement(t.awaitExpression((0, _utils.callExpression)(t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier('req')), t.identifier('get')), args, t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(getResponseTypeName(context, responseType)))]))));
};
var makeOptionsObject = function makeOptionsObject() {
  return t.variableDeclaration('const', [t.variableDeclarator((0, _utils.identifier)('options', t.tsTypeAnnotation(t.tsAnyKeyword())), t.objectExpression([t.objectProperty(t.identifier('params'), t.objectExpression([]))]))]);
};
var setParamOption = function setParamOption(context, name, svc) {
  var flippedCasing = Object.keys(svc.info.casing).reduce(function (m, v) {
    m[svc.info.casing[v]] = v;
    return m;
  }, {});
  var queryParam = flippedCasing[name] ? flippedCasing[name] : name;
  var param = svc.info.paramMap[name];

  // options.params.group_id = params.groupId;
  var expr = t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.memberExpression(t.identifier('options'), t.identifier('params')), t.identifier(queryParam)), t.memberExpression(t.identifier('params'), t.identifier(param))));
  if (name === 'pagination') {
    context.addUtil('setPaginationParams');
    expr = t.expressionStatement(t.callExpression(t.identifier('setPaginationParams'), [t.identifier('options'), t.memberExpression(t.identifier('params'), t.identifier('pagination'), false)]));
  }
  return t.ifStatement(t.binaryExpression('!==', t.unaryExpression('typeof', t.optionalMemberExpression(t.identifier('params'), t.identifier(param), false, true)), t.stringLiteral('undefined')), t.blockStatement([expr]));
};

// breaks a url string to prepare it for template strings
var getUrlTemplateString = function getUrlTemplateString(url) {
  var parts = url.split('/').filter(function (a) {
    return a !== '';
  });
  var cur = [];
  var strs = [];
  var atEnd = false;
  for (var p = 0; p < parts.length; p++) {
    var part = parts[p];
    if (/[{}]+/.test(part)) {
      if (p === parts.length - 1) atEnd = true;
      if (cur.length) {
        var vals = cur.join('/');
        strs.push(vals);
      } else {
        strs.push('/');
      }
      cur = [];
    } else {
      cur.push(part);
    }
  }
  if (cur.length) {
    strs.push(cur.join('/'));
  }
  strs = strs.filter(function (str) {
    return str !== '';
  }).map(function (v, i) {
    if (i === 0) {
      if (!v.endsWith('/')) v = "".concat(v, "/");
      return v;
    } else if (i === strs.length - 1) {
      if (atEnd) {
        // we want them to end with / if it's an "atEnd" el
        if (!v.endsWith('/')) v = "".concat(v, "/");
        return v;
      }
      // they should all start with "/"
      if (!v.startsWith('/')) v = "/".concat(v);
      return v;
    }
    if (!v.endsWith('/')) v = "".concat(v, "/");
    if (!v.startsWith('/')) v = "/".concat(v);
    return v;
  });
  return {
    strs: strs,
    atEnd: atEnd
  };
};
exports.getUrlTemplateString = getUrlTemplateString;
var makeTemplateTag = function makeTemplateTag(info) {
  var route = info.url.split('/').filter(function (a) {
    return a !== '';
  }).map(function (a) {
    if (a.startsWith('{')) {
      return "$".concat(a);
    } else {
      return a;
    }
  }).join('/');
  var parsed = getAstFromString("`".concat(route, "`"));
  // @ts-ignore
  var ast = parsed.program.body[0].expression;
  ast.expressions = ast.expressions.map(function (identifier) {
    var _info$casing;
    var name = (_info$casing = info.casing) !== null && _info$casing !== void 0 && _info$casing[identifier.name] ? info.casing[identifier.name] : identifier.name;
    if (!name) {
      console.warn(route);
      console.warn('route type not yet supported');
      return;
    }
    return t.memberExpression(t.identifier('params'), t.identifier(name));
  }).filter(Boolean);
  return ast;
};

// do we need to set end prop in ast?
// we may want to t.templateElement!!!
exports.makeTemplateTag = makeTemplateTag;
var makeTemplateTagLegacy = function makeTemplateTagLegacy(info) {
  if (!info.url) throw new Error('no URL on service method');
  var parts = getUrlTemplateString(info.url);
  var templateElts = parts.strs.map(function (raw) {
    return t.templateElement({
      raw: raw
    });
  });

  // Number of TemplateLiteral quasis should be exactly one more than the number of expressions

  var pathParams = info.pathParams.map(function (param) {
    var _info$casing2;
    var name = (_info$casing2 = info.casing) !== null && _info$casing2 !== void 0 && _info$casing2[param] ? info.casing[param] : param;
    return t.memberExpression(t.identifier('params'), t.identifier(name));
  });
  if (parts.atEnd) {
    templateElts.push(t.templateElement({
      raw: ''
    }));
  }

  // THIS MEANS WE PROBABLY HAVE A BUG
  if (templateElts.length !== pathParams.length + 1) {
    templateElts.push(t.templateElement({
      raw: ''
    }));
  }
  templateElts.forEach(function (el, n) {
    if (n === templateElts.length - 1) {
      // remove trailing slash...
      el.value.raw = el.value.raw.replace(/\/$/, '');
    }
  });
  return t.templateLiteral(templateElts, pathParams);
};
exports.makeTemplateTagLegacy = makeTemplateTagLegacy;
var makeComment = function makeComment(comment) {
  return [{
    type: 'CommentBlock',
    value: " ".concat(comment, " ")
  }];
};
var buildRequestMethod = function buildRequestMethod(context, serviceMethod) {
  var _serviceMethod$commen, _serviceMethod$fields, _serviceMethod$fields2;
  var methodName = firstLower(serviceMethod.name);
  var comment = (_serviceMethod$commen = serviceMethod.comment) !== null && _serviceMethod$commen !== void 0 ? _serviceMethod$commen : serviceMethod.name;
  if (!serviceMethod.info) {
    throw new Error('No Service URL!');
  }
  var queryParams = serviceMethod.info.queryParams.map(function (param) {
    return setParamOption(context, param, serviceMethod);
  });
  var optionsAst = [];
  if (serviceMethod.info.queryParams.length) {
    // options params object
    optionsAst.push(makeOptionsObject());
  }

  // parse field types
  Object.entries((_serviceMethod$fields = serviceMethod.fields) !== null && _serviceMethod$fields !== void 0 ? _serviceMethod$fields : {}).forEach(function (_ref) {
    var _ref2 = (0, _slicedToArray2["default"])(_ref, 2),
      key = _ref2[0],
      value = _ref2[1];
    switch (value.parsedType.type) {
      case 'Type':
        // this gets the import for us and loads them into ctx
        // if later we need to get subtypes, we have it all w/ctx
        context.getTypeName(value);
      case 'native':
    }
  });
  var fieldNames = Object.keys((_serviceMethod$fields2 = serviceMethod.fields) !== null && _serviceMethod$fields2 !== void 0 ? _serviceMethod$fields2 : {});
  var hasParams = fieldNames.length > 0;
  var paramName = hasParams ? 'params' : '_params';
  var methodArgs = (0, _utils.identifier)(paramName, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(serviceMethod.requestType))));

  // if no params, then let's default to empty object for cleaner API
  if (!hasParams) {
    methodArgs = t.assignmentPattern(methodArgs, t.objectExpression([]));
  } else if (hasParams && fieldNames.length === 1 && fieldNames.includes('pagination')) {
    // if only argument "required" is pagination
    // also default to empty
    methodArgs = t.assignmentPattern(methodArgs, t.objectExpression([t.objectProperty(t.identifier('pagination'), t.identifier('undefined'), false, false)]));
  }
  var body = t.blockStatement([].concat(optionsAst, (0, _toConsumableArray2["default"])(queryParams), [
  // endpoint
  t.variableDeclaration('const', [t.variableDeclarator(t.identifier('endpoint'), makeTemplateTag(serviceMethod.info))]),
  // return 
  returnAwaitRequest(context, serviceMethod.responseType,
  // serviceMethod.info.method,
  serviceMethod.info.queryParams.length > 0)]));
  if (context.pluginValue('classesUseArrowFunctions')) {
    return (0, _utils.classProperty)(t.identifier(methodName), (0, _utils.arrowFunctionExpression)([methodArgs], body, t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Promise'), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(getResponseTypeName(context, serviceMethod.responseType)))]))), true), undefined, undefined, undefined, undefined, undefined, undefined, makeComment(comment));
  }
  return (0, _utils.classMethod)('method', t.identifier(methodName), [methodArgs], body, returnReponseType(context, serviceMethod.responseType), makeComment(comment), false, false, false, true // async
  );
};

// MARKED AS NOT DRY (used in rpc/lcd)
var bindThis = function bindThis(name) {
  return t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.thisExpression(), t.identifier(name)), t.callExpression(t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier(name)), t.identifier('bind')), [t.thisExpression()])));
};
var createLCDClientClassBody = function createLCDClientClassBody(context, clientName, methods, service) {
  var boundMethods = [];
  // until the super() issue is figured out, we have to remove this
  if (service && !context.pluginValue('classesUseArrowFunctions')) {
    boundMethods = Object.keys(service.methods).map(function (key) {
      var _method$options;
      var method = service.methods[key];
      if (typeof ((_method$options = method.options) === null || _method$options === void 0 ? void 0 : _method$options['(google.api.http).get']) !== 'undefined') {
        var methodName = firstLower(method.name);
        return bindThis(methodName);
      }
    }).filter(Boolean);
  }
  return t.exportNamedDeclaration(t.classDeclaration(t.identifier(clientName), null, t.classBody([t.classProperty(t.identifier('req'), null, t.tsTypeAnnotation(t.tsTypeReference(t.identifier('LCDClient')))),
  // constructor
  t.classMethod('constructor', t.identifier('constructor'), [(0, _utils.objectPattern)([t.objectProperty(t.identifier('requestClient'), t.identifier('requestClient'), false, true)], t.tsTypeAnnotation(t.tsTypeLiteral([t.tsPropertySignature(t.identifier('requestClient'), t.tsTypeAnnotation(t.tsTypeReference(t.identifier('LCDClient'))))])))], t.blockStatement([t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.thisExpression(), t.identifier('req')), t.identifier('requestClient')))].concat((0, _toConsumableArray2["default"])(boundMethods))))].concat((0, _toConsumableArray2["default"])(methods)))));
};
var createLCDClient = function createLCDClient(context, service) {
  var methods = Object.keys(service.methods).map(function (key) {
    var _method$options2;
    var method = service.methods[key];
    if (method.info && typeof ((_method$options2 = method.options) === null || _method$options2 === void 0 ? void 0 : _method$options2['(google.api.http).get']) !== 'undefined') {
      return buildRequestMethod(context, method);
    }
  }).filter(Boolean);
  context.addUtil('LCDClient');
  if (methods.length) {
    var clientName = 'LCDQueryClient';
    return createLCDClientClassBody(context, clientName, methods, service);
  }
};
exports.createLCDClient = createLCDClient;
var createAggregatedLCDClient = function createAggregatedLCDClient(context, services, clientName) {
  context.addUtil('LCDClient');
  var methods = services.reduce(function (m, service) {
    var innerMethods = Object.keys(service.methods).map(function (key) {
      var _method$options3;
      var method = service.methods[key];
      if (method.info && typeof ((_method$options3 = method.options) === null || _method$options3 === void 0 ? void 0 : _method$options3['(google.api.http).get']) !== 'undefined') {
        return buildRequestMethod(context, method);
      }
    }).filter(Boolean);
    return [].concat((0, _toConsumableArray2["default"])(m), (0, _toConsumableArray2["default"])(innerMethods));
  }, []);
  return createLCDClientClassBody(context, clientName, methods);
};
exports.createAggregatedLCDClient = createAggregatedLCDClient;