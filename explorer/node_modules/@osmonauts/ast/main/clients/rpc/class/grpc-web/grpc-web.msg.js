"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.grpcWebRpcInterface = exports.getMethodDesc = exports.getGrpcWebImpl = exports.createGrpcWebMsgInterface = exports.createGrpcWebMsgClass = exports.GetDesc = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _utils = require("../../../../utils");
var _utils2 = require("@osmonauts/utils");
var _rpc = require("../utils/rpc");
var _utils3 = require("./utils");
var t = _interopRequireWildcard(require("@babel/types"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var gRPCWebMethodDefinition = function gRPCWebMethodDefinition(name, svc, trailingComments, leadingComments) {
  var _svc$fields;
  var requestType = svc.requestType;
  var responseType = svc.responseType;
  var fieldNames = Object.keys((_svc$fields = svc.fields) !== null && _svc$fields !== void 0 ? _svc$fields : {});
  var hasParams = fieldNames.length > 0;
  var optional = (0, _rpc.optionalBool)(hasParams, fieldNames);
  var methodArgs = (0, _utils.identifier)('request', t.tsTypeAnnotation(t.tsTypeReference(t.identifier('DeepPartial'), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(requestType))]))), optional);
  var metadataArgs = _utils3.metadata;
  return (0, _utils.tsMethodSignature)(t.identifier(name), null, [methodArgs, metadataArgs], (0, _rpc.returnReponseType)(responseType), trailingComments, leadingComments);
};
var createGrpcWebMsgInterface = function createGrpcWebMsgInterface(context, service) {
  var _service$methods;
  var camelRpcMethods = context.pluginValue('rpcClients.camelCase');
  var keys = Object.keys((_service$methods = service.methods) !== null && _service$methods !== void 0 ? _service$methods : {});
  var methods = keys.map(function (key) {
    var method = service.methods[key];
    var name = camelRpcMethods ? (0, _utils2.camel)(key) : key;
    var leadingComments = method.comment ? [(0, _utils.commentBlock)((0, _rpc.processRpcComment)(method))] : [];
    var trailingComments = [];
    return gRPCWebMethodDefinition(name, method, trailingComments, leadingComments);
  });
  var obj = t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier(service.name), null, [], t.tsInterfaceBody((0, _toConsumableArray2["default"])(methods))));
  if (service.comment) {
    obj.leadingComments = [(0, _utils.commentBlock)("* ".concat(service.comment, " "))];
  }
  return obj;
};
exports.createGrpcWebMsgInterface = createGrpcWebMsgInterface;
var rpcClassConstructor = function rpcClassConstructor(context, methods) {
  var bound = [];
  if (!context.pluginValue('classesUseArrowFunctions')) {
    bound = methods.map(function (method) {
      return (0, _utils3.bindThis)(method);
    });
  }
  return (0, _utils.classMethod)('constructor', t.identifier('constructor'), [(0, _utils.identifier)('rpc', t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Rpc'))))], t.blockStatement([t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.thisExpression(), t.identifier('rpc')), t.identifier('rpc')))].concat((0, _toConsumableArray2["default"])(bound))));
};
var rpcClassMethod = function rpcClassMethod(context, name, msg, svc, packageImport) {
  var _svc$comment, _svc$fields2;
  var partialName = 'DeepPartial';
  var optional = false;
  var requestType = svc.requestType;
  var responseType = svc.responseType;
  var comment = (_svc$comment = svc.comment) !== null && _svc$comment !== void 0 ? _svc$comment : svc.name;
  var methodArgs = (0, _utils.identifier)('request', t.tsTypeAnnotation(t.tsTypeReference(t.identifier(partialName), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(requestType))]))));
  var metadataArgs = _utils3.metadata;
  var fieldNames = Object.keys((_svc$fields2 = svc.fields) !== null && _svc$fields2 !== void 0 ? _svc$fields2 : {});
  var hasParams = fieldNames.length > 0;

  // if no params, then let's default to empty object for cleaner API
  if (!hasParams) {
    methodArgs = t.assignmentPattern(methodArgs, t.objectExpression([]));
  } else if (hasParams && fieldNames.length === 1 && fieldNames.includes('pagination')) {
    // if only argument "required" is pagination
    // also default to empty
    methodArgs = t.assignmentPattern(methodArgs, t.objectExpression([t.objectProperty(t.identifier('pagination'), t.identifier('undefined'), false, false)]));
  }
  var body = t.blockStatement([t.returnStatement(t.callExpression(t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier('rpc')), t.identifier('unary')), [
  //No Desc field so we need to modify it
  t.identifier(requestType.concat('Desc')), t.callExpression(t.memberExpression(t.identifier(requestType), t.identifier('fromPartial')), [t.identifier('request')]), t.identifier('metadata')]))]);
  if (context.pluginValue('classesUseArrowFunctions')) {
    return (0, _utils.classProperty)(t.identifier(name), (0, _utils.arrowFunctionExpression)([methodArgs], body, (0, _rpc.returnReponseType)(responseType), true), undefined, undefined, undefined, undefined, undefined, undefined, (0, _utils3.makeComment)(comment));
  }
  return (0, _utils.classMethod)('method', t.identifier(name), [methodArgs, metadataArgs], body, (0, _rpc.returnReponseType)(responseType));
};
var createGrpcWebMsgClass = function createGrpcWebMsgClass(context, service) {
  var _service$methods2, _service$methods3;
  context.addUtil('UnaryMethodDefinitionish');
  context.addUtil('_m0');
  context.addUtil('DeepPartial');
  context.addUtil('grpc');
  var camelRpcMethods = context.pluginValue('rpcClients.camelCase');
  var name = (0, _utils3.getRpcClassName)(service);
  var implementsName = service.name;
  var methodNames = Object.keys((_service$methods2 = service.methods) !== null && _service$methods2 !== void 0 ? _service$methods2 : {}).map(function (key) {
    return camelRpcMethods ? (0, _utils2.camel)(key) : key;
  });
  var methods = Object.keys((_service$methods3 = service.methods) !== null && _service$methods3 !== void 0 ? _service$methods3 : {}).map(function (key) {
    var method = service.methods[key];
    var name = camelRpcMethods ? (0, _utils2.camel)(key) : key;
    return rpcClassMethod(context, name, key, method, context.ref.proto["package"] + '.' + service.name);
  });
  return t.exportNamedDeclaration((0, _utils.classDeclaration)(t.identifier(name), null, t.classBody([(0, _utils.classProperty)(t.identifier('rpc'), null, t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Rpc'))), null, false, false, true, 'private'),
  // CONSTRUCTOR
  rpcClassConstructor(context, methodNames)].concat((0, _toConsumableArray2["default"])(methods))), null, [t.tsExpressionWithTypeArguments(t.identifier(implementsName))]));
};
exports.createGrpcWebMsgClass = createGrpcWebMsgClass;
var rpcMethodDef = function rpcMethodDef(svc) {
  var requestType = svc.requestType;
  var responseType = svc.responseType;
  var methodName = svc.name;
  return {
    methodName: methodName,
    requestType: requestType,
    responseType: responseType
  };
};

//return array of method Desc
var getMethodDesc = function getMethodDesc(context, service) {
  var _service$methods4;
  //get all method that need Desc
  var methods = Object.keys((_service$methods4 = service.methods) !== null && _service$methods4 !== void 0 ? _service$methods4 : {}).map(function (key) {
    return rpcMethodDef(service.methods[key]);
  });
  var methodsDesc = [];
  for (var i = 0; i < methods.length; i++) {
    var methodName = methods[i].methodName;
    var requestType = methods[i].requestType;
    var responseType = methods[i].responseType;
    var methodDesc = t.exportNamedDeclaration(t.variableDeclaration('const', [t.variableDeclarator(t.identifier(service.name + methodName + 'Desc: UnaryMethodDefinitionish'), t.objectExpression([t.objectProperty(t.identifier('methodName'), t.stringLiteral(methodName)), t.objectProperty(t.identifier('service'), t.identifier(service.name + 'Desc')), t.objectProperty(t.identifier('requestStream'), t.booleanLiteral(false)), t.objectProperty(t.identifier('reponseStream'), t.booleanLiteral(false)), t.objectProperty(t.identifier('requestType'), t.tsAsExpression(t.objectExpression([t.objectMethod('method', t.identifier('serializeBinary'), [], t.blockStatement([t.returnStatement(t.callExpression(t.memberExpression(t.callExpression(t.memberExpression(t.identifier(requestType), t.identifier('encode')), [t.thisExpression()]), t.identifier('finish')), []))]))]), t.tsAnyKeyword())), t.objectProperty(t.identifier('responseType'), t.tsAsExpression(t.objectExpression([t.objectMethod('method', t.identifier('deserializeBinary'), [(0, _utils.identifier)('data', t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Uint8Array'))))], t.blockStatement([t.returnStatement(t.objectExpression([t.spreadElement(t.callExpression(t.memberExpression(t.identifier(responseType), t.identifier('decode')), [t.identifier('data')])), t.objectMethod('method', t.identifier('toObject'), [], t.blockStatement([t.returnStatement(t.thisExpression())]))]))]))]), t.tsAnyKeyword()))]))]));
    methodsDesc.push(methodDesc);
  }
  return methodsDesc;
};
exports.getMethodDesc = getMethodDesc;
var GetDesc = function GetDesc(context, service) {
  var descName = service.name + 'Desc';
  var serviceName = context.ref.proto["package"] + '.' + service.name;
  return t.exportNamedDeclaration(t.variableDeclaration('const', [t.variableDeclarator(t.identifier(descName), t.objectExpression([t.objectProperty(t.identifier('serviceName'), t.stringLiteral(serviceName))]))]));
};
exports.GetDesc = GetDesc;
var grpcWebRpcInterface = function grpcWebRpcInterface() {
  return t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier('Rpc'), null, [], t.tsInterfaceBody([t.tsMethodSignature(t.identifier('unary'), t.tsTypeParameterDeclaration([t.tsTypeParameter(t.tsTypeReference(t.identifier('UnaryMethodDefinitionish')), null, 'T')]), [(0, _utils.identifier)('methodDesc', t.tsTypeAnnotation(t.tsTypeReference(t.identifier('T')))), (0, _utils.identifier)('request', t.tsTypeAnnotation(t.tsAnyKeyword())), (0, _utils.identifier)('metadata', t.tsTypeAnnotation(t.tSUnionType([t.tsTypeReference(t.tsQualifiedName(t.identifier('grpc'), t.identifier('Metadata'))), t.tsUndefinedKeyword()])))])])));
};
//you might not want to look at this
exports.grpcWebRpcInterface = grpcWebRpcInterface;
var getGrpcWebImpl = function getGrpcWebImpl(context) {
  context.addUtil('BrowserHeaders');
  return t.exportNamedDeclaration(t.classDeclaration(t.identifier('GrpcWebImpl'), null, t.classBody([t.classProperty(t.identifier('host'), null, t.tsTypeAnnotation(t.tsStringKeyword())), t.classProperty(t.identifier('options'), null, t.tsTypeAnnotation(t.tsTypeLiteral([t.tsPropertySignature(t.identifier('transport'), t.tsTypeAnnotation(t.tsTypeReference(t.tsQualifiedName(t.identifier('grpc'), t.identifier('TransportFactory'))))), t.tsPropertySignature(t.identifier('debug'), t.tsTypeAnnotation(t.tsBooleanKeyword())), t.tsPropertySignature(t.identifier('metadata'), t.tsTypeAnnotation(t.tsTypeReference(t.tsQualifiedName(t.identifier('grpc'), t.identifier('Metadata')))))]))), t.classMethod("constructor", t.identifier('constructor'), [(0, _utils.identifier)("host", t.tsTypeAnnotation(t.tsStringKeyword())), (0, _utils.identifier)("options", t.tsTypeAnnotation(t.tsTypeLiteral([t.tsPropertySignature(t.identifier('transport'), t.tsTypeAnnotation(t.tsTypeReference(t.tsQualifiedName(t.identifier('grpc'), t.identifier('TransportFactory'))))), t.tsPropertySignature(t.identifier('debug'), t.tsTypeAnnotation(t.tsBooleanKeyword())), t.tsPropertySignature(t.identifier('metadata'), t.tsTypeAnnotation(t.tsTypeReference(t.tsQualifiedName(t.identifier('grpc'), t.identifier('Metadata')))))])))], t.blockStatement([t.expressionStatement(t.assignmentExpression("=", t.memberExpression(t.thisExpression(), t.identifier('host')), t.identifier('host'))), t.expressionStatement(t.assignmentExpression("=", t.memberExpression(t.thisExpression(), t.identifier('options')), t.identifier('options')))])), t.classMethod("method", t.identifier('unary'), [(0, _utils.identifier)('methodDesc', t.tsTypeAnnotation(t.tsTypeReference(t.identifier('T')))), (0, _utils.identifier)('_request', t.tsTypeAnnotation(t.tsAnyKeyword())), (0, _utils.identifier)('metadata', t.tsTypeAnnotation(t.tsUnionType([t.tsTypeReference(t.tsQualifiedName(t.identifier('grpc'), t.identifier('metadata'))), t.tsUndefinedKeyword()])))], t.blockStatement([t.variableDeclaration("const", [t.variableDeclarator(t.identifier('request'), t.objectExpression([t.spreadElement(t.identifier('_request')), t.spreadElement(t.memberExpression(t.identifier('methodDesc'), t.identifier('requestType')))]))]), t.variableDeclaration("const", [t.variableDeclarator(t.identifier('maybeCombinedMetadata'), t.conditionalExpression(t.logicalExpression("&&", t.identifier('metadata'), t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier('options')), t.identifier('metadata'))), t.newExpression(t.identifier('BrowserHeaders'), [t.objectExpression([t.spreadElement(t.optionalMemberExpression(t.optionalMemberExpression(t.memberExpression(t.thisExpression(), t.identifier('metadata'), false), t.identifier('options'), false, true), t.identifier('headersMap'), false, false)), t.spreadElement(t.optionalMemberExpression(t.identifier('metadata'), t.identifier('headersMap'), false, true))])]), t.logicalExpression("||", t.identifier('metadata'), t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier('options')), t.identifier('metadata')))))]), t.returnStatement(t.newExpression(t.identifier('Promise'), [t.arrowFunctionExpression([t.identifier('resolve'), t.identifier('reject')], t.blockStatement([t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('grpc'), t.identifier('unary')), [t.identifier('methodDesc'), t.objectExpression([t.objectProperty(t.identifier('request'), t.identifier('request'), false, true), t.objectProperty(t.identifier('host'), t.memberExpression(t.thisExpression(), t.identifier('host'))), t.objectProperty(t.identifier('metadata'), t.identifier('maybeCombinedMetadata')), t.objectProperty(t.identifier('transport'), t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier('options')), t.identifier('transport'))), t.objectProperty(t.identifier('debug'), t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier('options')), t.identifier('debug'))), t.objectProperty(t.identifier('onEnd'), t.functionExpression(null, [t.identifier('response')], t.blockStatement([t.ifStatement(t.binaryExpression("===", t.memberExpression(t.identifier('response'), t.identifier('status')), t.memberExpression(t.memberExpression(t.identifier('grpc'), t.identifier('Code')), t.identifier('OK'))), t.blockStatement([t.expressionStatement(t.callExpression(t.identifier('resolve'), [t.memberExpression(t.identifier('response'), t.identifier('message'))]))]), t.blockStatement([t.variableDeclaration("const", [t.variableDeclarator(t.identifier('err'), t.tsAsExpression(t.newExpression(t.identifier('Error'), [t.memberExpression(t.identifier('response'), t.identifier('statusMessage'))]), t.tsAnyKeyword()))]), t.expressionStatement(t.assignmentExpression("=", t.memberExpression(t.identifier('err'), t.identifier('code')), t.memberExpression(t.identifier('response'), t.identifier('status')))), t.expressionStatement(t.assignmentExpression("=", t.memberExpression(t.identifier('err'), t.identifier('code')), t.memberExpression(t.identifier('response'), t.identifier('metadata')))), t.expressionStatement(t.assignmentExpression("=", t.memberExpression(t.identifier('err'), t.identifier('response')), t.memberExpression(t.identifier('response'), t.identifier('trailers')))), t.expressionStatement(t.callExpression(t.identifier('reject'), [t.identifier('err')]))]))])))])]))]))]))]))])));
};
exports.getGrpcWebImpl = getGrpcWebImpl;