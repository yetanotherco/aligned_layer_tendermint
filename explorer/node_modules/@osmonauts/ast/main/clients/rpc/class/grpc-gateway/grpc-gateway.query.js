"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createGRPCGatewayQueryClass = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _utils = require("../../../../utils");
var _utils2 = require("@osmonauts/utils");
var _rpc = require("../utils/rpc");
var _utils3 = require("./utils");
var t = _interopRequireWildcard(require("@babel/types"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var staticExpressionsNoUnwrappable = t.callExpression(t.memberExpression(t.identifier('fm'), t.identifier('renderURLSearchParams'), false), [t.objectExpression([t.spreadElement(t.identifier('request'))]), t.arrayExpression([])]);
// {...initReq, method: "GET"}
var staticSecondFetchReqArg = t.objectExpression([t.spreadElement(t.identifier('initRequest')), t.objectProperty(t.identifier('method'), t.stringLiteral('GET'), false, false)]);
var getQuasisNoUnwrappable = function getQuasisNoUnwrappable(path) {
  var quasis = [];

  // path?
  // ex: /cosmos/bank/v1beta1/supply?
  quasis.push(t.templateElement({
    raw: path + '?',
    cooked: path + '?'
  }, false));

  // add empty tail element
  quasis.push(t.templateElement({
    raw: '',
    cooked: ''
  }, true));
  return quasis;
};

// get quasis (string expressions) when there is an unwrappable element (quasis.length must === 3)
var getQuasisUnwrappable = function getQuasisUnwrappable(leftPath, rightPath) {
  var quasis = [];

  // add left path element to quasis (path before unwrappable element)
  quasis.push(t.templateElement({
    raw: leftPath,
    cooked: leftPath
  }, false));

  // add remaining path (if exists) or only '?' sign
  quasis.push(t.templateElement({
    raw: rightPath != '' ? rightPath + '?' : '?',
    cooked: rightPath != '' ? rightPath + '?' : '?'
  }, false));

  // add empty tail element
  quasis.push(t.templateElement({
    raw: '',
    cooked: ''
  }, true));
  return quasis;
};
var getExpressionsNoUnwrappable = function getExpressionsNoUnwrappable() {
  return [staticExpressionsNoUnwrappable];
};

// Get expressions for a path with unwrappable.
// Returning array must be of length 2.
// example expressions: ${req["denom"]} AND ${fm.renderURLSearchParams(req, ["denom"])}
var getExpressionsUnwrappable = function getExpressionsUnwrappable(path, indexLeft, indexRight) {
  var expressions = [];
  var unwrappable = path.slice(indexLeft + 1, indexRight);

  // ${req["denom"]}
  expressions.push(t.memberExpression(t.identifier('request'), t.stringLiteral(unwrappable), true));

  // ${fm.renderURLSearchParams(req, ["denom"])}
  expressions.push(t.callExpression(t.memberExpression(t.identifier('fm'), t.identifier('renderURLSearchParams'), false), [t.objectExpression([t.spreadElement(t.identifier('request'))]), t.arrayExpression([t.stringLiteral(unwrappable)])]));
  return expressions;
};

// Get fm.fetchReq arguments if there is no unwrappable element
// In this case, len of quasis must be 2 and len of expressions must be 1.
var getFetchReqArgsNoUnwrappable = function getFetchReqArgsNoUnwrappable(path) {
  var args = [];
  var quasis = getQuasisNoUnwrappable(path);
  var expressions = getExpressionsNoUnwrappable();
  args.push(t.templateLiteral(quasis, expressions));

  // {...initReq, method: "GET"}
  args.push(staticSecondFetchReqArg);
  return args;
};

// Get fm.fetchReq arguments if there is an unwrappable element
// In this case, len of quasis must be 3 and len of expressions must be 2.
var getFetchReqArgsUnwrappable = function getFetchReqArgsUnwrappable(path, indexLeft, indexRight) {
  var args = [];
  var leftPath = path.slice(0, indexLeft);
  var rightPath = path.slice(indexRight + 1);

  // first argument
  // ex: `/cosmos/bank/v1beta1/denoms_metadata/${req["denom"]}?${fm.renderURLSearchParams(req, ["denom"])}`
  var quasis = getQuasisUnwrappable(leftPath, rightPath);
  var expressions = getExpressionsUnwrappable(path, indexLeft, indexRight);
  args.push(t.templateLiteral(quasis, expressions));

  // {...initReq, method: "GET"}
  args.push(staticSecondFetchReqArg);
  return args;
};

// fetchArgs will be used in method body's return statement expression.
// Contains arguments to fm.fetchReq
var getFetchReqArgs = function getFetchReqArgs(context, svc) {
  // getPath ex: 
  // rpc Grants(QueryGrantsRequest) returns (QueryGrantsResponse) {
  //     option (google.api.http).get = "/cosmos/authz/v1beta1/grants";
  // }
  var getPath;
  try {
    getPath = svc.options['(google.api.http).get'];
  } catch (_unused) {}
  if (typeof getPath === 'undefined') {
    getPath = context.ref.proto["package"] + '.' + svc.name;
  }
  var args;

  // check if getPath contains "unwrappable" elements in path
  // ex: "/cosmos/bank/v1beta1/balances/{address}" 
  // {address} here is what I mean by "unwrappable"
  if (getPath.indexOf('{') > -1) {
    var indexLeft = getPath.indexOf('{');
    var indexRight = getPath.indexOf('}');
    args = buildFetchReqArgs(getPath, true, indexLeft, indexRight);
  } else {
    args = buildFetchReqArgs(getPath, false);
  }
  return args;
};
var buildFetchReqArgs = function buildFetchReqArgs(path, unwrappable) {
  var indexLeft = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
  var indexRight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;
  var args = [];
  if (unwrappable) {
    if (indexLeft === -1 || indexRight === -1) {
      throw new Error("indexLeft and indexRight must be provided when path has {unwrappable} element");
    }
    args = getFetchReqArgsUnwrappable(path, indexLeft, indexRight);
  } else {
    args = getFetchReqArgsNoUnwrappable(path);
  }
  return args;
};

// function to define a method of grpc-gateway style
var grpcGatewayMethodDefinition = function grpcGatewayMethodDefinition(context, name, svc, leadingComments) {
  var requestType = svc.requestType;
  var responseType = svc.responseType;

  // first parameter in method
  // ex: static Send(request: MsgSend)
  // paramRequest is an object representing everything in brackets here
  var paramRequest = (0, _utils.identifier)('request', t.tsTypeAnnotation(t.tsTypeReference(t.identifier(requestType))), false);

  // fm.fetchReq(fetchArgs are here)
  var fetchArgs = getFetchReqArgs(context, svc);

  // class method body (only return statement)
  var body = t.blockStatement([t.returnStatement(t.callExpression(t.memberExpression(t.identifier('fm'), t.identifier('fetchReq'), false), fetchArgs))]);
  return (0, _utils.classMethod)('method', t.identifier(name), [paramRequest, _utils3.initRequest],
  // params
  body, (0, _rpc.returnReponseType)(responseType), leadingComments, false, true // static 
  );
};

var createGRPCGatewayQueryClass = function createGRPCGatewayQueryClass(context, service) {
  var _service$methods;
  // adds import 
  context.addUtil('fm');
  var camelRpcMethods = context.pluginValue('rpcClient.camelCase');
  var keys = Object.keys((_service$methods = service.methods) !== null && _service$methods !== void 0 ? _service$methods : {});
  var methods = keys.map(function (key) {
    var method = service.methods[key];
    var name = camelRpcMethods ? (0, _utils2.camel)(key) : key;
    var leadingComments = method.comment ? [(0, _utils.commentBlock)((0, _rpc.processRpcComment)(method))] : [];
    return grpcGatewayMethodDefinition(context, name, method, leadingComments);
  });
  return t.exportNamedDeclaration(t.classDeclaration(t.identifier(service.name), null, t.classBody((0, _toConsumableArray2["default"])(methods)), []));
};
exports.createGRPCGatewayQueryClass = createGRPCGatewayQueryClass;