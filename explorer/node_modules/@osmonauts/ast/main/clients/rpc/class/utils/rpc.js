"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.returnReponseType = exports.processRpcComment = exports.optionalBool = exports.cleanType = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _utils = require("../../../../utils");
var t = _interopRequireWildcard(require("@babel/types"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var ensureOneSpaceEnd = function ensureOneSpaceEnd(str) {
  if (/[\s\n\t]$/.test(str)) return str;
  return "".concat(str, " ");
};
var ensureOneSpace = function ensureOneSpace(str) {
  if (/^[\s\n\t]+/.test(str)) return str;
  return " ".concat(str);
};
var processRpcComment = function processRpcComment(e) {
  var comment = e.comment;
  if (!comment) return '';
  if (!/[\n]+/.test(comment)) {
    return "*".concat(ensureOneSpaceEnd(ensureOneSpace((0, _utils.cleanComment)(comment))));
  }
  var lines = comment.split('\n');
  lines = ['*'].concat((0, _toConsumableArray2["default"])(lines), [' ']);
  var comments = lines.map(function (line, i) {
    if (i == 0) return line;
    if (i == lines.length - 1) return (0, _utils.cleanComment)(line);
    return " *".concat(ensureOneSpace((0, _utils.cleanComment)(line)));
  });
  return comments.join('\n');
};
exports.processRpcComment = processRpcComment;
var cleanType = function cleanType(ResponseType) {
  // MARKED AS NOT DRY [google.protobuf names]
  // TODO some have google.protobuf.Any shows up... figure out the better way to handle this
  if (/\./.test(ResponseType)) {
    ResponseType = ResponseType.split('.')[ResponseType.split('.').length - 1];
  }
  return ResponseType;
};
exports.cleanType = cleanType;
var returnReponseType = function returnReponseType(ResponseType) {
  ResponseType = cleanType(ResponseType);
  return t.tsTypeAnnotation(t.tsTypeReference(t.identifier('Promise'), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(ResponseType))])));
};
exports.returnReponseType = returnReponseType;
var optionalBool = function optionalBool(hasParams, fieldNames) {
  if (!hasParams) {
    return true;
  } else if (hasParams && fieldNames.length === 1 && fieldNames.includes('pagination')) {
    // if only argument "required" is pagination 
    // also default to empty 
    return true;
  }
  return false;
};
exports.optionalBool = optionalBool;