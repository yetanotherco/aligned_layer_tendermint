"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createGRPCGatewayMsgClass = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _utils = require("../../../../utils");
var _utils2 = require("@osmonauts/utils");
var _rpc = require("../utils/rpc");
var _utils3 = require("./utils");
var _utils4 = require("../utils");
var t = _interopRequireWildcard(require("@babel/types"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
// fetchArgs will be used in method body's return statement expression.
// Contains arguments to fm.fetchReq
var getFetchReqArgs = function getFetchReqArgs(name, packageImport) {
  var fetchArgs = [];
  // first argument of fetchReq
  var argTemplateLiteral = t.templateLiteral([t.templateElement({
    raw: '/' + packageImport + '/' + name,
    cooked: '/' + packageImport + '/' + name
  }, true)],
  // quasis
  [] // empty expressions
  );

  // adds proto path to fetchReq
  fetchArgs.push(argTemplateLiteral);

  // initReqProperties (contains information for initReq parameter in fetchReq) arguments: 
  var initReqProperties = (0, _utils3.getInitReqProperties)();
  var fetchArgsInitReqObj = t.objectExpression(initReqProperties);
  // adds initReq parameter to fetchReq
  fetchArgs.push(fetchArgsInitReqObj);
  return fetchArgs;
};
var grpcGatewayMethodDefinition = function grpcGatewayMethodDefinition(name, svc, packageImport, leadingComments) {
  var _svc$fields;
  var requestType = svc.requestType;
  var responseType = svc.responseType;
  var fieldNames = Object.keys((_svc$fields = svc.fields) !== null && _svc$fields !== void 0 ? _svc$fields : {});
  var hasParams = fieldNames.length > 0;
  var optional = (0, _rpc.optionalBool)(hasParams, fieldNames);

  // first parameter in method
  // ex: static Send(request: MsgSend)
  // paramRequest is an object representing everything in brackets here
  var paramRequest = (0, _utils.identifier)('request', t.tsTypeAnnotation(t.tsTypeReference(t.identifier(requestType))), optional);

  // fetchArgs will be used in method body's return statement expression.
  // Contains arguments to fm.fetchReq
  var fetchArgs = getFetchReqArgs(name, packageImport);

  // method's body
  var body = t.blockStatement([t.returnStatement(t.callExpression(t.memberExpression(t.identifier('fm'), t.identifier('fetchReq')), fetchArgs))]);
  return (0, _utils.classMethod)('method', t.identifier(name), [paramRequest, _utils3.initRequest],
  // params
  body, (0, _rpc.returnReponseType)(responseType), leadingComments, false, true // static 
  );
};

var createGRPCGatewayMsgClass = function createGRPCGatewayMsgClass(context, service) {
  var _service$methods;
  // adds import 
  context.addUtil('fm');
  var camelRpcMethods = context.pluginValue('rpcClient.camelCase');
  var keys = Object.keys((_service$methods = service.methods) !== null && _service$methods !== void 0 ? _service$methods : {});
  var methods = keys.map(function (key) {
    var method = service.methods[key];
    var name = camelRpcMethods ? (0, _utils2.camel)(key) : key;
    var leadingComments = method.comment ? [(0, _utils.commentBlock)((0, _utils4.processRpcComment)(method))] : [];
    return grpcGatewayMethodDefinition(name, method, context.ref.proto["package"], leadingComments);
  });
  return t.exportNamedDeclaration(t.classDeclaration(t.identifier(service.name), null, t.classBody((0, _toConsumableArray2["default"])(methods)), []));
};
exports.createGRPCGatewayMsgClass = createGRPCGatewayMsgClass;