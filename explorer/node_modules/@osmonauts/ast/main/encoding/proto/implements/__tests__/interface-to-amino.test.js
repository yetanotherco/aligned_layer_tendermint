"use strict";

var _testUtils = require("../../../../../test-utils/");
var _context = require("../../../context");
var _toAmino = require("../to-amino");
var store = (0, _testUtils.getTestProtoStore)();
store.options.interfaces.enabled = true;
store.options.aminoEncoding.enabled = true;
store.options.aminoEncoding.useRecursiveV2encoding = true;
store.traverseAll();
var typeMap = {
  ProposalContentI: [{
    ref: 'a/b/c.proto',
    pkg: 'a.b.c',
    types: [{
      typeUrl: '/cosmos.gov.v1beta1.TextProposal',
      aminoType: 'cosmos-sdk/TextProposal',
      type: 'TextProposal',
      importAs: 'TextProposal'
    }]
  }]
};
describe('ProposalContent', function () {
  var txRef = store.findProto('cosmos/gov/v1/tx.proto');
  var txContext = new _context.ProtoParseContext(txRef, store, store.options);
  it('ProposalContent helper', function () {
    (0, _testUtils.expectCode)((0, _toAmino.createInterfaceToAminoHelper)(txContext, 'ProposalContentI_toAmino', typeMap['ProposalContentI']));
  });
  it('ProposalContent', function () {
    (0, _testUtils.expectCode)((0, _toAmino.createInterfaceToAmino)(txContext, txRef, 'ProposalContentI'));
  });
});
describe('MsgCreateValidator', function () {
  var ref = store.findProto('cosmos/staking/v1beta1/tx.proto');
  var ctx = new _context.ProtoParseContext(ref, store, store.options);
  it('MsgCreateValidator', function () {
    (0, _testUtils.expectCode)((0, _toAmino.createInterfaceToAmino)(ctx, ref, 'cosmos.crypto.PubKey'));
  });
});