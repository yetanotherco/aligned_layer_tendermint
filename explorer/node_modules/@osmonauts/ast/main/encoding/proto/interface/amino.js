"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createEnumAminoType = exports.createAminoTypeType = exports.createAminoType = void 0;
var t = _interopRequireWildcard(require("@babel/types"));
var _utils = require("../../../utils");
var _types2 = require("../types");
var _types3 = require("../../types");
var _amino = require("../../amino");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var getAminoField = function getAminoField(context, field) {
  var ast = null;
  ast = (0, _types3.getFieldAminoTypeReference)(context, field);
  if (field.rule === 'repeated') {
    ast = t.tsArrayType(ast);
  }
  if (field.keyType) {
    ast = t.tsUnionType([t.tsTypeLiteral([t.tsIndexSignature([(0, _utils.identifier)('key', t.tsTypeAnnotation((0, _types3.getTSAminoType)(context, field.keyType)))], t.tsTypeAnnotation(ast))])]);
  }
  return ast;
};
var createAminoType = function createAminoType(context, name, proto) {
  var _proto$options;
  var oneOfs = (0, _types2.getOneOfs)(proto);
  var AminoName = _types3.SymbolNames.Amino(name);

  // scalar amino types!
  var declaration;
  if (proto.type === 'Type') {
    switch (proto.name) {
      case 'Duration':
      case 'google.protobuf.Duration':
      case 'Timestamp':
      case 'google.protobuf.Timestamp':
        declaration = t.exportNamedDeclaration(t.tsTypeAliasDeclaration(t.identifier(AminoName), null, t.tsStringKeyword()));
        break;
      default:
    }
  }

  // declaration
  if (!declaration) {
    declaration = t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier(AminoName), null, [], t.tsInterfaceBody(Object.keys(proto.fields).reduce(function (m, fieldName) {
      var _field$options$Teles, _field$options, _field$options2;
      var isOneOf = oneOfs.includes(fieldName);
      var field = proto.fields[fieldName];
      var orig = (_field$options$Teles = (_field$options = field.options) === null || _field$options === void 0 ? void 0 : _field$options['(telescope:orig)']) !== null && _field$options$Teles !== void 0 ? _field$options$Teles : fieldName;

      // this (useOriginalCase) is always true, right?
      // let fieldNameWithCase = options.useOriginalCase ? orig : fieldName;
      var fieldNameWithCase = orig;

      // should we actually just edit/add comments 
      // to make this more "native" for any google.protobuf.Any?
      // let's see...
      if (name === 'Any' && context.ref.proto["package"] === 'google.protobuf' &&
      // options.type === 'Amino' &&
      orig === 'type_url') {
        // type_url => type
        fieldNameWithCase = 'type';
      }
      var aminoField = getAminoField(context, field);
      if (name === 'Any' && context.ref.proto["package"] === 'google.protobuf' &&
      // options.type === 'Amino' &&
      orig === 'value') {
        aminoField = t.tsAnyKeyword();
      }
      var propSig = (0, _utils.tsPropertySignature)(t.identifier(fieldNameWithCase), t.tsTypeAnnotation(aminoField), (0, _types2.getFieldOptionality)(context, field, isOneOf));
      var comments = [];
      if (field.comment) {
        comments.push((0, _utils.makeCommentBlock)(field.comment));
      }
      if ((_field$options2 = field.options) !== null && _field$options2 !== void 0 && _field$options2.deprecated) {
        comments.push((0, _utils.makeCommentBlock)('@deprecated'));
      }
      if (comments.length) {
        propSig.leadingComments = comments;
      }
      m.push(propSig);
      return m;
    }, []))));
  }
  var comments = [];
  if (proto.comment) {
    comments.push((0, _utils.makeCommentBlock)(proto.comment));
  }
  if ((_proto$options = proto.options) !== null && _proto$options !== void 0 && _proto$options.deprecated) {
    comments.push((0, _utils.makeCommentBlock)('@deprecated'));
  }
  if (comments.length) {
    declaration.leadingComments = comments;
  }
  return declaration;
};
exports.createAminoType = createAminoType;
var createAminoTypeType = function createAminoTypeType(context, name, proto) {
  var AminoName = _types3.SymbolNames.Amino(name);
  var AminoTypeName = _types3.SymbolNames.AminoMsg(name);
  var aminoName = (0, _amino.getAminoTypeName)(context, context.ref.proto, proto);
  var typ = aminoName ? t.tsLiteralType(t.stringLiteral(aminoName)) : t.tsTypeReference(t.identifier('string'));
  var typeAnnotation = t.tsTypeAnnotation(typ);
  if (name === 'Any' && context.ref.proto["package"] === 'google.protobuf') {
    // replace type with plain string for this one case
    typeAnnotation = t.tsTypeAnnotation(t.tsStringKeyword());
  }

  // scalar amino types!
  return t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier(AminoTypeName), null, [], t.tsInterfaceBody([(0, _utils.tsPropertySignature)(t.identifier('type'), typeAnnotation, false), (0, _utils.tsPropertySignature)(t.identifier('value'), t.tsTypeAnnotation(t.tsTypeReference(t.identifier(AminoName))), false)])));
};
exports.createAminoTypeType = createAminoTypeType;
var createEnumAminoType = function createEnumAminoType(context, name, proto) {
  return t.exportNamedDeclaration(t.variableDeclaration('const', [t.variableDeclarator(t.identifier(_types3.SymbolNames.Amino(name)), t.identifier(name))]));
  // return createProtoEnum(
  //     context,
  //     name + 'Amino',
  //     proto
  // );
};
exports.createEnumAminoType = createEnumAminoType;