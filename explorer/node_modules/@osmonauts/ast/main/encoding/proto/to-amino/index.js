"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toAminoMsgMethod = exports.toAminoJSONMethodFields = exports.toAminoJSONMethod = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var t = _interopRequireWildcard(require("@babel/types"));
var _ = require("..");
var _utils = require("../../../utils");
var _utils2 = require("./utils");
var _types2 = require("../../types");
var _amino = require("../../amino");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var needsImplementation = function needsImplementation(name, field) {
  throw new Error("need to implement toAminoJSON (".concat(field.type, " rules[").concat(field.rule, "] name[").concat(name, "])"));
};
var toAminoJSONMethodFields = function toAminoJSONMethodFields(context, name, proto) {
  var _proto$fields;
  var oneOfs = (0, _.getOneOfs)(proto);
  var fields = Object.keys((_proto$fields = proto.fields) !== null && _proto$fields !== void 0 ? _proto$fields : {}).reduce(function (m, fieldName) {
    var field = _objectSpread({
      name: fieldName
    }, proto.fields[fieldName]);
    var isOneOf = oneOfs.includes(fieldName);
    var isOptional = (0, _.getFieldOptionality)(context, field, isOneOf);
    var args = {
      context: context,
      field: field,
      isOptional: isOptional
    };

    // arrays
    if (field.rule === 'repeated') {
      switch (field.type) {
        case 'string':
          return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.array(args, _utils2.arrayTypes.string())]);
        case 'bytes':
          return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.array(args, _utils2.arrayTypes.bytes(args))]);
        case 'bool':
          return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.array(args, _utils2.arrayTypes.bool())]);
        case 'double':
          return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.array(args, _utils2.arrayTypes["double"]())]);
        case 'float':
          return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.array(args, _utils2.arrayTypes["float"]())]);
        case 'int32':
          return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.array(args, _utils2.arrayTypes.int32())]);
        case 'sint32':
          return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.array(args, _utils2.arrayTypes.sint32())]);
        case 'uint32':
          return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.array(args, _utils2.arrayTypes.uint32())]);
        case 'fixed32':
          return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.array(args, _utils2.arrayTypes.fixed32())]);
        case 'sfixed32':
          return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.array(args, _utils2.arrayTypes.sfixed32())]);
        case 'int64':
          return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.array(args, _utils2.arrayTypes.int64(args))]);
        case 'sint64':
          return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.array(args, _utils2.arrayTypes.sint64(args))]);
        case 'uint64':
          return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.array(args, _utils2.arrayTypes.uint64(args))]);
        case 'fixed64':
          return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.array(args, _utils2.arrayTypes.fixed64(args))]);
        case 'sfixed64':
          return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.array(args, _utils2.arrayTypes.sfixed64(args))]);
        default:
          switch (field.parsedType.type) {
            case 'Enum':
              return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.array(args, _utils2.arrayTypes["enum"](args))]);
            case 'Type':
              return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.array(args, _utils2.arrayTypes.type(args))]);
          }
          return needsImplementation(fieldName, field);
      }
    }
    if (field.keyType) {
      switch (field.keyType) {
        case 'string':
        case 'int32':
        case 'sint32':
        case 'uint32':
        case 'fixed32':
        case 'sfixed32':
        case 'int64':
        case 'sint64':
        case 'uint64':
        case 'fixed64':
        case 'sfixed64':
          return [].concat((0, _toConsumableArray2["default"])(m), (0, _toConsumableArray2["default"])(_utils2.toAminoJSON.keyHash(args)));
        default:
          return needsImplementation(fieldName, field);
      }
    }

    // casting Any types
    if (field.type === 'google.protobuf.Any') {
      var _field$options;
      switch ((_field$options = field.options) === null || _field$options === void 0 ? void 0 : _field$options['(cosmos_proto.accepts_interface)']) {
        case 'cosmos.crypto.PubKey':
          return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.pubkey(args)]);
      }
    }
    if (field.type === 'bytes') {
      var _field$options2, _field$options3;
      // bytes [RawContractMessage]
      if (((_field$options2 = field.options) === null || _field$options2 === void 0 ? void 0 : _field$options2['(gogoproto.casttype)']) === 'RawContractMessage') {
        return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.rawBytes(args)]);
      }
      // bytes [WASMByteCode]
      // TODO use a better option for this in proto source
      if (((_field$options3 = field.options) === null || _field$options3 === void 0 ? void 0 : _field$options3['(gogoproto.customname)']) === 'WASMByteCode') {
        return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.wasmByteCode(args)]);
      }
    }

    // default types
    switch (field.type) {
      case 'string':
        return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.string(args)]);
      case 'double':
        return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON["double"](args)]);
      case 'float':
        return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON["float"](args)]);
      case 'bytes':
        return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.bytes(args)]);
      case 'bool':
        return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.bool(args)]);
      case 'int32':
        return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.int32(args)]);
      case 'sint32':
        return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.sint32(args)]);
      case 'uint32':
        return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.uint32(args)]);
      case 'fixed32':
        return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.fixed32(args)]);
      case 'sfixed32':
        return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.sfixed32(args)]);
      case 'int64':
        return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.int64(args)]);
      case 'sint64':
        return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.sint64(args)]);
      case 'uint64':
        return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.uint64(args)]);
      case 'fixed64':
        return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.fixed64(args)]);
      case 'sfixed64':
        return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.sfixed64(args)]);
      case 'google.protobuf.Duration':
      case 'Duration':
        return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.duration(args)]);
      case 'google.protobuf.Timestamp':
      case 'Timestamp':
        return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.timestamp(args)]);
      default:
        switch (field.parsedType.type) {
          case 'Enum':
            return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON["enum"](args)]);
          case 'Type':
            return [].concat((0, _toConsumableArray2["default"])(m), [_utils2.toAminoJSON.type(args)]);
        }
        return needsImplementation(fieldName, field);
    }
  }, []);
  return fields;
};
exports.toAminoJSONMethodFields = toAminoJSONMethodFields;
var toAminoJSONMethod = function toAminoJSONMethod(context, name, proto) {
  var fields = toAminoJSONMethodFields(context, name, proto);
  var varName = 'message';
  if (!fields.length) {
    varName = '_';
  }
  var AminoTypeName = _types2.SymbolNames.Amino(name);
  var body = [];

  // 1. some messages we parse specially
  if (proto.type === 'Type') {
    switch (proto.name) {
      case 'Duration':
      case 'google.protobuf.Duration':
        {
          body.push(_utils2.toAminoMessages.duration(context, name, proto));
          break;
        }
      // case 'Timestamp':
      // case 'google.protobuf.Timestamp':
      //     body.push(t.returnStatement(
      //         t.objectExpression([
      //         ])
      //     ))
      //     break;
      default:
    }
  }
  if (!body.length) {
    // 2. default to field-level parsing
    [].push.apply(body, [t.variableDeclaration('const', [t.variableDeclarator((0, _utils.identifier)('obj', t.tsTypeAnnotation(t.tsAnyKeyword())), t.objectExpression([]))])].concat((0, _toConsumableArray2["default"])(fields), [
    // RETURN 
    t.returnStatement(t.identifier('obj'))]));
  }
  return (0, _utils.objectMethod)('method', t.identifier('toAmino'), [(0, _utils.identifier)(varName, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(name))))], t.blockStatement(body), false, false, false, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(AminoTypeName))));
};
exports.toAminoJSONMethod = toAminoJSONMethod;
var toAminoMsgMethod = function toAminoMsgMethod(context, name, proto) {
  var varName = 'message';
  var ReturnType = _types2.SymbolNames.AminoMsg(name);
  var TypeName = _types2.SymbolNames.Msg(name);
  var aminoType = (0, _amino.getAminoTypeName)(context, context.ref.proto, proto);
  if (!aminoType || aminoType.startsWith('/')) return;
  var body = [];

  // body
  body.push(t.returnStatement(t.objectExpression([t.objectProperty(t.identifier('type'), t.stringLiteral(aminoType)), t.objectProperty(t.identifier('value'), t.callExpression(t.memberExpression(t.identifier(TypeName), t.identifier('toAmino')), [t.identifier(varName)]))])));
  return (0, _utils.objectMethod)('method', t.identifier('toAminoMsg'), [(0, _utils.identifier)(varName, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(TypeName))))], t.blockStatement(body), false, false, false, t.tsTypeAnnotation(t.tsTypeReference(t.identifier(ReturnType))));
};
exports.toAminoMsgMethod = toAminoMsgMethod;