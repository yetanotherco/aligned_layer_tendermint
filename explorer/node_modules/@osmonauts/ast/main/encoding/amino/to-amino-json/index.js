"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toAminoParseField = exports.toAminoJsonMethod = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var t = _interopRequireWildcard(require("@babel/types"));
var _utils = require("../../../utils");
var _utils2 = require("../utils");
var _utils3 = require("./utils");
var _proto = require("../../proto");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var needsImplementation = function needsImplementation(name, field) {
  throw new Error("need to implement toAmino (".concat(field.type, " rules[").concat(field.rule, "] name[").concat(name, "])"));
};
var warningDefaultImplementation = function warningDefaultImplementation(name, field) {
  console.warn("need to implement toAmino (".concat(field.type, " rules[").concat(field.rule, "] name[").concat(name, "])"));
};
;
var toAminoParseField = function toAminoParseField(_ref) {
  var context = _ref.context,
    field = _ref.field,
    currentProtoPath = _ref.currentProtoPath,
    previousScope = _ref.scope,
    previousFieldPath = _ref.fieldPath,
    nested = _ref.nested,
    isOptional = _ref.isOptional;
  var scope = [field.name].concat((0, _toConsumableArray2["default"])(previousScope));
  var fieldPath = [field].concat((0, _toConsumableArray2["default"])(previousFieldPath));
  var args = {
    context: context,
    field: field,
    currentProtoPath: currentProtoPath,
    scope: scope,
    fieldPath: fieldPath,
    nested: nested,
    isOptional: isOptional
  };

  // arrays
  if (field.rule === 'repeated') {
    switch (field.type) {
      case 'string':
        return _utils3.toAmino.string(args);
      case 'int64':
      case 'sint64':
      case 'uint64':
      case 'fixed64':
      case 'sfixed64':
        return _utils3.toAmino.scalarArray(args, _utils3.arrayTypes["long"]);
      case 'double':
      case 'float':
      case 'int32':
      case 'sint32':
      case 'uint32':
      case 'fixed32':
      case 'sfixed32':
      case 'bool':
      case 'bytes':
        return _utils3.toAmino.defaultType(args);
      case 'string':
        return _utils3.toAmino.string(args);
    }
    switch (field.parsedType.type) {
      case 'Type':
        return _utils3.toAmino.typeArray(args);
    }
    return needsImplementation(field.name, field);
  }

  // casting Any types
  if (field.type === 'google.protobuf.Any') {
    var _field$options;
    switch ((_field$options = field.options) === null || _field$options === void 0 ? void 0 : _field$options['(cosmos_proto.accepts_interface)']) {
      case 'cosmos.crypto.PubKey':
        return _utils3.toAmino.pubkey(args);
    }
  }

  // special types...
  switch (field.type) {
    case 'Timestamp':
    case 'google.protobuf.Timestamp':
      return _utils3.toAmino.defaultType(args);
    case 'cosmos.base.v1beta1.Coin':
      return _utils3.toAmino.coin(args);

    // TODO check can we just
    // make pieces optional and avoid hard-coding this type?
    case 'ibc.core.client.v1.Height':
    case 'Height':
      return _utils3.toAmino.height(args);
    case 'Duration':
    case 'google.protobuf.Duration':
      return _utils3.toAmino.duration(args);
    default:
  }

  // Types/Enums
  switch (field.parsedType.type) {
    case 'Enum':
      return _utils3.toAmino.defaultType(args);
    case 'Type':
      return _utils3.toAmino.type(args);
  }
  if (field.type === 'bytes') {
    var _field$options2, _field$options3;
    // bytes [RawContractMessage]
    if (((_field$options2 = field.options) === null || _field$options2 === void 0 ? void 0 : _field$options2['(gogoproto.casttype)']) === 'RawContractMessage') {
      return _utils3.toAmino.rawBytes(args);
    }
    // bytes [WASMByteCode]
    // TODO use a better option for this in proto source
    if (((_field$options3 = field.options) === null || _field$options3 === void 0 ? void 0 : _field$options3['(gogoproto.customname)']) === 'WASMByteCode') {
      return _utils3.toAmino.wasmByteCode(args);
    }
  }

  // scalar types...
  switch (field.type) {
    case 'string':
      return _utils3.toAmino.string(args);
    case 'int64':
    case 'sint64':
    case 'uint64':
    case 'fixed64':
    case 'sfixed64':
      return _utils3.toAmino["long"](args);
    case 'double':
    case 'float':
    case 'int32':
    case 'sint32':
    case 'uint32':
    case 'fixed32':
    case 'sfixed32':
    case 'bool':
    case 'bytes':
      return _utils3.toAmino.defaultType(args);
    default:
      warningDefaultImplementation(field.name, field);
      return _utils3.toAmino.defaultType(args);
  }
};
exports.toAminoParseField = toAminoParseField;
var toAminoJsonMethod = function toAminoJsonMethod(_ref2) {
  var context = _ref2.context,
    proto = _ref2.proto;
  var toAminoParams = t.objectPattern((0, _utils2.protoFieldsToArray)(proto).map(function (field) {
    return t.objectProperty(t.identifier(field.name), t.identifier(field.name), false, true);
  }));
  toAminoParams.typeAnnotation = t.tsTypeAnnotation(t.tsTypeReference(t.identifier(proto.name)));
  var oneOfs = (0, _proto.getOneOfs)(proto);
  var fields = (0, _utils2.protoFieldsToArray)(proto).map(function (field) {
    var isOneOf = oneOfs.includes(field.name);
    var isOptional = (0, _proto.getFieldOptionality)(context, field, isOneOf);
    var aminoField = toAminoParseField({
      context: context,
      field: field,
      currentProtoPath: context.ref.filename,
      scope: [],
      fieldPath: [],
      nested: 0,
      isOptional: isOptional
    });
    return {
      ctx: context,
      field: aminoField
    };
  });

  // const ctxs = fields.map(({ ctx }) => ctx);
  // ctxs.forEach(ctx => {
  //     // console.log('imports, ', ctx)
  // })

  return (0, _utils.arrowFunctionExpression)([toAminoParams], t.blockStatement([t.returnStatement(t.objectExpression(fields.map(function (_ref3) {
    var field = _ref3.field;
    return field;
  })))]), t.tsTypeAnnotation(t.tsIndexedAccessType(t.tsTypeReference(t.identifier(proto.name + 'AminoType')), t.tsLiteralType(t.stringLiteral('value')))));
};
exports.toAminoJsonMethod = toAminoJsonMethod;