"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toAmino = exports.arrayTypes = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var t = _interopRequireWildcard(require("@babel/types"));
var _utils = require("../../../utils");
var _utils2 = require("../utils");
var _index = require("./index");
var _proto = require("../../proto");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var toAmino = {
  defaultType: function defaultType(args) {
    if (args.field.name === args.context.aminoCaseField(args.field) && args.scope.length === 1) {
      return (0, _utils.shorthandProperty)(args.field.name);
    }
    return t.objectProperty(t.identifier(args.context.aminoCaseField(args.field)), (0, _utils.memberExpressionOrIdentifier)(args.scope));
  },
  "long": function long(args) {
    return t.objectProperty(t.identifier(args.context.aminoCaseField(args.field)), t.callExpression(t.memberExpression((0, _utils.memberExpressionOrIdentifier)(args.scope), t.identifier('toString')), []));
  },
  string: function string(args) {
    if (args.field.name === args.context.aminoCaseField(args.field) && args.scope.length === 1) {
      return (0, _utils.shorthandProperty)(args.field.name);
    }
    return t.objectProperty(t.identifier(args.context.aminoCaseField(args.field)), (0, _utils.memberExpressionOrIdentifier)(args.scope));
  },
  rawBytes: function rawBytes(args) {
    args.context.addUtil('fromUtf8');
    return t.objectProperty(t.identifier(args.context.aminoCaseField(args.field)), t.callExpression(t.memberExpression(t.identifier('JSON'), t.identifier('parse')), [t.callExpression(t.identifier('fromUtf8'), [(0, _utils.memberExpressionOrIdentifier)(args.scope)])]));
  },
  wasmByteCode: function wasmByteCode(args) {
    args.context.addUtil('toBase64');
    return t.objectProperty(t.identifier(args.context.aminoCaseField(args.field)), t.callExpression(t.identifier('toBase64'), [(0, _utils.memberExpressionOrIdentifier)(args.scope)]));
  },
  duration: function duration(args) {
    var durationFormat = args.context.pluginValue('prototypes.typingsFormat.duration');
    var updatedDuration = args.context.pluginValue('prototypes.typingsFormat.updatedDuration');
    switch (durationFormat) {
      case 'duration':
        if (updatedDuration) {
          return toAmino.durationType(args);
        }
      case 'string':
      default:
        return toAmino.durationString(args);
    }
  },
  // (duration * 1_000_000_000).toString(),
  durationString: function durationString(args) {
    var exp = t.binaryExpression('*', (0, _utils.memberExpressionOrIdentifier)(args.scope), _utils.BILLION);
    exp.extra = {
      parenthesized: true
    };
    var value = t.callExpression(t.memberExpression(exp, t.identifier('toString')), []);
    return t.objectProperty(t.identifier(args.context.aminoCaseField(args.field)), value);
  },
  // (duration.seconds.toInt() * 1_000_000_000).toString(),
  // what about nanos?
  durationType: function durationType(args) {
    var exp = t.binaryExpression('*', t.callExpression(t.memberExpression(t.memberExpression((0, _utils.memberExpressionOrIdentifier)(args.scope), t.identifier('seconds')), t.identifier('toInt')), []), _utils.BILLION);
    exp.extra = {
      parenthesized: true
    };
    var value = t.callExpression(t.memberExpression(exp, t.identifier('toString')), []);
    return t.objectProperty(t.identifier(args.context.aminoCaseField(args.field)), value);
  },
  height: function height(args) {
    args.context.addUtil('omitDefault');
    var value = t.objectExpression([t.objectProperty(t.identifier(args.context.aminoCasingFn('revision_height')), t.optionalCallExpression(t.optionalMemberExpression(t.callExpression(t.identifier('omitDefault'), [t.memberExpression((0, _utils.memberExpressionOrIdentifier)(args.scope), t.identifier('revisionHeight'))]), t.identifier('toString'), false, true), [], false)),
    //
    t.objectProperty(t.identifier(args.context.aminoCasingFn('revision_number')), t.optionalCallExpression(t.optionalMemberExpression(t.callExpression(t.identifier('omitDefault'), [t.memberExpression((0, _utils.memberExpressionOrIdentifier)(args.scope), t.identifier('revisionNumber'))]), t.identifier('toString'), false, true), [], false))]);
    var cond = t.conditionalExpression((0, _utils.memberExpressionOrIdentifier)(args.scope), value, t.objectExpression([]));
    return t.objectProperty(t.identifier(args.context.aminoCaseField(args.field)), cond);
  },
  coin: function coin(args) {
    args.context.addUtil('Long');
    var value = t.objectExpression([t.objectProperty(t.identifier('denom'), t.memberExpression((0, _utils.memberExpressionOrIdentifier)(args.scope), t.identifier('denom'))), t.objectProperty(t.identifier('amount'), t.callExpression(t.memberExpression(t.callExpression(t.memberExpression(t.identifier('Long'), t.identifier('fromValue')), [t.memberExpression((0, _utils.memberExpressionOrIdentifier)(args.scope), t.identifier('amount'))]), t.identifier('toString')), []))]);
    return t.objectProperty(t.identifier(args.context.aminoCaseField(args.field)), value);
  },
  type: function type(_ref) {
    var context = _ref.context,
      field = _ref.field,
      currentProtoPath = _ref.currentProtoPath,
      scope = _ref.scope,
      fieldPath = _ref.fieldPath,
      nested = _ref.nested,
      isOptional = _ref.isOptional;
    /// TODO (can this be refactored out? e.g. no recursive calls in this file?)
    /// BEGIN
    var Type = context.getTypeFromCurrentPath(field, currentProtoPath);
    var parentField = field;
    var oneOfs = (0, _proto.getOneOfs)(Type);
    var properties = (0, _utils2.protoFieldsToArray)(Type).map(function (field) {
      var isOneOf = oneOfs.includes(field.name);
      var isOptional = (0, _proto.getFieldOptionality)(context, field, isOneOf);
      if (parentField["import"]) currentProtoPath = parentField["import"];
      return (0, _index.toAminoParseField)({
        context: context,
        field: field,
        currentProtoPath: currentProtoPath,
        scope: (0, _toConsumableArray2["default"])(scope),
        fieldPath: (0, _toConsumableArray2["default"])(fieldPath),
        nested: nested,
        isOptional: isOptional // TODO how to handle nested optionality
      });
    });
    /// END 
    return t.objectProperty(t.identifier(context.aminoCaseField(field)), t.objectExpression(properties));
  },
  typeArray: function typeArray(_ref2) {
    var context = _ref2.context,
      field = _ref2.field,
      currentProtoPath = _ref2.currentProtoPath,
      scope = _ref2.scope,
      fieldPath = _ref2.fieldPath,
      nested = _ref2.nested,
      isOptional = _ref2.isOptional;
    //////
    var variable = 'el' + nested;
    var f = JSON.parse(JSON.stringify(field)); // clone
    var varProto = _objectSpread({}, f);
    varProto.name = variable;
    varProto.options['(telescope:orig)'] = variable;
    varProto.options['(telescope:name)'] = variable;
    varProto.options['(telescope:camel)'] = variable;
    //////

    if (field.parsedType.type !== 'Type') {
      throw new Error('Arrays only support types[Type] right now.');
    }
    var Type = context.getTypeFromCurrentPath(field, currentProtoPath);
    var parentField = field;
    var oneOfs = (0, _proto.getOneOfs)(Type);
    var properties = (0, _utils2.protoFieldsToArray)(Type).map(function (field) {
      var isOneOf = oneOfs.includes(field.name);
      var isOptional = (0, _proto.getFieldOptionality)(context, field, isOneOf);
      if (parentField["import"]) currentProtoPath = parentField["import"];
      return (0, _index.toAminoParseField)({
        context: context,
        field: field,
        currentProtoPath: currentProtoPath,
        scope: [variable],
        fieldPath: [varProto],
        nested: nested + 1,
        isOptional: isOptional // TODO how to handle nested optionality
      });
    });

    var expr = t.callExpression(t.memberExpression((0, _utils.memberExpressionOrIdentifier)(scope), t.identifier('map')), [t.arrowFunctionExpression([t.identifier(variable)], t.objectExpression(properties))]);
    return t.objectProperty(t.identifier(context.aminoCaseField(field)), expr);
  },
  scalarArray: function scalarArray(_ref3, arrayTypeAstFunc) {
    var context = _ref3.context,
      field = _ref3.field,
      currentProtoPath = _ref3.currentProtoPath,
      scope = _ref3.scope,
      nested = _ref3.nested,
      isOptional = _ref3.isOptional;
    var variable = 'el' + nested;
    var expr = t.callExpression(t.memberExpression((0, _utils.memberExpressionOrIdentifier)(scope), t.identifier('map')), [t.arrowFunctionExpression([t.identifier(variable)], arrayTypeAstFunc(variable))]);
    return t.objectProperty(t.identifier(context.aminoCaseField(field)), expr);
  },
  pubkey: function pubkey(args) {
    args.context.addUtil('fromBase64');
    args.context.addUtil('decodeBech32Pubkey');
    return t.objectProperty(t.identifier(args.field.name), t.objectExpression([t.objectProperty(t.identifier('typeUrl'), t.stringLiteral('/cosmos.crypto.secp256k1.PubKey')), t.objectProperty(t.identifier('value'), t.callExpression(t.identifier('fromBase64'), [t.memberExpression(t.callExpression(t.identifier('decodeBech32Pubkey'), [t.identifier(args.field.name)]), t.identifier('value'))]))]));
  }
};
exports.toAmino = toAmino;
var arrayTypes = {
  "long": function long(varname) {
    return t.callExpression(t.memberExpression((0, _utils.memberExpressionOrIdentifier)([varname]), t.identifier('toString')), []);
  }
};
exports.arrayTypes = arrayTypes;