"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromAmino = exports.arrayTypes = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var t = _interopRequireWildcard(require("@babel/types"));
var _utils = require("../../../utils");
var _index = require("./index");
var _utils2 = require("../utils");
var _proto = require("../../proto");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var fromAmino = {
  defaultType: function defaultType(args) {
    if (args.field.name === args.context.aminoCaseField(args.field) && args.scope.length === 1) {
      return (0, _utils.shorthandProperty)(args.field.name);
    }
    return t.objectProperty(t.identifier(args.field.name), (0, _utils.memberExpressionOrIdentifierAminoCaseField)(args.fieldPath, args.context.aminoCaseField));
  },
  string: function string(args) {
    if (args.field.name === args.context.aminoCaseField(args.field) && args.scope.length === 1) {
      return (0, _utils.shorthandProperty)(args.field.name);
    }
    return t.objectProperty(t.identifier(args.field.name), (0, _utils.memberExpressionOrIdentifierAminoCaseField)(args.fieldPath, args.context.aminoCaseField));
  },
  rawBytes: function rawBytes(args) {
    args.context.addUtil('toUtf8');
    return t.objectProperty(t.identifier(args.field.name), t.callExpression(t.identifier('toUtf8'), [t.callExpression(t.memberExpression(t.identifier('JSON'), t.identifier('stringify')), [(0, _utils.memberExpressionOrIdentifierAminoCaseField)(args.fieldPath, args.context.aminoCaseField)])]));
  },
  wasmByteCode: function wasmByteCode(args) {
    args.context.addUtil('fromBase64');
    return t.objectProperty(t.identifier(args.field.name), t.callExpression(t.identifier('fromBase64'), [(0, _utils.memberExpressionOrIdentifierAminoCaseField)(args.fieldPath, args.context.aminoCaseField)]));
  },
  "long": function long(args) {
    args.context.addUtil('Long');
    return t.objectProperty(t.identifier(args.field.name), t.callExpression(t.memberExpression(t.identifier('Long'), t.identifier('fromString')), [(0, _utils.memberExpressionOrIdentifierAminoCaseField)(args.fieldPath, args.context.aminoCaseField)]));
  },
  duration: function duration(args) {
    var durationFormat = args.context.pluginValue('prototypes.typingsFormat.duration');
    switch (durationFormat) {
      case 'duration':
      // TODO duration amino type
      case 'string':
      default:
        return fromAmino.durationString(args);
    }
  },
  durationString: function durationString(args) {
    args.context.addUtil('Long');
    var value = t.objectExpression([t.objectProperty(t.identifier('seconds'), t.callExpression(t.memberExpression(t.identifier('Long'), t.identifier('fromNumber')), [t.callExpression(t.memberExpression(t.identifier('Math'), t.identifier('floor')), [t.binaryExpression('/', t.callExpression(t.identifier('parseInt'), [(0, _utils.memberExpressionOrIdentifierAminoCaseField)(args.fieldPath, args.context.aminoCaseField)]), _utils.BILLION)])])), t.objectProperty(t.identifier('nanos'), t.binaryExpression('%', t.callExpression(t.identifier('parseInt'), [(0, _utils.memberExpressionOrIdentifierAminoCaseField)(args.fieldPath, args.context.aminoCaseField)]), _utils.BILLION))]);
    return t.objectProperty(t.identifier(args.field.name), value);
  },
  height: function height(args) {
    args.context.addUtil('Long');
    return t.objectProperty(t.identifier(args.field.name), t.conditionalExpression((0, _utils.memberExpressionOrIdentifierAminoCaseField)(args.fieldPath, args.context.aminoCaseField), t.objectExpression([t.objectProperty(t.identifier('revisionHeight'), t.callExpression(t.memberExpression(t.identifier('Long'), t.identifier('fromString')), [t.logicalExpression('||', t.memberExpression((0, _utils.memberExpressionOrIdentifierAminoCaseField)(args.fieldPath, args.context.aminoCaseField), t.identifier(args.context.aminoCasingFn('revision_height'))), t.stringLiteral('0')), t.booleanLiteral(true)])),
    //
    t.objectProperty(t.identifier('revisionNumber'), t.callExpression(t.memberExpression(t.identifier('Long'), t.identifier('fromString')), [t.logicalExpression('||', t.memberExpression((0, _utils.memberExpressionOrIdentifierAminoCaseField)(args.fieldPath, args.context.aminoCaseField), t.identifier(args.context.aminoCasingFn('revision_number'))), t.stringLiteral('0')), t.booleanLiteral(true)]))]), t.identifier('undefined')));
  },
  "enum": function _enum(_ref) {
    var context = _ref.context,
      field = _ref.field,
      currentProtoPath = _ref.currentProtoPath,
      scope = _ref.scope,
      fieldPath = _ref.fieldPath,
      nested = _ref.nested,
      isOptional = _ref.isOptional;
    var enumFunction = context.lookupEnumFromJson(field, currentProtoPath);
    var value = t.callExpression(t.identifier(enumFunction), [(0, _utils.memberExpressionOrIdentifierAminoCaseField)(fieldPath, context.aminoCaseField)]);
    return t.objectProperty(t.identifier(field.name), value);
  },
  enumArray: function enumArray(_ref2) {
    var context = _ref2.context,
      field = _ref2.field,
      currentProtoPath = _ref2.currentProtoPath,
      scope = _ref2.scope,
      fieldPath = _ref2.fieldPath,
      nested = _ref2.nested,
      isOptional = _ref2.isOptional;
    var enumFunction = context.lookupEnumFromJson(field, currentProtoPath);
    var value = t.callExpression(t.memberExpression((0, _utils.memberExpressionOrIdentifierAminoCaseField)(fieldPath, context.aminoCaseField), t.identifier('map')), [t.arrowFunctionExpression([t.identifier('el')], t.callExpression(t.identifier(enumFunction), [t.identifier('el')]))]);
    return t.objectProperty(t.identifier(field.name), value);
  },
  type: function type(_ref3) {
    var context = _ref3.context,
      field = _ref3.field,
      currentProtoPath = _ref3.currentProtoPath,
      scope = _ref3.scope,
      fieldPath = _ref3.fieldPath,
      nested = _ref3.nested,
      isOptional = _ref3.isOptional;
    var parentField = field;
    var Type = context.getTypeFromCurrentPath(field, currentProtoPath);
    var oneOfs = (0, _proto.getOneOfs)(Type);
    var properties = (0, _utils2.protoFieldsToArray)(Type).map(function (field) {
      var isOneOf = oneOfs.includes(field.name);
      var isOptional = (0, _proto.getFieldOptionality)(context, field, isOneOf);
      if (parentField["import"]) currentProtoPath = parentField["import"];
      return (0, _index.fromAminoParseField)({
        context: context,
        field: field,
        currentProtoPath: currentProtoPath,
        scope: (0, _toConsumableArray2["default"])(scope),
        fieldPath: (0, _toConsumableArray2["default"])(fieldPath),
        nested: nested + 1,
        isOptional: isOptional // TODO how to handle nested optionality?
      });
    });

    return t.objectProperty(t.identifier(field.name), t.objectExpression(properties));
  },
  arrayFrom: function arrayFrom(args) {
    return t.objectProperty(t.identifier(args.field.name), t.callExpression(t.memberExpression(t.identifier('Array'), t.identifier('from')), [(0, _utils.memberExpressionOrIdentifierAminoCaseField)(args.fieldPath, args.context.aminoCaseField)]));
  },
  typeArray: function typeArray(_ref4) {
    var context = _ref4.context,
      field = _ref4.field,
      currentProtoPath = _ref4.currentProtoPath,
      scope = _ref4.scope,
      fieldPath = _ref4.fieldPath,
      nested = _ref4.nested,
      isOptional = _ref4.isOptional;
    //////
    var variable = 'el' + nested;
    var f = JSON.parse(JSON.stringify(field)); // clone
    var varProto = _objectSpread({}, f);
    varProto.name = variable;
    varProto.options['(telescope:orig)'] = variable;
    varProto.options['(telescope:name)'] = variable;
    varProto.options['(telescope:camel)'] = variable;
    //////

    var parentField = field;
    var Type = context.getTypeFromCurrentPath(field, currentProtoPath);
    var oneOfs = (0, _proto.getOneOfs)(Type);
    var properties = (0, _utils2.protoFieldsToArray)(Type).map(function (field) {
      var isOneOf = oneOfs.includes(field.name);
      var isOptional = (0, _proto.getFieldOptionality)(context, field, isOneOf);
      if (parentField["import"]) currentProtoPath = parentField["import"];
      return (0, _index.fromAminoParseField)({
        context: context,
        field: field,
        currentProtoPath: currentProtoPath,
        scope: [variable],
        fieldPath: [varProto],
        nested: nested + 1,
        isOptional: isOptional // TODO how to handle nested optionality?
      });
    });

    var expr = t.callExpression(t.memberExpression((0, _utils.memberExpressionOrIdentifierAminoCaseField)(fieldPath, context.aminoCaseField), t.identifier('map')), [t.arrowFunctionExpression([t.identifier(variable)], t.objectExpression(properties))]);
    return t.objectProperty(t.identifier(field.name), expr);
  },
  scalarArray: function scalarArray(_ref5, arrayTypeAstFunc) {
    var context = _ref5.context,
      field = _ref5.field,
      currentProtoPath = _ref5.currentProtoPath,
      scope = _ref5.scope,
      fieldPath = _ref5.fieldPath,
      nested = _ref5.nested,
      isOptional = _ref5.isOptional;
    var variable = 'el' + nested;
    var expr = t.callExpression(t.memberExpression((0, _utils.memberExpressionOrIdentifierAminoCaseField)(fieldPath, context.aminoCaseField), t.identifier('map')), [t.arrowFunctionExpression([t.identifier(variable)], arrayTypeAstFunc(variable))]);
    return t.objectProperty(t.identifier(field.name), expr);
  },
  pubkey: function pubkey(args) {
    args.context.addUtil('toBase64');
    args.context.addUtil('encodeBech32Pubkey');
    return t.objectProperty(t.identifier(args.field.name), t.callExpression(t.identifier('encodeBech32Pubkey'), [t.objectExpression([t.objectProperty(t.identifier('type'), t.stringLiteral('tendermint/PubKeySecp256k1')), t.objectProperty(t.identifier('value'), t.callExpression(t.identifier('toBase64'), [t.memberExpression(t.identifier('pubkey'), t.identifier('value'))]))]),
    // TODO how to manage this?
    // 1. options.prefix
    // 2. look into prefix and how it's used across chains
    // 3. maybe AminoConverter is a class and has this.prefix!
    t.stringLiteral('cosmos')]));
  }
};
exports.fromAmino = fromAmino;
var arrayTypes = {
  "long": function long(varname) {
    return t.callExpression(t.memberExpression(t.identifier('Long'), t.identifier('fromString')), [t.identifier(varname)]);
  }
};
exports.arrayTypes = arrayTypes;