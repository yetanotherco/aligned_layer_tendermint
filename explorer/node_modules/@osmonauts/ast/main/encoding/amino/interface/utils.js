"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.aminoInterface = void 0;
var t = _interopRequireWildcard(require("@babel/types"));
var _utils = require("../utils");
var _types2 = require("../../types");
var _proto = require("../../proto");
var _ = require(".");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var aminoInterface = {
  defaultType: function defaultType(args) {
    return t.tsPropertySignature(t.identifier(args.context.aminoCaseField(args.field)), t.tsTypeAnnotation((0, _types2.getTSTypeForAmino)(args.context, args.field)));
  },
  string: function string(args) {
    return t.tsPropertySignature(t.identifier(args.context.aminoCaseField(args.field)), t.tsTypeAnnotation(t.tsStringKeyword()));
  },
  "long": function long(args) {
    // longs become strings...
    return t.tsPropertySignature(t.identifier(args.context.aminoCaseField(args.field)), t.tsTypeAnnotation(t.tSStringKeyword()));
  },
  height: function height(args) {
    args.context.addUtil('AminoHeight');
    return t.tsPropertySignature(t.identifier(args.context.aminoCaseField(args.field)), t.tsTypeAnnotation(t.tsTypeReference(t.identifier('AminoHeight'))));
  },
  duration: function duration(args) {
    var durationFormat = args.context.pluginValue('prototypes.typingsFormat.duration');
    switch (durationFormat) {
      case 'string':
        return t.tsPropertySignature(t.identifier(args.context.aminoCaseField(args.field)), t.tsTypeAnnotation(t.tsStringKeyword()));
      case 'duration':
      default:
        return aminoInterface.type(args);
    }
  },
  timestamp: function timestamp(args) {
    var timestampFormat = args.context.pluginValue('prototypes.typingsFormat.timestamp');
    switch (timestampFormat) {
      case 'date':
      // TODO check is date is Date for amino?
      // return t.tsPropertySignature(
      //     t.identifier(args.context.aminoCaseField(args.field)),
      //     t.tsTypeAnnotation(
      //         t.tsTypeReference(t.identifier('Date'))
      //     )
      // );
      case 'timestamp':
      default:
        return aminoInterface.type(args);
    }
  },
  "enum": function _enum(args) {
    return t.tsPropertySignature(t.identifier(args.context.aminoCaseField(args.field)), t.tsTypeAnnotation(t.tSNumberKeyword()));
  },
  enumArray: function enumArray(args) {
    return t.tsPropertySignature(t.identifier(args.context.aminoCaseField(args.field)), t.tsTypeAnnotation((0, _utils.arrayTypeNDim)(t.tSNumberKeyword(), 1)));
  },
  type: function type(_ref) {
    var context = _ref.context,
      field = _ref.field,
      currentProtoPath = _ref.currentProtoPath,
      isOptional = _ref.isOptional;
    var parentField = field;
    var Type = context.getTypeFromCurrentPath(field, currentProtoPath);
    var oneOfs = (0, _proto.getOneOfs)(Type);
    var properties = (0, _utils.protoFieldsToArray)(Type).map(function (field) {
      var isOneOf = oneOfs.includes(field.name);
      var isOptional = (0, _proto.getFieldOptionality)(context, field, isOneOf);
      // TODO how to handle isOptional from parent to child...
      if (parentField["import"]) currentProtoPath = parentField["import"];
      return (0, _.renderAminoField)({
        context: context,
        field: field,
        currentProtoPath: currentProtoPath,
        isOptional: isOptional // TODO how to handle nested optionality
      });
    });

    // 
    return t.tsPropertySignature(t.identifier(context.aminoCaseField(field)), t.tsTypeAnnotation(t.tsTypeLiteral(properties)));
  },
  typeArray: function typeArray(_ref2) {
    var context = _ref2.context,
      field = _ref2.field,
      currentProtoPath = _ref2.currentProtoPath,
      isOptional = _ref2.isOptional;
    var parentField = field;
    var Type = context.getTypeFromCurrentPath(field, currentProtoPath);

    // TODO how to handle isOptional from parent to child... 
    var oneOfs = (0, _proto.getOneOfs)(Type);
    var properties = (0, _utils.protoFieldsToArray)(Type).map(function (field) {
      var isOneOf = oneOfs.includes(field.name);
      var isOptional = (0, _proto.getFieldOptionality)(context, field, isOneOf);
      if (parentField["import"]) currentProtoPath = parentField["import"];
      return (0, _.renderAminoField)({
        context: context,
        field: field,
        currentProtoPath: currentProtoPath,
        isOptional: isOptional // TODO how to handle nested optionality
      });
    });

    // 
    return t.tsPropertySignature(t.identifier(context.aminoCaseField(field)), t.tsTypeAnnotation((0, _utils.arrayTypeNDim)(t.tsTypeLiteral(properties), 1)));
  },
  array: function array(args) {
    // TODO write test case 

    // return t.tsPropertySignature(
    //     t.identifier(options.aminoCasingFn(field.name)),
    //     t.tsTypeAnnotation(
    //         arrayTypeNDim(t.tsTypeLiteral(
    //             properties
    //         ), 1)
    //     )
    // );
    return t.tsPropertySignature(t.identifier(args.context.aminoCaseField(args.field)), t.tsTypeAnnotation((0, _utils.arrayTypeNDim)((0, _types2.getTSTypeForAmino)(args.context, args.field), 1)));
  }
};
exports.aminoInterface = aminoInterface;