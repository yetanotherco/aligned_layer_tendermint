"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTSTypeFromGoogleType = exports.getTSTypeForProto = exports.getTSTypeForAmino = exports.getTSType = exports.getTSAminoType = exports.getFieldTypeReference = exports.getFieldNames = exports.getFieldAminoTypeReference = exports.getDefaultTSTypeFromProtoType = exports.SymbolNames = void 0;
var t = _interopRequireWildcard(require("@babel/types"));
var _types2 = require("@osmonauts/types");
var _utils = require("../utils");
var _proto = require("./proto");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var getFieldNames = function getFieldNames(field) {
  var _field$options$Teles, _field$options, _field$options$Teles2, _field$options2;
  var propName = (_field$options$Teles = (_field$options = field.options) === null || _field$options === void 0 ? void 0 : _field$options['(telescope:name)']) !== null && _field$options$Teles !== void 0 ? _field$options$Teles : field.name;
  var origName = (_field$options$Teles2 = (_field$options2 = field.options) === null || _field$options2 === void 0 ? void 0 : _field$options2['(telescope:orig)']) !== null && _field$options$Teles2 !== void 0 ? _field$options$Teles2 : field.name;
  return {
    propName: propName,
    origName: origName
  };
};
exports.getFieldNames = getFieldNames;
var getSymbolName = function getSymbolName(name) {
  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Msg';
  var typeNameSuffix;
  switch (type) {
    case 'ProtoMsg':
      typeNameSuffix = 'ProtoMsg';
      break;
    case 'AminoMsg':
      typeNameSuffix = 'AminoMsg';
      break;
    case 'Amino':
      typeNameSuffix = 'Amino';
      break;
    case 'SDKType':
      typeNameSuffix = 'SDKType';
      break;
    case 'Encoded':
      typeNameSuffix = 'Encoded';
      break;
    case 'Msg':
    default:
  }
  return [name, typeNameSuffix].filter(Boolean).join('');
};
var SymbolNames = {
  Msg: function Msg(name) {
    return getSymbolName(name, 'Msg');
  },
  SDKType: function SDKType(name) {
    return getSymbolName(name, 'SDKType');
  },
  ProtoMsg: function ProtoMsg(name) {
    return getSymbolName(name, 'ProtoMsg');
  },
  AminoMsg: function AminoMsg(name) {
    return getSymbolName(name, 'AminoMsg');
  },
  Amino: function Amino(name) {
    return getSymbolName(name, 'Amino');
  },
  Encoded: function Encoded(name) {
    return getSymbolName(name, 'Encoded');
  }
};
exports.SymbolNames = SymbolNames;
var getFieldTypeReference = function getFieldTypeReference(context, field) {
  var _field$options3, _field$parsedType2, _field$parsedType3, _field$parsedType4;
  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'Msg';
  var ast = null;
  var typ = null;
  if (_proto.SCALAR_TYPES.includes(field.type)) {
    // return on scalar
    typ = getTSTypeForProto(context, field);
    return {
      ast: typ
    };
  } else if (_proto.GOOGLE_TYPES.includes(field.type)) {
    typ = getTSTypeFromGoogleType(context, field.type, type);
  } else {
    var _field$parsedType;
    var propName = (0, _utils.getProtoFieldTypeName)(context, field);
    var MsgName = ((_field$parsedType = field.parsedType) === null || _field$parsedType === void 0 ? void 0 : _field$parsedType.type) === 'Enum' ? propName : SymbolNames[type](propName);
    typ = t.tsTypeReference(t.identifier(MsgName));
  }
  var implementsAcceptsAny = context.pluginValue('interfaces.enabled');
  var lookupInterface = (_field$options3 = field.options) === null || _field$options3 === void 0 ? void 0 : _field$options3['(cosmos_proto.accepts_interface)'];
  var isAnyType = ((_field$parsedType2 = field.parsedType) === null || _field$parsedType2 === void 0 ? void 0 : _field$parsedType2.type) === 'Type' && ((_field$parsedType3 = field.parsedType) === null || _field$parsedType3 === void 0 ? void 0 : _field$parsedType3.name) === 'Any';
  var isArray = field.rule === 'repeated';
  var isBaseType = type === 'Msg';
  var isEncodedType = type === 'ProtoMsg';
  var isSDKType = type === 'SDKType';

  // MARKED AS NOT DRY (symbols)
  var symbols = null;
  if (implementsAcceptsAny && lookupInterface) {
    symbols = context.store._symbols.filter(function (s) {
      return s.implementsType === lookupInterface && s.ref === context.ref.filename;
    });
    if (!symbols.length && context.options.logLevel >= _types2.TelescopeLogLevel.Warn) {
      console.warn("[WARN] ".concat(lookupInterface, " is accepted but not implemented"));
    }
  }
  if (!isBaseType) {
    if (['ProtoMsg', 'SDKType'].includes(type)) {
      var _symbols;
      (_symbols = symbols) === null || _symbols === void 0 ? void 0 : _symbols.forEach(function (s) {
        context.addImportDerivative({
          type: type,
          symbol: s
        });
      });
    }
    // main type could be Any

    if (['SDKType'].includes(type) &&
    // no derivatives for Enums!
    field.parsedType.type === 'Type') {
      context.addImportDerivative({
        type: type,
        symbol: {
          ref: context.ref.filename,
          readAs: field.parsedType.name,
          // maybe not!
          source: field["import"],
          symbolName: field.parsedType.name,
          type: 'import'
        }
      });
    }
  }

  // cast Any types!
  var isAnyInterface = isAnyType && lookupInterface && implementsAcceptsAny && symbols;
  var isTypeCastable = isAnyInterface && isBaseType;
  var isProtoTypeCastable = isAnyInterface && isEncodedType;
  var isSDKTypeCastable = isAnyInterface && isSDKType;
  var isNonArrayNullableType = ((_field$parsedType4 = field.parsedType) === null || _field$parsedType4 === void 0 ? void 0 : _field$parsedType4.type) === 'Type' && field.rule !== 'repeated' && context.pluginValue('prototypes.allowUndefinedTypes');
  if (isTypeCastable) {
    var tp = symbols.map(function (a) {
      return t.tsTypeReference(t.identifier(a.readAs));
    });
    tp.push(typ);
    if (context.pluginValue('interfaces.useUnionTypes')) {
      if (!isArray) {
        tp.push(t.tsUndefinedKeyword());
      }
      ast = t.tsUnionType(tp);
    } else {
      // intersections
      if (isArray) {
        ast = t.tsIntersectionType(tp);
      } else {
        ast = t.tsUnionType([t.tsIntersectionType(tp), t.tsUndefinedKeyword()]);
      }
    }
  } else if (isProtoTypeCastable) {
    var _tp = symbols.map(function (a) {
      return t.tsTypeReference(t.identifier(SymbolNames.ProtoMsg(a.readAs)));
    });
    symbols.forEach(function (a) {
      context.addImportDerivative({
        type: 'ProtoMsg',
        symbol: a
      });
    });
    _tp.push(typ);
    if (!isArray) {
      _tp.push(t.tsUndefinedKeyword());
    }
    ast = t.tsUnionType(_tp);
  } else if (isSDKTypeCastable) {
    var _tp2 = symbols.map(function (a) {
      return t.tsTypeReference(t.identifier(SymbolNames.SDKType(a.readAs)));
    });
    symbols.forEach(function (a) {
      context.addImportDerivative({
        type: 'SDKType',
        symbol: a
      });
    });
    _tp2.push(typ);
    if (!isArray) {
      _tp2.push(t.tsUndefinedKeyword());
    }
    ast = t.tsUnionType(_tp2);
  } else if (isNonArrayNullableType) {
    // regular types!
    ast = t.tsUnionType([typ, t.tsUndefinedKeyword()]);
  } else {
    ast = typ;
  }
  return {
    ast: ast,
    isTypeCastableAnyType: isTypeCastable
  };
};
exports.getFieldTypeReference = getFieldTypeReference;
var getFieldAminoTypeReference = function getFieldAminoTypeReference(context, field) {
  var _field$parsedType6, _field$parsedType7;
  var ast = null;
  var typ = null;
  if (_proto.SCALAR_TYPES.includes(field.type)) {
    // return on scalar
    typ = getTSTypeForAmino(context, field);
    return typ;
  } else if (_proto.GOOGLE_TYPES.includes(field.type)) {
    typ = getTSTypeFromGoogleType(context, field.type, 'Amino');
  } else {
    var _field$parsedType5;
    var propName = (0, _utils.getProtoFieldTypeName)(context, field);
    // enums don't need suffixes, etc.
    var MsgName = ((_field$parsedType5 = field.parsedType) === null || _field$parsedType5 === void 0 ? void 0 : _field$parsedType5.type) === 'Enum' ? propName : SymbolNames.Amino(propName);
    typ = t.tsTypeReference(t.identifier(MsgName));
  }
  if (((_field$parsedType6 = field.parsedType) === null || _field$parsedType6 === void 0 ? void 0 : _field$parsedType6.type) === 'Type') {
    context.addImportDerivative({
      type: 'Amino',
      symbol: {
        ref: context.ref.filename,
        readAs: field.parsedType.name,
        // maybe not!
        source: field["import"],
        symbolName: field.parsedType.name,
        type: 'import'
      }
    });
  }
  if (((_field$parsedType7 = field.parsedType) === null || _field$parsedType7 === void 0 ? void 0 : _field$parsedType7.type) === 'Type' && field.rule !== 'repeated' && context.pluginValue('prototypes.allowUndefinedTypes')) {
    // NOTE: unfortunately bc of defaults...
    ast = t.tsUnionType([typ, t.tsUndefinedKeyword()]);
  } else {
    ast = typ;
  }
  return ast;
};
exports.getFieldAminoTypeReference = getFieldAminoTypeReference;
var getTSType = function getTSType(context, type) {
  switch (type) {
    case 'string':
      return t.tsStringKeyword();
    case 'double':
    case 'float':
    case 'int32':
    case 'uint32':
    case 'sint32':
    case 'fixed32':
    case 'sfixed32':
      return t.tsNumberKeyword();
    case 'int64':
    case 'uint64':
    case 'sint64':
    case 'fixed64':
    case 'sfixed64':
      return t.tsTypeReference(t.identifier('Long'));
    case 'bytes':
      return t.tsTypeReference(t.identifier('Uint8Array'));
    case 'bool':
      return t.tsBooleanKeyword();
    default:
      throw new Error('getTSType() type not found');
  }
  ;
};
exports.getTSType = getTSType;
var getTSAminoType = function getTSAminoType(context, type) {
  switch (type) {
    case 'string':
      return t.tsStringKeyword();
    case 'double':
    case 'float':
    case 'int32':
    case 'uint32':
    case 'sint32':
    case 'fixed32':
    case 'sfixed32':
      return t.tsNumberKeyword();
    case 'int64':
    case 'uint64':
    case 'sint64':
    case 'fixed64':
    case 'sfixed64':
      return t.tsStringKeyword();
    case 'bytes':
      return t.tsTypeReference(t.identifier('Uint8Array'));
    case 'bool':
      return t.tsBooleanKeyword();
    default:
      throw new Error('getTSType() type not found');
  }
  ;
};
exports.getTSAminoType = getTSAminoType;
var getTSTypeFromGoogleType = function getTSTypeFromGoogleType(context, type) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'Msg';
  var identifier = function identifier(str) {
    return t.identifier(SymbolNames[options](str));
  };
  switch (type) {
    case 'google.protobuf.Timestamp':
      switch (context.pluginValue('prototypes.typingsFormat.timestamp')) {
        case 'timestamp':
          return t.tsTypeReference(identifier('Timestamp'));
        case 'date':
        default:
          return t.tsTypeReference(t.identifier('Date'));
      }
    case 'google.protobuf.Duration':
      switch (context.pluginValue('prototypes.typingsFormat.duration')) {
        case 'duration':
          return t.tsTypeReference(identifier('Duration'));
        case 'string':
        default:
          return t.tsStringKeyword();
      }
    case 'google.protobuf.Any':
      return t.tsTypeReference(identifier('Any'));
    default:
      throw new Error('getTSTypeFromGoogleType() type not found');
  }
  ;
};
exports.getTSTypeFromGoogleType = getTSTypeFromGoogleType;
var getTSTypeForAmino = function getTSTypeForAmino(context, field) {
  var _field$options4;
  switch (field.type) {
    case 'bytes':
      // bytes [WASMByteCode]
      if (((_field$options4 = field.options) === null || _field$options4 === void 0 ? void 0 : _field$options4['(gogoproto.customname)']) === 'WASMByteCode') {
        return t.tsStringKeyword();
      }
      return t.tsTypeReference(t.identifier('Uint8Array'));
    default:
      return getTSAminoType(context, field.type);
  }
  ;
};
exports.getTSTypeForAmino = getTSTypeForAmino;
var getTSTypeForProto = function getTSTypeForProto(context, field) {
  return getTSType(context, field.type);
};
exports.getTSTypeForProto = getTSTypeForProto;
var getDefaultTSTypeFromProtoType = function getDefaultTSTypeFromProtoType(context, field, isOneOf) {
  var _field$parsedType8;
  var isOptional = (0, _proto.getFieldOptionalityForDefaults)(context, field, isOneOf);
  if (isOptional) {
    return t.identifier('undefined');
  }
  if (field.rule === 'repeated') {
    return t.arrayExpression([]);
  }
  if (field.keyType) {
    return t.objectExpression([]);
  }
  if (((_field$parsedType8 = field.parsedType) === null || _field$parsedType8 === void 0 ? void 0 : _field$parsedType8.type) === 'Enum') {
    var _context$ref$proto;
    // @ts-ignore
    if (((_context$ref$proto = context.ref.proto) === null || _context$ref$proto === void 0 ? void 0 : _context$ref$proto.syntax) === 'proto2') {
      return t.numericLiteral(1);
    }
    return t.numericLiteral(0);
  }
  switch (field.type) {
    case 'string':
      return t.stringLiteral('');
    case 'double':
    case 'float':
    case 'int32':
    case 'uint32':
    case 'sint32':
    case 'fixed32':
    case 'sfixed32':
      return t.numericLiteral(0);
    case 'uint64':
      context.addUtil('Long');
      return t.memberExpression(t.identifier('Long'), t.identifier('UZERO'));
    case 'int64':
    case 'sint64':
    case 'fixed64':
    case 'sfixed64':
      context.addUtil('Long');
      return t.memberExpression(t.identifier('Long'), t.identifier('ZERO'));
    case 'bytes':
      return t.newExpression(t.identifier('Uint8Array'), []);
    case 'bool':
      return t.booleanLiteral(false);

    // OTHER TYPES
    case 'google.protobuf.Timestamp':
      return t.identifier('undefined');
    case 'google.protobuf.Duration':
      return t.identifier('undefined');
    case 'google.protobuf.Any':
      return t.identifier('undefined');
    case 'cosmos.base.v1beta1.Coins':
      return t.arrayExpression([]);
    case 'cosmos.base.v1beta1.Coin':
      return t.identifier('undefined');
    default:
      // console.warn('getDefaultTSTypeFromProtoType() type not found: ' + type);
      return t.identifier('undefined');
  }
  ;
};
exports.getDefaultTSTypeFromProtoType = getDefaultTSTypeFromProtoType;