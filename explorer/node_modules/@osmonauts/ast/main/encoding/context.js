"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ProtoParseContext = exports.GenericParseContext = exports.AminoParseContext = void 0;
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _protoParser = require("@osmonauts/proto-parser");
var _proto = require("./proto");
var _plugins = require("../plugins");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var GenericParseContext = /*#__PURE__*/function () {
  function GenericParseContext(ref, store, options) {
    (0, _classCallCheck2["default"])(this, GenericParseContext);
    (0, _defineProperty2["default"])(this, "options", void 0);
    (0, _defineProperty2["default"])(this, "imports", []);
    (0, _defineProperty2["default"])(this, "derivedImports", []);
    (0, _defineProperty2["default"])(this, "utils", {});
    (0, _defineProperty2["default"])(this, "store", void 0);
    (0, _defineProperty2["default"])(this, "ref", void 0);
    this.ref = ref;
    this.store = store;
    this.options = options;
    if (!this.options) {
      throw new Error('ParseContext requires options!');
    }
  }
  (0, _createClass2["default"])(GenericParseContext, [{
    key: "pluginValue",
    value: function pluginValue(name) {
      return (0, _plugins.getPluginValue)(name, this.ref.proto["package"], this.options);
    }
  }, {
    key: "isExcluded",
    value: function isExcluded() {
      var _this$pluginValue, _this$pluginValue2;
      var packages = (_this$pluginValue = this.pluginValue('prototypes.excluded.packages')) !== null && _this$pluginValue !== void 0 ? _this$pluginValue : [];
      var protos = (_this$pluginValue2 = this.pluginValue('prototypes.excluded.protos')) !== null && _this$pluginValue2 !== void 0 ? _this$pluginValue2 : [];
      return packages.includes(this.ref.proto["package"]) || protos.includes(this.ref.filename);
    }
  }, {
    key: "addUtil",
    value: function addUtil(util) {
      this.utils[util] = true;
    }
  }, {
    key: "addImport",
    value: function addImport(imp) {
      // some local lookups don't have an import (local proto-style lookups do)
      if (!imp["import"]) return;
      this.imports.push(imp);
    }
  }, {
    key: "addImportDerivative",
    value: function addImportDerivative(imp) {
      var found = this.derivedImports.find(function (a) {
        return a.type === imp.type && a.symbol.symbolName === imp.symbol.symbolName && a.symbol.source === imp.symbol.source;
      });
      if (!found) {
        this.derivedImports.push(imp);
      }
    }
  }, {
    key: "getTypeNameFromFieldName",
    value: function getTypeNameFromFieldName(name, importSrc) {
      var _this$ref$traversed;
      var importedAs = name;
      var names = (_this$ref$traversed = this.ref.traversed) === null || _this$ref$traversed === void 0 ? void 0 : _this$ref$traversed.importNames;
      if (names && names.hasOwnProperty(importSrc) && names[importSrc].hasOwnProperty(name)) {
        importedAs = names[importSrc][name];
      }
      this.addImport({
        type: 'typeImport',
        name: name,
        importedAs: importedAs,
        "import": importSrc
      });
      return importedAs;
    }
  }, {
    key: "getTypeName",
    value: function getTypeName(field) {
      var name = (0, _proto.getFieldsTypeName)(field);
      return this.getTypeNameFromFieldName(name, field["import"]);
    }
  }, {
    key: "lookupTypeFromCurrentPath",
    value: function lookupTypeFromCurrentPath(field, currentProtoPath) {
      var ref = this.store.findProto(currentProtoPath);
      var lookup = this.store.get(ref, field.parsedType.name);
      if (!lookup) {
        // if we can't find it, use field import
        if (field["import"]) {
          var importRef = this.store.findProto(field["import"]);
          if (!importRef) {
            throw new Error("bad import ".concat(field["import"]));
          }
          lookup = this.store.get(importRef, field.parsedType.name);
        }
        if (!lookup) {
          throw new Error('Undefined Symbol: ' + field.parsedType.name);
        }
      }
      return lookup;
    }
  }, {
    key: "getTypeFromCurrentPath",
    value: function getTypeFromCurrentPath(field, currentProtoPath) {
      var ref = this.store.findProto(currentProtoPath);
      var lookup = this.store.get(ref, field.parsedType.name);
      if (!lookup) {
        // if we can't find it, use field import
        if (field["import"]) {
          var importRef = this.store.findProto(field["import"]);
          if (!importRef) {
            throw new Error("bad import ".concat(field["import"]));
          }
          lookup = this.store.get(importRef, field.parsedType.name);
        }
        if (!lookup) {
          throw new Error('Undefined Symbol: ' + field.parsedType.name);
        }
      }
      this.addImport({
        type: 'typeImport',
        name: lookup.importedName,
        "import": lookup["import"]
      });
      return lookup.obj;
    }
  }]);
  return GenericParseContext;
}();
exports.GenericParseContext = GenericParseContext;
var AminoParseContext = /*#__PURE__*/function (_GenericParseContext) {
  (0, _inherits2["default"])(AminoParseContext, _GenericParseContext);
  var _super = _createSuper(AminoParseContext);
  function AminoParseContext(ref, store, options) {
    var _this;
    (0, _classCallCheck2["default"])(this, AminoParseContext);
    _this = _super.call(this, ref, store, options);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "aminoCasingFn", void 0);
    _this.ref = ref;
    _this.store = store;
    _this.options = options;
    _this.setAminoCasingFn();
    if (!_this.aminoCasingFn) {
      throw new Error('missing aminoCasingFn!');
    }
    _this.aminoCaseField = _this.aminoCaseField.bind((0, _assertThisInitialized2["default"])(_this));
    return _this;
  }
  (0, _createClass2["default"])(AminoParseContext, [{
    key: "setAminoCasingFn",
    value: function setAminoCasingFn() {
      if (this.aminoCasingFn) return this.aminoCasingFn;
      this.aminoCasingFn = this.pluginValue('aminoEncoding.casingFn');
      return this.aminoCasingFn;
    }
  }, {
    key: "aminoCaseField",
    value: function aminoCaseField(field) {
      return field.options['(telescope:orig)'];
    }
  }, {
    key: "lookupEnumFromJson",
    value: function lookupEnumFromJson(field, currentProtoPath) {
      var lookup = this.lookupTypeFromCurrentPath(field, currentProtoPath);
      var Enum = lookup.obj;
      var name = (0, _proto.getEnumFromJsonName)((0, _protoParser.getObjectName)(Enum.name, Enum.scope));
      this.addImport({
        type: 'fromJSONEnum',
        name: name,
        "import": lookup["import"]
      });
      return name;
    }
  }, {
    key: "lookupEnumToJson",
    value: function lookupEnumToJson(field, currentProtoPath) {
      var lookup = this.lookupTypeFromCurrentPath(field, currentProtoPath);
      var Enum = lookup.obj;
      var name = (0, _proto.getEnumToJsonName)((0, _protoParser.getObjectName)(Enum.name, Enum.scope));
      this.addImport({
        type: 'toJSONEnum',
        name: name,
        "import": lookup["import"]
      });
      return name;
    }
  }]);
  return AminoParseContext;
}(GenericParseContext);
exports.AminoParseContext = AminoParseContext;
var ProtoParseContext = /*#__PURE__*/function (_GenericParseContext2) {
  (0, _inherits2["default"])(ProtoParseContext, _GenericParseContext2);
  var _super2 = _createSuper(ProtoParseContext);
  function ProtoParseContext(ref, store, options) {
    var _this2;
    (0, _classCallCheck2["default"])(this, ProtoParseContext);
    _this2 = _super2.call(this, ref, store, options);
    _this2.ref = ref;
    _this2.store = store;
    _this2.options = options;
    return _this2;
  }
  (0, _createClass2["default"])(ProtoParseContext, [{
    key: "getToEnum",
    value: function getToEnum(field) {
      var name = (0, _proto.getEnumToJsonName)((0, _proto.getFieldsTypeName)(field));
      this.addImport({
        type: 'toJSONEnum',
        name: name,
        "import": field["import"]
      });
      return name;
    }
  }, {
    key: "getFromEnum",
    value: function getFromEnum(field) {
      var fromJSONFuncName = (0, _proto.getEnumFromJsonName)((0, _proto.getFieldsTypeName)(field));
      this.addImport({
        type: 'fromJSONEnum',
        name: fromJSONFuncName,
        "import": field["import"]
      });
      return fromJSONFuncName;
    }
  }]);
  return ProtoParseContext;
}(GenericParseContext);
exports.ProtoParseContext = ProtoParseContext;