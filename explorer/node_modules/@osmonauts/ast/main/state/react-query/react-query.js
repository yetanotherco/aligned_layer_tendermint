"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRpcQueryHooks = exports.createRpcQueryHookInterfaces = exports.createRpcQueryHookClientMap = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var t = _interopRequireWildcard(require("@babel/types"));
var _utils = require("../../utils");
var _utils2 = require("@osmonauts/utils");
var _case = require("case");
var _weakMap = require("./weak-map");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var makeUseHookName = function makeUseHookName(name) {
  return (0, _utils2.camel)('use_' + name);
};
var makeUseHookTypeName = function makeUseHookTypeName(name) {
  return (0, _case.pascal)('Use_' + name + 'Query');
};
var makeHookKeyName = function makeHookKeyName(name) {
  return (0, _utils2.camel)(name + 'Query');
};

/**
 * Create an AST of a specific hook method
 * eg: __fixtures__/output1/akash/audit/v1beta2/query.rpc.Query.ts:
 * const useAllProvidersAttributes = ...
 * @param {Object=} context - context of generating the file
 * @param {string} name - name of the hook
 * @param {Object=} svc - method details
 * @returns {ParseResult} created AST
 */
var rpcHookMethod = function rpcHookMethod(context, name, svc) {
  var _svc$fields;
  var requestType = svc.requestType;
  var responseType = svc.responseType;
  var fieldNames = Object.keys((_svc$fields = svc.fields) !== null && _svc$fields !== void 0 ? _svc$fields : {});
  var hasParams = fieldNames.length > 0;
  var optional = false;
  // // if no params, then let's default to empty object for cleaner API
  if (!hasParams) {
    optional = true;
  } else if (hasParams && fieldNames.length === 1 && fieldNames.includes('pagination')) {
    // if only argument "required" is pagination
    // also default to empty
    optional = true;
  }

  // add import
  context.addUtil('useQuery');
  return t.variableDeclaration('const', [t.variableDeclarator(t.identifier(makeUseHookName(name)), (0, _utils.arrowFunctionExpression)([(0, _utils.objectPattern)([t.objectProperty(t.identifier('request'), t.identifier('request'), false, true), t.objectProperty(t.identifier('options'), t.identifier('options'), false, true)], t.tsTypeAnnotation(t.tsTypeReference(t.identifier(makeUseHookTypeName(name)), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier('TData'))]))))], t.blockStatement([t.returnStatement((0, _utils.callExpression)(t.identifier('useQuery'), [t.arrayExpression([t.stringLiteral(makeHookKeyName(name)), t.identifier('request')]), t.arrowFunctionExpression([], t.blockStatement([t.ifStatement(t.unaryExpression('!', t.identifier('queryService'), true), t.throwStatement(t.newExpression(t.identifier('Error'), [t.stringLiteral('Query Service not initialized')]))), t.returnStatement(t.callExpression(t.memberExpression(t.identifier('queryService'), t.identifier(name)), [t.identifier('request')]))])), t.identifier('options')], t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(responseType)), t.tsTypeReference(t.identifier('Error')), t.tsTypeReference(t.identifier('TData'))])))]), null, false, (0, _utils.tsTypeParameterDeclaration)([t.tsTypeParameter(null, t.tsTypeReference(t.identifier(responseType)), 'TData')])))]);
};

/**
 * Create an AST of a specific query interface of react-query
 * eg: __fixtures__/output1/akash/audit/v1beta2/query.rpc.Query.ts:
 * export interface UseAllProvidersAttributesQuery<TData> extends ReactQueryParams...
 * @param {Object=} context - context of generating the file
 * @param {string} name - name of the hook
 * @param {Object=} svc - method details
 * @returns {ParseResult} created AST
 */
var rpcHookMethodInterface = function rpcHookMethodInterface(context, name, svc) {
  var _svc$fields2;
  var requestType = svc.requestType;
  var responseType = svc.responseType;
  var fieldNames = Object.keys((_svc$fields2 = svc.fields) !== null && _svc$fields2 !== void 0 ? _svc$fields2 : {});
  var hasParams = fieldNames.length > 0;
  var optional = false;
  // // if no params, then let's default to empty object for cleaner API
  if (!hasParams) {
    optional = true;
  } else if (hasParams && fieldNames.length === 1 && fieldNames.includes('pagination')) {
    // if only argument "required" is pagination
    // also default to empty
    optional = true;
  }

  // import ReactQueryParams in the generated file.
  context.addUtil('ReactQueryParams');
  return t.exportNamedDeclaration(t.tsInterfaceDeclaration(t.identifier(makeUseHookTypeName(name)), t.tsTypeParameterDeclaration([t.tsTypeParameter(null, null, 'TData')]), [t.tsExpressionWithTypeArguments(t.identifier('ReactQueryParams'), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(responseType)), t.tsTypeReference(t.identifier('TData'))]))], t.tsInterfaceBody([(0, _utils.tsPropertySignature)(t.identifier('request'), t.tsTypeAnnotation(t.tsTypeReference(t.identifier(requestType))), optional)])));
};

/**
 * Create an ASTs for a function creating hooks
 * eg: __fixtures__/output1/akash/audit/v1beta2/query.rpc.Query.ts
 * export const createRpcQueryHooks = ...
 * @param {Object=} context - context of generating the file
 * @param {Object=} service - service details
 * @returns {ParseResult} created AST
 */
var createRpcQueryHooks = function createRpcQueryHooks(context, service) {
  var _service$methods, _service$methods2;
  // add imports
  context.addUtil('QueryClient');
  context.addUtil('createProtobufRpcClient');
  context.addUtil('ProtobufRpcClient');
  var camelRpcMethods = context.pluginValue('rpcClients.camelCase');
  var methods = Object.keys((_service$methods = service.methods) !== null && _service$methods !== void 0 ? _service$methods : {}).map(function (key) {
    var method = service.methods[key];
    var name = camelRpcMethods ? (0, _utils2.camel)(key) : key;
    return rpcHookMethod(context, name, method);
  });
  var methodNames = Object.keys((_service$methods2 = service.methods) !== null && _service$methods2 !== void 0 ? _service$methods2 : {}).map(function (key) {
    var name = camelRpcMethods ? (0, _utils2.camel)(key) : key;
    return {
      name: name,
      comment: service.methods[key].comment
    };
  });
  return t.exportNamedDeclaration(t.variableDeclaration('const', [t.variableDeclarator(t.identifier('createRpcQueryHooks'), t.arrowFunctionExpression([(0, _utils.identifier)('rpc', t.tsTypeAnnotation(t.tsUnionType([t.tsTypeReference(t.identifier('ProtobufRpcClient')), t.tsUndefinedKeyword()])))],
  // body
  t.blockStatement([
  // query service
  t.variableDeclaration('const', [t.variableDeclarator(t.identifier('queryService'), t.callExpression(t.identifier('getQueryService'), [t.identifier('rpc')]))])].concat((0, _toConsumableArray2["default"])(methods), [
  // return the methods...
  t.returnStatement(t.objectExpression(methodNames.map(function (_ref) {
    var name = _ref.name,
      comment = _ref.comment;
    return (0, _utils.objectProperty)(t.identifier(makeUseHookName(name)), t.identifier(makeUseHookName(name)), false, true, null, (0, _utils.makeCommentLineWithBlocks)(comment));
  })))]))
  // end body
  ))]));
};

/**
 * Create ASTs for all the methods of a proto service.
 * @param {Object=} context - context of generating the file
 * @param {Object=} service - service details
 * @returns {ParseResult} created AST
 */
exports.createRpcQueryHooks = createRpcQueryHooks;
var createRpcQueryHookInterfaces = function createRpcQueryHookInterfaces(context, service) {
  var _service$methods3;
  var camelRpcMethods = context.pluginValue('rpcClients.camelCase');
  var methods = Object.keys((_service$methods3 = service.methods) !== null && _service$methods3 !== void 0 ? _service$methods3 : {}).map(function (key) {
    var name = camelRpcMethods ? (0, _utils2.camel)(key) : key;
    var method = service.methods[key];
    return {
      name: name,
      method: method
    };
  });
  return methods.map(function (method) {
    return rpcHookMethodInterface(context, method.name, method.method);
  });
};

/**
 * Create an ASTs for a map of query clients and a function of getting query service.
 * eg: __fixtures__/output1/akash/audit/v1beta2/query.rpc.Query.ts
 * const _queryClients: WeakMap...
 *
 * const getQueryService = (...
 * @param {Object=} context - context of generating the file
 * @param {Object=} service - service details
 * @returns {ParseResult} created AST
 */
exports.createRpcQueryHookInterfaces = createRpcQueryHookInterfaces;
var createRpcQueryHookClientMap = function createRpcQueryHookClientMap(context, service) {
  var name = service.name + 'ClientImpl';

  // get ast based on a template.
  return (0, _weakMap.createClientMap)(name);
};
exports.createRpcQueryHookClientMap = createRpcQueryHookClientMap;