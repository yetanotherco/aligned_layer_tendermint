"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMobxQueryStores = exports.buildRpcStores = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var t = _interopRequireWildcard(require("@babel/types"));
var _utils = require("../../utils");
var _protoParser = require("@osmonauts/proto-parser");
var _utils2 = require("@osmonauts/utils");
var _case = require("case");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var makeQueryStoreName = function makeQueryStoreName(name) {
  return "Query".concat((0, _case.pascal)(name), "Store");
};

/**
 * Entry for building stores.
 * @param {Object=} context - context of generating the file
 * @param {Object=} service - method details
 */
var createMobxQueryStores = function createMobxQueryStores(context, service) {
  var isIncluded = context.pluginValue('mobx.enabled') && (0, _protoParser.isRefIncluded)(context.ref, context.pluginValue('mobx.include'));
  if (isIncluded) {
    // before this, make sure:
    // 1. refactor adding getQueryService part into helpers.
    // 2. add new query store class to helpers.
    // build whole ast, don't forget to add utils.
    return buildRpcStores(context, service);
  }
  return null;
};

/**
 * Create an AST to generate creating store functions.
 * eg:
 * export const createRpcStores = (rpc: ProtobufRpcClient | undefined) => {
 *   const queryService = getQueryService(rpc);
 *
 *   class BalanceStoreInherited extends QueryStore<
 *     QueryBalanceRequest,
 *     QueryBalanceResponse
 *   > {
 *     constructor() {
 *       super(queryService?.balance);
 *       makeObservable(this, {
 *         state: override,
 *         request: override,
 *         response: override,
 *         isLoading: override,
 *         isSuccess: override,
 *         refetch: override,
 *         getData: override
 *       });
 *     }
 *
 *     balance(request: QueryBalanceRequest): MobxResponse<QueryBalanceResponse> {
 *       return this.getData(request);
 *     }
 *   }
 *
 *   return {
 *     BalanceStoreInherited
 *   };
 * };
 * @param {Object=} context - context of generating the file
 * @param {Object=} service - method details
 * @returns {ParseResult} created AST
 */
exports.createMobxQueryStores = createMobxQueryStores;
var buildRpcStores = function buildRpcStores(context, service) {
  var _service$methods;
  // add imports
  context.addUtil('ProtobufRpcClient');

  //TODO: add util for getQueryService

  var isCamelRpcMethods = context.pluginValue('rpcClients.camelCase');
  var storeNames = [];
  var stores = Object.keys((_service$methods = service.methods) !== null && _service$methods !== void 0 ? _service$methods : {}).map(function (key) {
    var method = service.methods[key];
    var name = isCamelRpcMethods ? (0, _utils2.camel)(key) : key;
    storeNames.push({
      name: name,
      comment: method.comment
    });
    return buildStore(context, name, method);
  });
  return t.exportNamedDeclaration(t.variableDeclaration('const', [t.variableDeclarator(t.identifier('createRpcQueryStores'), t.arrowFunctionExpression([(0, _utils.identifier)('rpc', t.tsTypeAnnotation(t.tsUnionType([t.tsTypeReference(t.identifier('ProtobufRpcClient')), t.tsUndefinedKeyword()])))],
  // body
  t.blockStatement([
  // query service
  t.variableDeclaration('const', [t.variableDeclarator(t.identifier('queryService'), t.callExpression(t.identifier('getQueryService'), [t.identifier('rpc')]))])].concat((0, _toConsumableArray2["default"])(stores), [
  // return the methods...
  t.returnStatement(t.objectExpression(storeNames.map(function (_ref) {
    var name = _ref.name,
      comment = _ref.comment;
    var id = t.identifier(makeQueryStoreName(name));
    return (0, _utils.objectProperty)(id, id, false, true, null, (0, _utils.makeCommentLineWithBlocks)(comment));
  })))]))
  // end body
  ))]));
};

/**
 * Create an AST of inherited store.
 * eg:
 *   class BalanceStore extends QueryStore<
 *     QueryBalanceRequest,
 *     QueryBalanceResponse
 *   > {
 *     constructor() {
 *       super(queryService?.balance);
 *       makeObservable(this, {
 *         state: override,
 *         request: override,
 *         response: override,
 *         isLoading: override,
 *         isSuccess: override,
 *         refetch: override,
 *         getData: override
 *       });
 *     }
 *
 *     balance(request: QueryBalanceRequest): MobxResponse<QueryBalanceResponse> {
 *       return this.getData(request);
 *     }
 *   }
 * @param {Object=} context - context of generating the file
 * @param {string} name - name of the store
 * @param {Object=} serviceMethod - method details
 * @returns {ParseResult} created AST
 */
exports.buildRpcStores = buildRpcStores;
var buildStore = function buildStore(context, name, serviceMethod) {
  var _serviceMethod$fields;
  //add util for QueryStore
  context.addUtil('QueryStore');

  //add util for MobxResponse
  context.addUtil('MobxResponse');

  //add util for makeObservable
  context.addUtil('makeObservable');

  //add util for override
  context.addUtil('override');
  var requestType = serviceMethod.requestType;
  var responseType = serviceMethod.responseType;
  var fieldNames = Object.keys((_serviceMethod$fields = serviceMethod.fields) !== null && _serviceMethod$fields !== void 0 ? _serviceMethod$fields : {});
  var hasParams = fieldNames.length > 0;
  var isOptional = false;
  // // if no params, then let's default to empty object for cleaner API
  if (!hasParams) {
    isOptional = true;
  } else if (hasParams && fieldNames.length === 1 && fieldNames.includes('pagination')) {
    // if only argument "required" is pagination
    // also default to empty
    isOptional = true;
  }
  var storeClassName = makeQueryStoreName(name);
  var storeQueryClass = (0, _utils.classDeclaration)(t.identifier(storeClassName), t.identifier('QueryStore'), t.classBody([t.classMethod('constructor', t.identifier('constructor'), [], t.blockStatement([t.expressionStatement(t.callExpression(t["super"](), [t.optionalMemberExpression(t.identifier('queryService'), t.identifier(name), false, true)])), t.expressionStatement(t.callExpression(t.identifier('makeObservable'), [t.thisExpression(), t.objectExpression([t.objectProperty(t.identifier('state'), t.identifier('override')), t.objectProperty(t.identifier('request'), t.identifier('override')), t.objectProperty(t.identifier('response'), t.identifier('override')), t.objectProperty(t.identifier('isLoading'), t.identifier('override')), t.objectProperty(t.identifier('isSuccess'), t.identifier('override')), t.objectProperty(t.identifier('refetch'), t.identifier('override')), t.objectProperty(t.identifier('getData'), t.identifier('override'))])]))])), (0, _utils.classMethod)('method', t.identifier(name), [(0, _utils.identifier)('request', t.tsTypeAnnotation(t.tsTypeReference(t.identifier(requestType))), isOptional)], t.blockStatement([t.returnStatement(t.callExpression(t.memberExpression(t.thisExpression(), t.identifier('getData')), [t.identifier('request')]))]), t.tsTypeAnnotation(t.tsTypeReference(t.identifier('MobxResponse'), t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(responseType))]))))]), [],
  // TODO the lines below have no impact (see classDeclaration)
  null, t.tsTypeParameterInstantiation([t.tsTypeReference(t.identifier(requestType)), t.tsTypeReference(t.identifier(responseType))]));
  return storeQueryClass;
};