"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.classMethod = exports.classDeclaration = exports.callExpression = exports.arrowFunctionExpression = void 0;
exports.classProperty = classProperty;
exports.tsEnumMember = exports.objectProperty = exports.objectPattern = exports.objectMethod = exports.makeCommentLineWithBlocks = exports.identifier = exports.functionDeclaration = exports.commentLine = exports.commentBlock = void 0;
exports.tsMethodSignature = tsMethodSignature;
exports.tsTypeParameterDeclaration = exports.tsPropertySignature = void 0;
var t = _interopRequireWildcard(require("@babel/types"));
var _utils = require("./utils");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
// TODO move to @osmonauts/utils package

var commentBlock = function commentBlock(value) {
  return {
    type: 'CommentBlock',
    value: value,
    start: null,
    end: null,
    loc: null
  };
};
exports.commentBlock = commentBlock;
var commentLine = function commentLine(value) {
  return {
    type: 'CommentLine',
    value: value,
    start: null,
    end: null,
    loc: null
  };
};
exports.commentLine = commentLine;
function tsMethodSignature(key) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var parameters = arguments.length > 2 ? arguments[2] : undefined;
  var typeAnnotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var trailingComments = arguments.length > 4 ? arguments[4] : undefined;
  var leadingComments = arguments.length > 5 ? arguments[5] : undefined;
  var obj = t.tsMethodSignature(key, typeParameters, parameters, typeAnnotation);
  obj.kind = 'method';
  if (trailingComments && trailingComments.length) {
    obj.trailingComments = trailingComments;
  }
  if (leadingComments && leadingComments.length) {
    obj.leadingComments = leadingComments;
  }
  return obj;
}
var classMethod = function classMethod(kind, key, params, body, returnType) {
  var leadingComments = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];
  var computed = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
  var _static = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
  var generator = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
  var async = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;
  var obj = t.classMethod(kind, key, params, body, computed, _static, generator, async);
  if (returnType) {
    obj.returnType = returnType;
  }
  if (leadingComments) {
    obj.leadingComments = leadingComments;
  }
  return obj;
};
exports.classMethod = classMethod;
var tsEnumMember = function tsEnumMember(id, initializer, leadingComments) {
  var obj = t.tsEnumMember(id, initializer);
  obj.leadingComments = leadingComments;
  return obj;
};
exports.tsEnumMember = tsEnumMember;
var tsPropertySignature = function tsPropertySignature(key, typeAnnotation, optional) {
  var obj = t.tsPropertySignature(key, typeAnnotation);
  obj.optional = optional;
  return obj;
};
exports.tsPropertySignature = tsPropertySignature;
var functionDeclaration = function functionDeclaration(id, params, body, generator, async, returnType) {
  var func = t.functionDeclaration(id, params, body, generator, async);
  func.returnType = returnType;
  return func;
};
exports.functionDeclaration = functionDeclaration;
var callExpression = function callExpression(callee, _arguments, typeParameters) {
  var callExpr = t.callExpression(callee, _arguments);
  callExpr.typeParameters = typeParameters;
  return callExpr;
};
exports.callExpression = callExpression;
var identifier = function identifier(name, typeAnnotation) {
  var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var type = t.identifier(name);
  type.typeAnnotation = typeAnnotation;
  type.optional = optional;
  return type;
};
exports.identifier = identifier;
var classDeclaration = function classDeclaration(id) {
  var superClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var body = arguments.length > 2 ? arguments[2] : undefined;
  var decorators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var vImplements = arguments.length > 4 ? arguments[4] : undefined;
  var superTypeParameters = arguments.length > 5 ? arguments[5] : undefined;
  var obj = t.classDeclaration(id, superClass, body, decorators);
  if (superTypeParameters) {
    obj.superTypeParameters = superTypeParameters;
  }
  if (vImplements) {
    obj["implements"] = vImplements;
  }
  return obj;
};
exports.classDeclaration = classDeclaration;
function classProperty(key) {
  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var decorators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var computed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var _static = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  var _readonly = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
  var accessibility = arguments.length > 7 ? arguments[7] : undefined;
  var leadingComments = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : [];
  var obj = t.classProperty(key, value, typeAnnotation, decorators, computed, _static);
  if (accessibility) obj.accessibility = accessibility;
  if (_readonly) obj.readonly = _readonly;
  if (leadingComments.length) obj.leadingComments = leadingComments;
  return obj;
}
;
var arrowFunctionExpression = function arrowFunctionExpression(params, body, returnType) {
  var isAsync = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var typeParameters = arguments.length > 4 ? arguments[4] : undefined;
  var func = t.arrowFunctionExpression(params, body, isAsync);
  func.returnType = returnType;
  func.typeParameters = typeParameters;
  return func;
};
exports.arrowFunctionExpression = arrowFunctionExpression;
var tsTypeParameterDeclaration = function tsTypeParameterDeclaration(params) {
  var obj = t.tsTypeParameterDeclaration(params);
  delete obj.extra;
  return obj;
};
exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
var objectPattern = function objectPattern(properties, typeAnnotation) {
  var obj = t.objectPattern(properties);
  obj.typeAnnotation = typeAnnotation;
  return obj;
};
exports.objectPattern = objectPattern;
var objectMethod = function objectMethod(kind, key, params, body, computed, generator, async, returnType, typeParameters) {
  var obj = t.objectMethod(kind, key, params, body, computed, generator, async);
  obj.returnType = returnType;
  obj.typeParameters = typeParameters;
  return obj;
};
exports.objectMethod = objectMethod;
var objectProperty = function objectProperty(key, value, computed, shorthand, decorators) {
  var leadingComments = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];
  var obj = t.objectProperty(key, value, computed, shorthand, decorators);
  if (leadingComments.length) obj.leadingComments = leadingComments;
  return obj;
};
exports.objectProperty = objectProperty;
var makeCommentLineWithBlocks = function makeCommentLineWithBlocks(comment) {
  if (!comment) return [];
  // NOTE using blocks instead of lines here...
  // @ts-ignore
  return [(0, _utils.makeCommentBlock)(comment)];
};
exports.makeCommentLineWithBlocks = makeCommentLineWithBlocks;