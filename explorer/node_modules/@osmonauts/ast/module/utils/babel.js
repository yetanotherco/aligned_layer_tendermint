import * as t from '@babel/types';
import { makeCommentBlock } from './utils';

// TODO move to @osmonauts/utils package

export const commentBlock = value => {
  return {
    type: 'CommentBlock',
    value,
    start: null,
    end: null,
    loc: null
  };
};
export const commentLine = value => {
  return {
    type: 'CommentLine',
    value,
    start: null,
    end: null,
    loc: null
  };
};
export function tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation = null, trailingComments, leadingComments) {
  const obj = t.tsMethodSignature(key, typeParameters, parameters, typeAnnotation);
  obj.kind = 'method';
  if (trailingComments && trailingComments.length) {
    obj.trailingComments = trailingComments;
  }
  if (leadingComments && leadingComments.length) {
    obj.leadingComments = leadingComments;
  }
  return obj;
}
export const classMethod = (kind, key, params, body, returnType, leadingComments = [], computed = false, _static = false, generator = false, async = false) => {
  const obj = t.classMethod(kind, key, params, body, computed, _static, generator, async);
  if (returnType) {
    obj.returnType = returnType;
  }
  if (leadingComments) {
    obj.leadingComments = leadingComments;
  }
  return obj;
};
export const tsEnumMember = (id, initializer, leadingComments) => {
  const obj = t.tsEnumMember(id, initializer);
  obj.leadingComments = leadingComments;
  return obj;
};
export const tsPropertySignature = (key, typeAnnotation, optional) => {
  const obj = t.tsPropertySignature(key, typeAnnotation);
  obj.optional = optional;
  return obj;
};
export const functionDeclaration = (id, params, body, generator, async, returnType) => {
  const func = t.functionDeclaration(id, params, body, generator, async);
  func.returnType = returnType;
  return func;
};
export const callExpression = (callee, _arguments, typeParameters) => {
  const callExpr = t.callExpression(callee, _arguments);
  callExpr.typeParameters = typeParameters;
  return callExpr;
};
export const identifier = (name, typeAnnotation, optional = false) => {
  const type = t.identifier(name);
  type.typeAnnotation = typeAnnotation;
  type.optional = optional;
  return type;
};
export const classDeclaration = (id, superClass = null, body, decorators = null, vImplements, superTypeParameters) => {
  const obj = t.classDeclaration(id, superClass, body, decorators);
  if (superTypeParameters) {
    obj.superTypeParameters = superTypeParameters;
  }
  if (vImplements) {
    obj.implements = vImplements;
  }
  return obj;
};
export function classProperty(key, value = null, typeAnnotation = null, decorators = null, computed = false, _static = false, _readonly = false, accessibility, leadingComments = []) {
  const obj = t.classProperty(key, value, typeAnnotation, decorators, computed, _static);
  if (accessibility) obj.accessibility = accessibility;
  if (_readonly) obj.readonly = _readonly;
  if (leadingComments.length) obj.leadingComments = leadingComments;
  return obj;
}
;
export const arrowFunctionExpression = (params, body, returnType, isAsync = false, typeParameters) => {
  const func = t.arrowFunctionExpression(params, body, isAsync);
  func.returnType = returnType;
  func.typeParameters = typeParameters;
  return func;
};
export const tsTypeParameterDeclaration = params => {
  const obj = t.tsTypeParameterDeclaration(params);
  delete obj.extra;
  return obj;
};
export const objectPattern = (properties, typeAnnotation) => {
  const obj = t.objectPattern(properties);
  obj.typeAnnotation = typeAnnotation;
  return obj;
};
export const objectMethod = (kind, key, params, body, computed, generator, async, returnType, typeParameters) => {
  const obj = t.objectMethod(kind, key, params, body, computed, generator, async);
  obj.returnType = returnType;
  obj.typeParameters = typeParameters;
  return obj;
};
export const objectProperty = (key, value, computed, shorthand, decorators, leadingComments = []) => {
  const obj = t.objectProperty(key, value, computed, shorthand, decorators);
  if (leadingComments.length) obj.leadingComments = leadingComments;
  return obj;
};
export const makeCommentLineWithBlocks = comment => {
  if (!comment) return [];
  // NOTE using blocks instead of lines here...
  // @ts-ignore
  return [makeCommentBlock(comment)];
};