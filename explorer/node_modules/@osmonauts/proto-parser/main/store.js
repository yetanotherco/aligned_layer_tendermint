"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseProto = exports.ProtoStore = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _glob = require("glob");

var _protobufjs = require("@pyramation/protobufjs");

var _fs = require("fs");

var _path = require("path");

var _utils = require("./utils");

var _traverse = require("./traverse");

var _lookup = require("./lookup");

var _types = require("@osmonauts/types");

var _any = _interopRequireDefault(require("./native/any"));

var _descriptor = _interopRequireDefault(require("./native/descriptor"));

var _duration = _interopRequireDefault(require("./native/duration"));

var _timestamp = _interopRequireDefault(require("./native/timestamp"));

var _empty = _interopRequireDefault(require("./native/empty"));

var _field_mask = _interopRequireDefault(require("./native/field_mask"));

var _struct = _interopRequireDefault(require("./native/struct"));

var _wrappers = _interopRequireDefault(require("./native/wrappers"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var GOOGLE_PROTOS = [['google/protobuf/any.proto', _any["default"]], ['google/protobuf/duration.proto', _duration["default"]], ['google/protobuf/descriptor.proto', _descriptor["default"]], ['google/protobuf/timestamp.proto', _timestamp["default"]], ['google/protobuf/empty.proto', _empty["default"]], ['google/protobuf/struct.proto', _struct["default"]], ['google/protobuf/wrappers.proto', _wrappers["default"]], ['google/protobuf/field_mask.proto', _field_mask["default"]]];
var protoParseOptionsDefaults = {
  keepCase: false,
  alternateCommentMode: true,
  preferTrailingComment: false
};

var parseProto = function parseProto(content, options) {
  if (!options) {
    options = protoParseOptionsDefaults;
  }

  return (0, _protobufjs.parse)(content, options);
};

exports.parseProto = parseProto;

var ProtoStore = /*#__PURE__*/function () {
  function ProtoStore() {
    var protoDirs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _types.defaultTelescopeOptions;
    (0, _classCallCheck2["default"])(this, ProtoStore);
    (0, _defineProperty2["default"])(this, "files", void 0);
    (0, _defineProperty2["default"])(this, "protoDirs", void 0);
    (0, _defineProperty2["default"])(this, "deps", void 0);
    (0, _defineProperty2["default"])(this, "protos", void 0);
    (0, _defineProperty2["default"])(this, "packages", void 0);
    (0, _defineProperty2["default"])(this, "options", void 0);
    (0, _defineProperty2["default"])(this, "requests", {});
    (0, _defineProperty2["default"])(this, "responses", {});
    (0, _defineProperty2["default"])(this, "_traversed", false);
    (0, _defineProperty2["default"])(this, "_symbols", []);
    this.protoDirs = protoDirs.map(function (protoDir) {
      return (0, _path.resolve)(protoDir);
    });
    this.options = options;
  }

  (0, _createClass2["default"])(ProtoStore, [{
    key: "findProto",
    value: function findProto(filename) {
      return this.getProtos().find(function (proto) {
        return proto.filename === filename;
      });
    }
  }, {
    key: "findProtoWhere",
    value: function findProtoWhere(fn) {
      return this.getProtos().find(function (ref) {
        return fn(ref);
      });
    }
  }, {
    key: "filterProtoWhere",
    value: function filterProtoWhere(fn) {
      return this.getProtos().filter(function (ref) {
        return fn(ref);
      });
    }
  }, {
    key: "findProtoObject",
    value: function findProtoObject(filename, name) {
      var _proto$traversed;

      var proto = this.findProto(filename);
      return (0, _utils.getNestedProto)((_proto$traversed = proto.traversed) !== null && _proto$traversed !== void 0 ? _proto$traversed : proto.proto)[name];
    }
  }, {
    key: "registerRequest",
    value: function registerRequest(svc) {
      this.requests[svc.requestType] = svc;
      this.responses[svc.responseType] = svc;
    }
  }, {
    key: "processProtos",
    value: function processProtos(contents) {
      var _this = this;

      return contents.map(function (_ref) {
        var absolute = _ref.absolute,
            filename = _ref.filename,
            content = _ref.content;

        try {
          var proto = parseProto(content, _this.options.prototypes.parser);
          return {
            absolute: absolute,
            filename: filename,
            proto: proto
          };
        } catch (e) {
          console.error("".concat(filename, " has a proto syntax error"));
          throw e;
        }
      });
    }
  }, {
    key: "getProtos",
    value: function getProtos() {
      var _this2 = this;

      if (this.protos) return this.protos;
      var contents = this.protoDirs.reduce(function (m, protoDir) {
        var protoSplat = (0, _path.join)(protoDir, '/**/*.proto');
        var protoFiles = (0, _glob.sync)(protoSplat);
        var contents = protoFiles.map(function (filename) {
          return {
            absolute: filename,
            filename: filename.split(protoDir)[1].replace(/^\//, ''),
            content: (0, _fs.readFileSync)(filename, 'utf-8')
          };
        });
        return [].concat((0, _toConsumableArray2["default"])(m), (0, _toConsumableArray2["default"])(contents));
      }, []);
      var registeredProtos = [];
      var protos = this.processProtos(contents).filter(function (proto) {
        if (registeredProtos.includes(proto.filename)) {
          if (_this2.options.logLevel >= _types.TelescopeLogLevel.Warn) {
            console.warn("".concat(proto.filename, " already included!"));
          }

          return false;
        }

        registeredProtos.push(proto.filename);
        return true;
      });
      var neededFromGoogle = [];
      this.getDependencies(protos).map(function (dep) {
        var _dep$imports$filter, _dep$imports;

        var google = (_dep$imports$filter = (_dep$imports = dep.imports) === null || _dep$imports === void 0 ? void 0 : _dep$imports.filter(function (imp) {
          return imp.startsWith('google/protobuf');
        })) !== null && _dep$imports$filter !== void 0 ? _dep$imports$filter : [];

        if (google.length) {
          google.forEach(function (goog) {
            // if they don't got it, let's give it to 'em!
            var found = contents.find(function (file) {
              return file.filename === goog;
            });
            if (found) return; // NOT FOUND

            var filler = GOOGLE_PROTOS.find(function (_ref2) {
              var _ref3 = (0, _slicedToArray2["default"])(_ref2, 2),
                  f = _ref3[0],
                  v = _ref3[1];

              return f === goog;
            });
            if (!filler) return; // technically an error should be thrown 
            // we have the filler

            if (!neededFromGoogle.find(function (file) {
              return file.filename === goog;
            })) {
              neededFromGoogle.push({
                absolute: filler[0],
                filename: filler[0],
                content: filler[1]
              });
            }
          });
        }
      });
      var missingProtos = this.processProtos(neededFromGoogle);
      this.protos = [].concat((0, _toConsumableArray2["default"])(protos), (0, _toConsumableArray2["default"])(missingProtos));
      return this.protos;
    }
  }, {
    key: "getPackages",
    value: function getPackages() {
      if (this.packages) return this.packages;
      this.packages = this.getProtos().reduce(function (m, ref) {
        return (0, _toConsumableArray2["default"])(new Set([].concat((0, _toConsumableArray2["default"])(m), [ref.proto["package"]])));
      }, []); // LONGEST strings first, for better matching

      this.packages = this.packages.sort(function (a, b) {
        return b.length - a.length;
      });
      return this.packages;
    }
  }, {
    key: "parseScope",
    value: function parseScope(type) {
      var pkgs = this.getPackages();

      var _iterator = _createForOfIteratorHelper(pkgs),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var pkg = _step.value;
          var found = (0, _utils.getPackageAndNestedFromStr)(type, pkg);
          if (found) return found;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "getDeps",
    value: function getDeps() {
      if (this.deps) return this.deps;
      this.deps = this.getDependencies(this.getProtos());
      return this.deps;
    }
  }, {
    key: "getDependencies",
    value: function getDependencies(protos) {
      return protos.map(function (el) {
        var filename = el.filename,
            _el$proto = el.proto,
            pkg = _el$proto["package"],
            imports = _el$proto.imports;
        return {
          filename: filename,
          "package": pkg,
          imports: imports
        };
      });
    }
  }, {
    key: "traverseAll",
    value: function traverseAll() {
      var _this3 = this;

      if (this._traversed) return;
      this.protos = this.getProtos().map(function (ref) {
        return {
          absolute: ref.absolute,
          filename: ref.filename,
          proto: ref.proto,
          traversed: (0, _traverse.traverse)(_this3, ref)
        };
      });
      this._symbols = (0, _traverse.parseFullyTraversedProtoImports)(this); // process import names

      this.protos = this.protos.map(function (ref) {
        var traversed = ref.traversed;

        var symbs = _this3._symbols.filter(function (f) {
          return f.ref === ref.filename;
        });

        traversed.importNames = (0, _traverse.symbolsToImportNames)(ref, symbs); // now add any inferred imports as a result of accepts/implements

        symbs.filter(function (f) {
          return f.ref !== f.source;
        }).forEach(function (f) {
          traversed.parsedImports[f.source] = traversed.parsedImports[f.source] || [];
          traversed.parsedImports[f.source] = (0, _toConsumableArray2["default"])(new Set([].concat((0, _toConsumableArray2["default"])(traversed.parsedImports[f.source]), [f.symbolName])));
        });
        return _objectSpread(_objectSpread({}, ref), {}, {
          traversed: traversed
        });
      });
      this._traversed = true;
    }
  }, {
    key: "get",
    value: function get(from, name) {
      if (!this._traversed) throw new Error('get() requires traversal');
      return (0, _lookup.lookupAny)(this, from, name);
    }
  }, {
    key: "getImportFromRef",
    value: function getImportFromRef(ref, name) {
      if (!this._traversed) throw new Error('getImportFromRef() requires traversal');
      return (0, _lookup.lookupAnyFromImports)(this, ref, name);
    }
  }, {
    key: "getTypeUrlMap",
    value: function getTypeUrlMap(ref) {
      return (0, _utils.createTypeUrlTypeMap)(this, ref);
    } // DOCUMENTATION

  }, {
    key: "getServices",
    value: function getServices(myBase) {
      var _this4 = this;

      var refs = this.getProtos().filter(function (ref) {
        var proto = (0, _utils.getNestedProto)(ref.traversed); //// Anything except Msg Service OK...

        var allowedRpcServices = _this4.options.rpcClients.enabledServices.filter(function (a) {
          return a !== 'Msg';
        });

        var found = allowedRpcServices.some(function (svc) {
          var _proto$svc;

          return (proto === null || proto === void 0 ? void 0 : proto[svc]) && ((_proto$svc = proto[svc]) === null || _proto$svc === void 0 ? void 0 : _proto$svc.type) === 'Service';
        });

        if (!found) {
          return;
        } ///


        return true;
      });
      var check = refs.filter(function (ref) {
        var _ref$proto$package$sp = ref.proto["package"].split('.'),
            _ref$proto$package$sp2 = (0, _slicedToArray2["default"])(_ref$proto$package$sp, 1),
            base = _ref$proto$package$sp2[0];

        return base === myBase;
      });

      if (!check.length) {
        return {};
      }

      var packages = refs.reduce(function (m, ref) {
        var _ref$proto$package$sp3 = ref.proto["package"].split('.'),
            _ref$proto$package$sp4 = (0, _slicedToArray2["default"])(_ref$proto$package$sp3, 1),
            base = _ref$proto$package$sp4[0];

        if (base === myBase) {
          if (!m[ref.proto["package"]]) m[ref.proto["package"]] = [];
          m[ref.proto["package"]].push(ref);
        }

        return m;
      }, {});
      return packages;
    }
  }]);
  return ProtoStore;
}();

exports.ProtoStore = ProtoStore;