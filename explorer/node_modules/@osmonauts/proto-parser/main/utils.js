"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lookupSymbolScopes = exports.isRefIncluded = exports.instanceType = exports.getTypes = exports.getServices = exports.getPackageAndNestedFromStr = exports.getObjectName = exports.getNestedProtoGeneric = exports.getNestedProto = exports.getNested = exports.getEnums = exports.createTypeUrlTypeMap = exports.SCALAR_TYPES = void 0;

var _toArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _dotty = _interopRequireDefault(require("dotty"));

var _protobufjs = require("@pyramation/protobufjs");

var _ast = require("@osmonauts/ast");

var _minimatch = _interopRequireDefault(require("minimatch"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var getNestedProto = function getNestedProto(root) {
  var nestedPath = 'root.nested.' + root["package"].split('.').join('.nested.') + '.nested';
  return _dotty["default"].get(root, nestedPath);
};

exports.getNestedProto = getNestedProto;

var getNestedProtoGeneric = function getNestedProtoGeneric(root, path) {
  path = root["package"].split('.').concat(path);
  var nestedPath = 'root.nested.' + path.join('.nested.') + '.nested';
  return _dotty["default"].get(root, nestedPath);
};

exports.getNestedProtoGeneric = getNestedProtoGeneric;

var getNested = function getNested(root, path) {
  var nestedPath = 'root.nested.' + path.join('.nested.') + '.nested';
  return _dotty["default"].get(root, nestedPath);
}; // https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/descriptor.cc#L3798-L3812
// NOTE: sometimes you need to pass in `.Dummy` for the first call,
// for example, osmosis.gamm.v1beta1.Dummy, so the first pop()
// that gets called, it will still look relative to the current module scope


exports.getNested = getNested;

var lookupSymbolScopes = function lookupSymbolScopes(name, relativeTo, list) {
  // fully-qualified name
  if (name.startsWith('.')) return [name.replace(/^\./, '')];
  if (!list) list = [];
  var relativeToParts = relativeTo.split('.'); // This first searches siblings of relative_to (pop off relative_to)

  relativeToParts.pop();
  var newName = [].concat((0, _toConsumableArray2["default"])(relativeToParts), (0, _toConsumableArray2["default"])(name.split('.'))).join('.');
  if (newName === name) return [].concat((0, _toConsumableArray2["default"])(list), [name]);
  return lookupSymbolScopes(name, relativeToParts.join('.'), [].concat((0, _toConsumableArray2["default"])(list), [newName]));
};

exports.lookupSymbolScopes = lookupSymbolScopes;

var createTypeUrlTypeMap = function createTypeUrlTypeMap(store, fromRef) {
  var _fromRef$traversed$ac, _fromRef$traversed;

  var ctx = new _ast.GenericParseContext(fromRef, store, store.options);
  var result = {};
  var interfaces = [];
  Object.keys((_fromRef$traversed$ac = (_fromRef$traversed = fromRef.traversed) === null || _fromRef$traversed === void 0 ? void 0 : _fromRef$traversed.acceptsInterface) !== null && _fromRef$traversed$ac !== void 0 ? _fromRef$traversed$ac : {}).forEach(function (implementsType) {
    interfaces.push(implementsType);
  });
  store.getProtos().forEach(function (ref) {
    var _ref$traversed;

    if ((_ref$traversed = ref.traversed) !== null && _ref$traversed !== void 0 && _ref$traversed.implementsInterface) {
      Object.keys(ref.traversed.implementsInterface).forEach(function (implementsType) {
        var _ref$traversed2;

        if (!interfaces.includes(implementsType)) return;
        var types = (_ref$traversed2 = ref.traversed) === null || _ref$traversed2 === void 0 ? void 0 : _ref$traversed2.implementsInterface[implementsType];
        result[implementsType] = result[implementsType] || [];
        result[implementsType].push({
          ref: ref.filename,
          pkg: ref.proto["package"],
          types: types === null || types === void 0 ? void 0 : types.map(function (type) {
            var protoType = getNestedProto(ref.proto)[type];
            var typeUrl = (0, _ast.getTypeUrl)(ref.proto, protoType);
            var aminoType = (0, _ast.getAminoTypeName)(ctx, ref.proto, protoType);
            return {
              typeUrl: typeUrl,
              aminoType: aminoType,
              type: type,
              importAs: ctx.getTypeNameFromFieldName(type, ref.filename)
            };
          })
        });
      });
    }
  });
  return result;
};

exports.createTypeUrlTypeMap = createTypeUrlTypeMap;

var isRefIncluded = function isRefIncluded(ref, include) {
  var _include$patterns, _include$packages, _include$protos, _include$patterns2, _include$packages2, _include$protos2;

  // if no include object, no filter
  if (!include) return true; // if no arrays are populated, no filter

  if (!((_include$patterns = include.patterns) !== null && _include$patterns !== void 0 && _include$patterns.length) && !((_include$packages = include.packages) !== null && _include$packages !== void 0 && _include$packages.length) && !((_include$protos = include.protos) !== null && _include$protos !== void 0 && _include$protos.length)) {
    return true;
  }

  if (include !== null && include !== void 0 && (_include$patterns2 = include.patterns) !== null && _include$patterns2 !== void 0 && _include$patterns2.some(function (pattern) {
    return (0, _minimatch["default"])(ref.filename, pattern);
  })) {
    return true;
  }

  if (include !== null && include !== void 0 && (_include$packages2 = include.packages) !== null && _include$packages2 !== void 0 && _include$packages2.includes(ref.proto["package"])) {
    return true;
  }

  if (include !== null && include !== void 0 && (_include$protos2 = include.protos) !== null && _include$protos2 !== void 0 && _include$protos2.includes(ref.filename)) {
    return true;
  }

  return false;
};

exports.isRefIncluded = isRefIncluded;

var getPackageAndNestedFromStr = function getPackageAndNestedFromStr(type, pkg) {
  if (type.startsWith(pkg) && type.length > pkg.length) {
    var nested = type.substring(pkg.length + 1);
    return {
      nested: nested,
      "package": pkg
    };
  }
};

exports.getPackageAndNestedFromStr = getPackageAndNestedFromStr;

var getServices = function getServices(root) {
  var nested = getNestedProto(root);
  return Object.keys(nested).map(function (key) {
    return nested[key];
  }).filter(function (obj) {
    return obj instanceof _protobufjs.Service;
  }).map(function (el) {
    return _objectSpread({
      name: el.name
    }, el.toJSON({
      keepComments: true
    }));
  });
};

exports.getServices = getServices;

var getTypes = function getTypes(root) {
  var nested = getNestedProto(root);
  return Object.keys(nested).map(function (key) {
    return nested[key];
  }).filter(function (obj) {
    return obj instanceof _protobufjs.Type;
  }).map(function (el) {
    return _objectSpread({
      name: el.name
    }, el.toJSON({
      keepComments: true
    }));
  });
};

exports.getTypes = getTypes;

var getEnums = function getEnums(root) {
  var nested = getNestedProto(root);
  return Object.keys(nested).map(function (key) {
    return nested[key];
  }).filter(function (obj) {
    return obj instanceof _protobufjs.Enum;
  }).map(function (el) {
    return _objectSpread({
      name: el.name
    }, el.toJSON({
      keepComments: true
    }));
  });
};
/*
    nested objects get a slightly different naming convention
    e.g. SignatureDescriptor_Data or SignatureDescriptor_Data_Multi
*/


exports.getEnums = getEnums;

var getObjectName = function getObjectName(name) {
  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  if (!scope.length || scope.length === 1) return name;

  var _scope = (0, _toArray2["default"])(scope),
      _pkg = _scope[0],
      scopes = _scope.slice(1);

  return [].concat((0, _toConsumableArray2["default"])(scopes), [name]).join('_');
};

exports.getObjectName = getObjectName;
var SCALAR_TYPES = ["double", // 0
"float", // 1
"int32", // 2
"uint32", // 3
"sint32", // 4
"fixed32", // 5
"sfixed32", // 6
"int64", // 7
"uint64", // 8
"sint64", // 9
"fixed64", // 10
"sfixed64", // 11
"bool", // 12
"string", // 13
"bytes" // 14
];
exports.SCALAR_TYPES = SCALAR_TYPES;

var instanceType = function instanceType(obj) {
  if (obj instanceof _protobufjs.Type) {
    return {
      name: obj.name,
      type: 'Type'
    };
  }

  if (obj instanceof _protobufjs.Enum) {
    return {
      name: obj.name,
      type: 'Enum'
    };
  }

  if (obj instanceof _protobufjs.Service) {
    return {
      name: obj.name,
      type: 'Service'
    };
  }

  if (obj instanceof _protobufjs.Root) {
    return {
      type: 'Root'
    };
  }

  if (obj instanceof _protobufjs.Namespace) {
    return {
      type: 'Namespace'
    };
  } // if (obj.name === 'Timestamp') {
  //     return {
  //         name: obj.name,
  //         type: 'google'
  //     };
  // }
  // if (obj.name === 'Duration') {
  //     return {
  //         name: obj.name,
  //         type: 'google'
  //     };
  // }


  if (obj.name.match(/^[a-z]/)) {
    throw new Error('instanceType() cannot find protobufjs Type');
  } // duck typing... 
  // TODO why did we lose instance types/names?


  if (obj.fields) {
    return {
      name: obj.name,
      type: 'Type'
    };
  }

  if (obj.values) {
    return {
      name: obj.name,
      type: 'Enum'
    };
  }

  throw new Error('instanceType() cannot find protobufjs Type');
};

exports.instanceType = instanceType;