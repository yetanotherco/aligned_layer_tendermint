"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.traverse = exports.symbolsToImportNames = exports.recursiveTraversal = exports.parseFullyTraversedProtoImports = exports.TraverseContext = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _ast = require("@osmonauts/ast");

var _protobufjs = require("@pyramation/protobufjs");

var _lookup = require("./lookup");

var _services = require("./services");

var _utils = require("./utils");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var TraverseContext = /*#__PURE__*/function () {
  function TraverseContext(store, ref) {
    (0, _classCallCheck2["default"])(this, TraverseContext);
    this.store = store;
    this.ref = ref;
    this.acceptsInterface = {};
    this.implementsInterface = {};
    this.imports = {};
    this.exports = {};
  }

  (0, _createClass2["default"])(TraverseContext, [{
    key: "addImport",
    value: function addImport(filename, symbolName) {
      this.imports[filename] = this.imports[filename] || [];
      this.imports[filename] = (0, _toConsumableArray2["default"])(new Set([].concat((0, _toConsumableArray2["default"])(this.imports[filename]), [symbolName])));
    }
  }, {
    key: "addImplements",
    value: function addImplements(symbolName, msgName) {
      this.implementsInterface = this.implementsInterface || {};
      this.implementsInterface[symbolName] = this.implementsInterface[symbolName] || [];
      this.implementsInterface[symbolName] = (0, _toConsumableArray2["default"])(new Set([].concat((0, _toConsumableArray2["default"])(this.implementsInterface[symbolName]), [msgName])));
    }
  }, {
    key: "addAccepts",
    value: function addAccepts(symbolName, msgName) {
      this.acceptsInterface[symbolName] = this.acceptsInterface[symbolName] || [];
      this.acceptsInterface[symbolName] = (0, _toConsumableArray2["default"])(new Set([].concat((0, _toConsumableArray2["default"])(this.acceptsInterface[symbolName]), [msgName])));
    }
  }, {
    key: "addExport",
    value: function addExport(symbolName) {
      this.exports[symbolName] = true;
    }
  }]);
  return TraverseContext;
}();

exports.TraverseContext = TraverseContext;

var symbolsToImportNames = function symbolsToImportNames(ref, symbols) {
  return symbols.reduce(function (m, v) {
    // imports to self... nope.
    if (v.source === ref.filename) return m;
    m[v.source] = m[v.source] || {};
    m[v.source][v.symbolName] = v.readAs;
    return m;
  }, {});
};

exports.symbolsToImportNames = symbolsToImportNames;

var parseFullyTraversedProtoImports = function parseFullyTraversedProtoImports(store) {
  var protos = store.getProtos();
  var records = [];
  var symbols = []; // AGGREGATE ALL implements

  protos.forEach(function (ref) {
    var _ref$traversed$implem, _ref$traversed;

    var enabled = (0, _ast.getPluginValue)('interfaces.enabled', ref.proto["package"], store.options);
    if (!enabled) return; //

    var implementsInterface = (_ref$traversed$implem = (_ref$traversed = ref.traversed) === null || _ref$traversed === void 0 ? void 0 : _ref$traversed.implementsInterface) !== null && _ref$traversed$implem !== void 0 ? _ref$traversed$implem : {};
    Object.keys(implementsInterface).forEach(function (implementsType) {
      implementsInterface[implementsType].forEach(function (msgName) {
        records.push({
          filename: ref.filename,
          implementsType: implementsType,
          msgName: msgName
        });
      });
    });
  });
  protos.forEach(function (ref) {
    var _ref$traversed$parsed, _ref$traversed2, _ref$traversed$parsed2, _ref$traversed3, _ref$traversed$accept, _ref$traversed5;

    var localSymbols = [];

    var hasConflict = function hasConflict(symbolName) {
      return localSymbols.filter(function (a) {
        return a.symbolName === symbolName;
      }).length > 1;
    };

    var findAvailableName = function findAvailableName(symbolName) {
      var counter = 1;
      if (!hasConflict(symbolName)) return symbolName;

      var _loop = function _loop() {
        var testName = symbolName + counter;
        var found = localSymbols.find(function (a) {
          return a.readAs === testName;
        });

        if (found) {
          counter++;
        } else {
          return {
            v: testName
          };
        }
      };

      while (true) {
        var _ret = _loop();

        if ((0, _typeof2["default"])(_ret) === "object") return _ret.v;
      }
    };

    Object.keys((_ref$traversed$parsed = (_ref$traversed2 = ref.traversed) === null || _ref$traversed2 === void 0 ? void 0 : _ref$traversed2.parsedExports) !== null && _ref$traversed$parsed !== void 0 ? _ref$traversed$parsed : {}).forEach(function (e) {
      localSymbols.push({
        type: 'export',
        source: ref.filename,
        symbolName: e,
        readAs: e
      });
    });
    Object.keys((_ref$traversed$parsed2 = (_ref$traversed3 = ref.traversed) === null || _ref$traversed3 === void 0 ? void 0 : _ref$traversed3.parsedImports) !== null && _ref$traversed$parsed2 !== void 0 ? _ref$traversed$parsed2 : {}).forEach(function (source) {
      var _ref$traversed$parsed3, _ref$traversed4, _ref$traversed4$parse;

      var imps = (_ref$traversed$parsed3 = (_ref$traversed4 = ref.traversed) === null || _ref$traversed4 === void 0 ? void 0 : (_ref$traversed4$parse = _ref$traversed4.parsedImports) === null || _ref$traversed4$parse === void 0 ? void 0 : _ref$traversed4$parse[source]) !== null && _ref$traversed$parsed3 !== void 0 ? _ref$traversed$parsed3 : [];
      imps.forEach(function (im) {
        localSymbols.push({
          type: 'import',
          source: source,
          symbolName: im,
          readAs: im
        });
      });
    });
    Object.keys((_ref$traversed$accept = (_ref$traversed5 = ref.traversed) === null || _ref$traversed5 === void 0 ? void 0 : _ref$traversed5.acceptsInterface) !== null && _ref$traversed$accept !== void 0 ? _ref$traversed$accept : {}).forEach(function (implementsType) {
      var enabled = (0, _ast.getPluginValue)('interfaces.enabled', ref.proto["package"], store.options);
      if (!enabled) return;
      var recordsThatMatter = records.filter(function (rec) {
        return rec.implementsType === implementsType;
      });
      var notYetInImports = recordsThatMatter.filter(function (r) {
        return !localSymbols.find(function (l) {
          return l.source === r.filename && l.symbolName === r.msgName;
        });
      });
      var alreadyInImports = recordsThatMatter.filter(function (r) {
        return localSymbols.find(function (l) {
          return l.source === r.filename && l.symbolName === r.msgName;
        });
      });
      notYetInImports.forEach(function (imp) {
        localSymbols.push({
          type: 'import',
          source: imp.filename,
          readAs: imp.msgName,
          symbolName: imp.msgName,
          implementsType: imp.implementsType
        });
      }); // if already imported, addd implementsType

      alreadyInImports.forEach(function (imp) {
        var index = localSymbols.findIndex(function (l) {
          return l.source === imp.filename && l.symbolName === imp.msgName;
        });
        localSymbols[index].implementsType = imp.implementsType;
      });
    }); // update localSymbols for any conflicts

    localSymbols.forEach(function (sym) {
      // aside from exports, update readAs names...
      if (sym.readAs === sym.symbolName && hasConflict(sym.symbolName) && sym.type !== 'export') {
        sym.readAs = findAvailableName(sym.symbolName);
      } // add to symbols


      symbols.push(_objectSpread({
        ref: ref.filename
      }, sym));
    });
  });
  return symbols;
};

exports.parseFullyTraversedProtoImports = parseFullyTraversedProtoImports;

var traverse = function traverse(store, ref) {
  var context = new TraverseContext(store, ref); // @ts-ignore

  var obj = {
    imports: ref.proto.imports,
    "package": ref.proto["package"],
    root: recursiveTraversal(store, ref, ref.proto.root, context, [], false),
    parsedImports: null,
    parsedExports: null,
    importNames: {}
  };
  obj.parsedImports = context.imports;
  obj.parsedExports = context.exports;
  obj.acceptsInterface = context.acceptsInterface;
  obj.implementsInterface = context.implementsInterface; // just bc devs use proto syntax for types in the same file
  // does not mean we need to import them
  // delete any imports related to "this" file
  // delete obj.importNames[ref.filename];

  delete obj.parsedImports[ref.filename];
  return obj;
};

exports.traverse = traverse;

var getAllRefs = function getAllRefs(store, ref) {
  var _ref$proto$imports$ma, _ref$proto$imports;

  var importRefs = (_ref$proto$imports$ma = (_ref$proto$imports = ref.proto.imports) === null || _ref$proto$imports === void 0 ? void 0 : _ref$proto$imports.map(function (imp) {
    return store.findProto(imp);
  })) !== null && _ref$proto$imports$ma !== void 0 ? _ref$proto$imports$ma : [];
  return importRefs.reduce(function (m, v) {
    return [].concat((0, _toConsumableArray2["default"])(m), (0, _toConsumableArray2["default"])(getAllRefs(store, v)));
  }, importRefs);
};

var traverseFields = function traverseFields(store, ref, obj, context, traversal) {
  return Object.keys(obj.fields).reduce(function (m, mykey) {
    var _field$options;

    var field = obj.fields[mykey];
    var fieldName = mykey;
    var regexp = /([a-zA-Z0-9]+)[_]+([0-9]+)$/;

    if (regexp.test(fieldName)) {
      var matches = fieldName.match(regexp);

      if (matches !== null && matches !== void 0 && matches.length) {
        var begin = fieldName.split(matches[1])[0];
        fieldName = "".concat(begin).concat(matches[1]).concat(matches[2]);
      }
    }

    var serialize = function serialize() {
      if (typeof field.toJSON !== 'undefined') {
        // non-traversed
        return field.toJSON({
          keepComments: true
        });
      } // traversed
      // field.name is used for proto!


      field.name = fieldName;
      field.message = obj.name;
      field["package"] = ref.proto["package"];
      return field;
    };

    var implementsAcceptsAny = (0, _ast.getPluginValue)('interfaces.enabled', ref.proto["package"], store.options);

    if (implementsAcceptsAny && (_field$options = field.options) !== null && _field$options !== void 0 && _field$options['(cosmos_proto.accepts_interface)']) {
      var value = field.options['(cosmos_proto.accepts_interface)']; // some of these contain a comma ...

      value.split(',').map(function (a) {
        return a.trim();
      }).forEach(function (name) {
        context.addAccepts(name, obj.name);
      });
    }

    var found = null;

    if (_utils.SCALAR_TYPES.includes(field.type)) {
      m[fieldName] = _objectSpread({
        parsedType: {
          name: field.type,
          type: 'native'
        },
        isScalar: true,
        typeNum: _utils.SCALAR_TYPES.indexOf(field.type)
      }, serialize());
      return m;
    } // nested scope first


    found = (0, _lookup.lookupNested)(ref, traversal, field.type);

    if (found) {
      m[fieldName] = _objectSpread({
        scope: found.scope,
        parsedType: (0, _utils.instanceType)(found)
      }, serialize());
      return m;
    } // local scope second


    found = (0, _lookup.lookup)(store, ref, field.type);

    if (found) {
      m[fieldName] = _objectSpread({
        scope: found.scope,
        parsedType: (0, _utils.instanceType)(found)
      }, serialize());
      return m;
    }

    found = (0, _lookup.importLookup)(store, ref, field.type);

    if (found) {
      context.addImport(found["import"], found.name);
      m[fieldName] = _objectSpread(_objectSpread({
        parsedType: (0, _utils.instanceType)(found.obj),
        scopeType: 'import',
        scope: [found.obj.scope]
      }, serialize()), {}, {
        importedName: found.importedName,
        "import": found["import"]
      });
      return m;
    } // found = protoImportLookup(store, ref, field.type);
    // if (found) {
    //     imports[found.import] = imports[found.import] || [];
    //     imports[found.import] = [...new Set([...imports[found.import], found.name])];
    //     m[fieldName] = {
    //         parsedType: instanceType(found.obj),
    //         scopeType: 'protoImport',
    //         scope: [found.package],
    //         ...serialize(),
    //         importedName: found.importedName,
    //         import: found.import,
    //     };
    //     return m;
    // }
    // new scope lookup (TODO: replace above cases)


    var typeNames = (0, _utils.lookupSymbolScopes)(field.type, ref.proto["package"] + '.dummy');

    var _iterator = _createForOfIteratorHelper(typeNames),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var lookupType = _step.value;
        found = (0, _lookup.protoScopeImportLookup)(store, ref, lookupType);

        if (found) {
          context.addImport(found["import"], found.name);
          m[fieldName] = _objectSpread(_objectSpread({
            parsedType: (0, _utils.instanceType)(found.obj),
            scopeType: 'protoImport',
            scope: found.obj.scope ? found.obj.scope : [found["package"]]
          }, serialize()), {}, {
            importedName: found.importedName,
            "import": found["import"]
          });
          return m;
        }
      } // e.g. akash/deployment/v1beta2/service.proto
      // referencing messages in another file, and so we need access through our imports
      // if we get this issue again, this should be recursive and not just one level...

    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    var importRefs = ref.proto.imports.map(function (imp) {
      return store.findProto(imp);
    }); // const importRefs = getAllRefs(store, ref);

    var _iterator2 = _createForOfIteratorHelper(importRefs),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var importRef = _step2.value;

        var _typeNames = (0, _utils.lookupSymbolScopes)(field.type, importRef.proto["package"] + '.dummy');

        var _iterator3 = _createForOfIteratorHelper(_typeNames),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _lookupType = _step3.value;
            found = (0, _lookup.protoScopeImportLookup)(store, importRef, _lookupType);

            if (found) {
              context.addImport(found["import"], found.name);
              m[fieldName] = _objectSpread(_objectSpread({
                parsedType: (0, _utils.instanceType)(found.obj),
                scopeType: 'protoImport',
                scope: found.obj.scope ? found.obj.scope : [found["package"]]
              }, serialize()), {}, {
                importedName: found.importedName,
                "import": found["import"]
              });
              return m;
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    console.warn("\n".concat(obj.name, ".").concat(field.name, ": ").concat(field.type, " NOT FOUND from ").concat(ref.filename, " in ").concat(ref.proto["package"], "\nyou should contact the maintainers.\n"));
    return m;
  }, {});
};

var traverseType = function traverseType(store, ref, obj, context, traversal, isNested) {
  var _traversed$options;

  var nested = null;

  if (obj.nested) {
    nested = Object.keys(obj.nested).reduce(function (m, key) {
      m[key] = recursiveTraversal(store, ref, obj.nested[key], context, [].concat((0, _toConsumableArray2["default"])(traversal), [key]), true);
      return m;
    }, {});
  }

  if (!isNested) {
    context.addExport(obj.name);
  }

  var traversed = {
    type: 'Type',
    name: obj.name,
    "package": ref.proto["package"],
    options: obj.options,
    oneofs: obj.oneofs ? Object.keys(obj.oneofs).reduce(function (m, v) {
      m[v] = {
        // parse oneof
        oneof: obj.oneofs[v].oneof.map(function (name) {
          return name;
        })
      };
      return m;
    }, {}) : undefined,
    fields: traverseFields(store, ref, obj, context, traversal),
    nested: nested,
    keyTypes: [],
    comment: obj.comment
  }; // parse keyType

  var hasKeyType = Object.keys(traversed.fields).some(function (field) {
    return !!traversed.fields[field].keyType;
  });
  var keyTypes = [];

  if (hasKeyType) {
    keyTypes = Object.keys(traversed.fields).filter(function (field) {
      return !!traversed.fields[field].keyType;
    }).map(function (field) {
      return _objectSpread({
        name: field
      }, traversed.fields[field]);
    });
  }

  traversed.keyTypes = keyTypes;
  var implementsAcceptsAny = (0, _ast.getPluginValue)('interfaces.enabled', ref.proto["package"], store.options);

  if (implementsAcceptsAny && (_traversed$options = traversed.options) !== null && _traversed$options !== void 0 && _traversed$options["(cosmos_proto.implements_interface)"]) {
    var name = traversed.options['(cosmos_proto.implements_interface)'];
    context.addImplements(name, obj.name);
  }

  return traversed;
};

var traverseEnum = function traverseEnum(store, ref, obj, context) {
  return _objectSpread({
    type: 'Enum',
    name: obj.name
  }, obj.toJSON({
    keepComments: true
  }));
};

var traverseField = function traverseField(store, ref, obj, context) {
  return _objectSpread({
    // type is already a property on field
    name: obj.name
  }, obj.toJSON({
    keepComments: true
  }));
};

var traverseServiceMethod = function traverseServiceMethod(store, ref, obj, context, name, traversal) {
  var service = obj.methods[name];
  var requestType = service.requestType,
      responseType = service.responseType,
      options = service.options,
      comment = service.comment;
  var responseObject = (0, _lookup.lookupAny)(store, ref, requestType);

  if (!responseObject) {
    throw new Error('Symbol not found ' + requestType);
  }

  var requestObject = (0, _lookup.lookupAny)(store, ref, requestType);

  if (!requestObject) {
    throw new Error('Symbol not found ' + requestType);
  }

  var fields = traverseFields(store, ref, requestObject.obj, context, traversal); // @ts-ignore

  var info = (0, _services.parseService)({
    options: options,
    fields: fields
  });
  var svc = {
    type: 'ServiceMethod',
    info: info,
    name: name,
    comment: comment,
    requestType: requestType,
    responseType: responseType,
    options: options,
    fields: fields
  };

  if (info) {
    // TODO is this still needed?
    // get casing info for request objects
    Object.keys(requestObject.obj.fields).map(function (fieldName) {
      var field = requestObject.obj.fields[fieldName];
      var protoCasing = store.options.prototypes.parser.keepCase ? field.options['(telescope:orig)'] : field.options['(telescope:camel)'];
      var origCase = field.options['(telescope:orig)'];
      svc.info.casing = svc.info.casing || {};
      svc.info.casing[origCase] = protoCasing;
    });
  }

  store.registerRequest(svc);
  return svc;
};

var traverseService = function traverseService(store, ref, obj, context, traversal) {
  var json = obj.toJSON({
    keepComments: true
  });
  var methods = Object.keys(json.methods).reduce(function (m, key) {
    m[key] = traverseServiceMethod(store, ref, json, context, key, traversal);
    return m;
  }, {});
  return _objectSpread(_objectSpread({
    type: 'Service',
    name: obj.name
  }, obj.toJSON({
    keepComments: true
  })), {}, {
    methods: methods
  });
};

var recursiveTraversal = function recursiveTraversal(store, ref, obj, context, traversal, isNested) {
  if (obj instanceof _protobufjs.Type) {
    return traverseType(store, ref, obj, context, traversal, isNested);
  }

  if (obj instanceof _protobufjs.Enum) {
    return traverseEnum(store, ref, obj, context);
  }

  if (obj instanceof _protobufjs.Service) {
    return traverseService(store, ref, obj, context, traversal);
  }

  if (obj instanceof _protobufjs.Field) {
    return traverseField(store, ref, obj, context);
  }

  if (obj instanceof _protobufjs.Root) {
    if (obj.nested) {
      return Object.keys(obj.nested).reduce(function (m, key) {
        m.nested[key] = recursiveTraversal(store, ref, obj.nested[key], context, [].concat((0, _toConsumableArray2["default"])(traversal), [key]), isNested);
        return m;
      }, {
        type: 'Root',
        nested: {}
      });
    } else {
      throw new Error('recursiveTraversal() [Root] cannot find protobufjs Type');
    }
  }

  if (obj instanceof _protobufjs.Namespace) {
    if (obj.nested) {
      return Object.keys(obj.nested).reduce(function (m, key) {
        m.nested[key] = recursiveTraversal(store, ref, obj.nested[key], context, [].concat((0, _toConsumableArray2["default"])(traversal), [key]), isNested);
        return m;
      }, {
        type: 'Namespace',
        nested: {}
      });
    } else {
      throw new Error('recursiveTraversal() [Namespace] cannot find protobufjs Type');
    }
  }

  throw new Error('recursiveTraversal() cannot find protobufjs Type');
};

exports.recursiveTraversal = recursiveTraversal;