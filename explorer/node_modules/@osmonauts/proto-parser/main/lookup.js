"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.recursiveLookup = exports.protoScopeImportLookup = exports.protoImportLookup = exports.lookupNested = exports.lookupLocal = exports.lookupAnyFromImports = exports.lookupAny = exports.lookup = exports.importLookup = exports.externalLookup = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _utils = require("./utils");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var recursiveLookup = function recursiveLookup(proto, name) {
  var scope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var allowNested = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  if (!proto) return;
  if (proto.hasOwnProperty(name)) return _objectSpread({
    name: name,
    scope: scope
  }, proto[name]);

  if (allowNested && proto) {
    var keys = Object.keys(proto);

    for (var k = 0; k < keys.length; k++) {
      var found = recursiveLookup(proto[keys[k]].nested, name, [].concat((0, _toConsumableArray2["default"])(scope), [keys[k]]), allowNested);

      if (found) {
        return _objectSpread({
          name: name
        }, found);
      }

      ;
    }
  }
};

exports.recursiveLookup = recursiveLookup;

var getRoot = function getRoot(ref) {
  if (ref.traversed) return ref.traversed;
  return ref.proto;
};
/*

  "imports": [
    "google/api/expr/v1alpha1/syntax.proto",
    "google/protobuf/empty.proto",
    "google/protobuf/struct.proto"
  ],

  ...

  "type": "Empty"

  finds Empty inside of the import

*/


var importLookup = function importLookup(store, ref, name) {
  var _root$imports$map$fil, _root$imports;

  var root = getRoot(ref);
  var objectsFromImports = (_root$imports$map$fil = root === null || root === void 0 ? void 0 : (_root$imports = root.imports) === null || _root$imports === void 0 ? void 0 : _root$imports.map(function (imp) {
    var ref = store.findProto(imp);

    if (!ref) {
      throw new Error("missing proto import ".concat(imp));
    }

    return {
      name: name,
      importType: 'import',
      "import": imp,
      importedName: name,
      obj: lookup(store, ref, name, false)
    };
  }).filter(function (a) {
    return !!a.obj;
  })) !== null && _root$imports$map$fil !== void 0 ? _root$imports$map$fil : [];
  if (objectsFromImports.length) return objectsFromImports[0];
};
/*

  "imports": [
    "google/api/expr/v1alpha1/syntax.proto",
    "google/protobuf/empty.proto",
    "google/protobuf/struct.proto"
  ],

  ...

  "type": "google.protobuf.NullValue"

  finds NullValue directly from package name

*/


exports.importLookup = importLookup;

var protoImportLookup = function protoImportLookup(store, ref, name) {
  var root = getRoot(ref);
  if (name.startsWith('.')) name = name.replace(/^\./, '');
  var nameAsArray = name.split('.');
  var objectName = nameAsArray.pop();
  var packageName = nameAsArray.join('.');
  var objs = store.getProtos() // 1 ask all package files of package, e.g "google.protobuf"
  .filter(function (proto) {
    return proto.proto["package"] === packageName;
  }) // 2 cross-checking w the imports by filter()
  .filter(function (proto) {
    var _root$imports2;

    return proto.filename === ref.filename || ((_root$imports2 = root.imports) === null || _root$imports2 === void 0 ? void 0 : _root$imports2.includes(proto.filename));
  }).map(function (ref) {
    return {
      "import": ref.filename,
      obj: lookup(store, ref, objectName, false)
    };
  }).filter(function (a) {
    return !!a.obj;
  });

  if (objs.length) {
    return {
      "import": objs[0]["import"],
      importType: 'protoImport',
      obj: objs[0].obj,
      importedName: name,
      name: objectName,
      "package": packageName
    };
  }
};

exports.protoImportLookup = protoImportLookup;

var protoScopeImportLookup = function protoScopeImportLookup(store, ref, name) {
  var root = getRoot(ref); // TODO pass in the imports and this ref
  // e.g. only include packges of those files !!!!!
  // this is currently looking at ALL protos 

  var parsed = store.parseScope(name);

  if (!parsed) {
    return;
  }

  var packageName = parsed["package"];
  var nameAsArray = parsed.nested.split('.');
  var lookupFn;

  if (nameAsArray.length > 1) {
    // nested!
    var traversal = [].concat((0, _toConsumableArray2["default"])(packageName.split('.')), (0, _toConsumableArray2["default"])(nameAsArray));
    var nameToLookFor = traversal.pop();

    lookupFn = function lookupFn(ref) {
      return {
        "import": ref.filename,
        obj: lookupNested(ref, traversal, nameToLookFor, true)
      };
    };
  } else {
    // single lookup
    lookupFn = function lookupFn(ref) {
      return {
        "import": ref.filename,
        obj: lookup(store, ref, parsed.nested, false)
      };
    };
  }

  var refs = store.getProtos() // 1 ask all package files of package, e.g "google.protobuf"
  .filter(function (proto) {
    return proto.proto["package"] === packageName;
  }) // 2 cross-checking w the imports by filter()
  .filter(function (proto) {
    var _root$imports3;

    return proto.filename === ref.filename || ((_root$imports3 = root.imports) === null || _root$imports3 === void 0 ? void 0 : _root$imports3.includes(proto.filename));
  });

  var _iterator = _createForOfIteratorHelper(refs),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _ref = _step.value;
      var found = lookupFn(_ref);

      if (found && found.obj) {
        if (nameAsArray.length > 1) {
          return {
            "import": found["import"],
            importType: 'protoImport',
            obj: found.obj,
            // not sure why scope doesn't handle this
            // so we're wrapping with underscores here
            // EXAMPLE: google/logging/v2/logging_metrics 
            // EXAMPLE: google/api/servicecontrol/v1/distribution
            importedName: nameAsArray.join('_'),
            name: nameAsArray.join('_'),
            "package": packageName
          };
        } else {
          return {
            "import": found["import"],
            importType: 'protoImport',
            obj: found.obj,
            importedName: name,
            name: parsed.nested,
            "package": packageName
          };
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
};

exports.protoScopeImportLookup = protoScopeImportLookup;

var lookup = function lookup(store, ref, name) {
  var allowNested = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var root = getRoot(ref);
  var nested = (0, _utils.getNestedProto)(root);
  return recursiveLookup(nested, name, [root["package"]], allowNested);
};

exports.lookup = lookup;

var lookupNested = function lookupNested(ref, traversal, name) {
  var allowNested = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var root = getRoot(ref);
  var nested = (0, _utils.getNested)(root, traversal);
  var scoped = (0, _toConsumableArray2["default"])(traversal).splice(root["package"].split('.').length);
  return recursiveLookup(nested, name, [root["package"]].concat((0, _toConsumableArray2["default"])(scoped)), allowNested);
};

exports.lookupNested = lookupNested;

var lookupAny = function lookupAny(store, ref, name) {
  var refObject = lookupLocal(store, ref, name);

  if (refObject) {
    return refObject;
  }

  refObject = externalLookup(store, ref, name);

  if (refObject) {
    return refObject;
  }
}; // recursively look at all imports and find what you're looking for...


exports.lookupAny = lookupAny;

var lookupAnyFromImports = function lookupAnyFromImports(store, ref, name) {
  var _ref$traversed$parsed, _ref$traversed;

  var refObject = lookupAny(store, ref, name);
  if (refObject) return refObject;
  var imports = Object.keys((_ref$traversed$parsed = (_ref$traversed = ref.traversed) === null || _ref$traversed === void 0 ? void 0 : _ref$traversed.parsedImports) !== null && _ref$traversed$parsed !== void 0 ? _ref$traversed$parsed : {});

  for (var i = 0; i < imports.length; i++) {
    var _ref2 = store.findProto(imports[i]);

    refObject = lookupAnyFromImports(store, _ref2, name);
    if (refObject) return refObject;
  }

  return refObject;
};

exports.lookupAnyFromImports = lookupAnyFromImports;

var lookupLocal = function lookupLocal(store, ref, name) {
  var root = getRoot(ref);
  var refObject = lookup(store, ref, name);

  if (refObject) {
    return {
      name: name,
      "import": ref.filename,
      importType: 'local',
      importedName: name,
      "package": root["package"],
      obj: refObject
    };
  }
};

exports.lookupLocal = lookupLocal;

var externalLookup = function externalLookup(store, ref, name) {
  var refObject;
  refObject = protoImportLookup(store, ref, name);

  if (refObject) {
    return refObject;
  }

  refObject = importLookup(store, ref, name);

  if (refObject) {
    return refObject;
  }
};

exports.externalLookup = externalLookup;