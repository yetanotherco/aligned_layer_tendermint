"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.grpcGateway = void 0;
var grpcGateway = "\n\n/**\n * base64 encoder and decoder\n * Copied and adapted from https://github.com/protobufjs/protobuf.js/blob/master/lib/base64/index.js\n */\n// Base64 encoding table\nconst b64 = new Array(64);\n\nexport interface InitReq extends RequestInit {\n  pathPrefix?: string\n}\n\ntype RequestPayload = Record<string, unknown>;\n\nexport function b64Encode(buffer: Uint8Array, start: number, end: number): string {\n\tlet parts: any = null;\n  const chunk: any[] = [];\n  let i = 0, // output index\n    j = 0, // goto index\n    t;     // temporary\n  while (start < end) {\n    const b = buffer[start++];\n    switch (j) {\n      case 0:\n        chunk[i++] = b64[b >> 2];\n        t = (b & 3) << 4;\n        j = 1;\n        break;\n      case 1:\n        chunk[i++] = b64[t | b >> 4];\n        t = (b & 15) << 2;\n        j = 2;\n        break;\n      case 2:\n        chunk[i++] = b64[t | b >> 6];\n        chunk[i++] = b64[b & 63];\n        j = 0;\n        break;\n    }\n    if (i > 8191) {\n      (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n      i = 0;\n    }\n  }\n  if (j) {\n    chunk[i++] = b64[t];\n    chunk[i++] = 61;\n    if (j === 1)\n      chunk[i++] = 61;\n  }\n  if (parts) {\n    if (i)\n      parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n    return parts.join(\"\");\n  }\n  return String.fromCharCode.apply(String, chunk.slice(0, i));\n}\n\nexport function replacer(key: any, value: any): any {\n  if(value && value.constructor === Uint8Array) {\n    return b64Encode(value, 0, value.length);\n  }\n\n  return value;\n}\n\nexport function fetchReq<I, O>(path: string, init?: InitReq): Promise<O> {\n  const {pathPrefix, ...req} = init || {}\n\n  const url = pathPrefix ? `${pathPrefix}${path}` : path\n\n  return fetch(url, req).then(r => r.json().then((body: O) => {\n    if (!r.ok) { throw body; }\n    return body;\n  })) as Promise<O>\n}\n\nfunction isPrimitive(value: unknown): boolean {\n  return [\"string\", \"number\", \"boolean\"].some(t => typeof value === t);\n}\n\ntype Primitive = string | boolean | number;\ntype FlattenedRequestPayload = Record<string, Primitive | Array<Primitive>>;\n\nfunction isZeroValuePrimitive(value: Primitive): boolean {\n  return value === false || value === 0 || value === \"\";\n}\n\nfunction flattenRequestPayload<T extends RequestPayload>(\n  requestPayload: T,\n  path: string = \"\"\n): FlattenedRequestPayload {\n  return Object.keys(requestPayload).reduce(\n    (acc: T, key: string): T => {\n      const value = requestPayload[key];\n      const newPath = path ? [path, key].join(\".\") : key;\n\n      const isNonEmptyPrimitiveArray =\n        Array.isArray(value) &&\n        value.every(v => isPrimitive(v)) &&\n        value.length > 0;\n\n      const isNonZeroValuePrimitive =\n        isPrimitive(value) && !isZeroValuePrimitive(value as Primitive);\n\n      let objectToMerge = {};\n\n      if (isPlainObject(value)) {\n        objectToMerge = flattenRequestPayload(value as RequestPayload, newPath);\n      } else if (isNonZeroValuePrimitive || isNonEmptyPrimitiveArray) {\n        objectToMerge = { [newPath]: value };\n      }\n\n      return { ...acc, ...objectToMerge };\n    },\n    {} as T\n  ) as FlattenedRequestPayload;\n}\n\nfunction isPlainObject(value: unknown): boolean {\n  const isObject =\n    Object.prototype.toString.call(value).slice(8, -1) === \"Object\";\n  const isObjLike = value !== null && isObject;\n\n  if (!isObjLike || !isObject) {\n    return false;\n  }\n\n  const proto = Object.getPrototypeOf(value);\n\n  const hasObjectConstructor =\n    typeof proto === \"object\" &&\n    proto.constructor === Object.prototype.constructor;\n\n  return hasObjectConstructor;\n}\n\nexport function renderURLSearchParams<T extends RequestPayload>(\n  requestPayload: T,\n  urlPathParams: string[] = []\n): string {\n  const flattenedRequestPayload = flattenRequestPayload(requestPayload);\n\n  const urlSearchParams = Object.keys(flattenedRequestPayload).reduce(\n    (acc: string[][], key: string): string[][] => {\n      // key should not be present in the url path as a parameter\n      const value = flattenedRequestPayload[key];\n      if (urlPathParams.find(f => f === key)) {\n        return acc;\n      }\n      return Array.isArray(value)\n        ? [...acc, ...value.map(m => [key, m.toString()])]\n        : (acc = [...acc, [key, value.toString()]]);\n    },\n    [] as string[][]\n  );\n\n  // react-native doesn't like working with array of arrays, and this is easier to patch\n  return urlSearchParams\n    .map((x) => new URLSearchParams({ [x[0]]: x[1] }).toString())\n    .join(\"&\");\n}\n";
exports.grpcGateway = grpcGateway;