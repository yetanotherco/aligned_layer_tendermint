"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseType = exports.parseService = exports.parseRecur = exports.parseEnum = exports.parse = exports.getParsedObjectName = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _types = require("@osmonauts/types");
var _protoParser = require("@osmonauts/proto-parser");
var _ast = require("@osmonauts/ast");
var _utils = require("./utils");
var parse = function parse(context) {
  var root = (0, _utils.getRoot)(context.ref);
  parseRecur({
    context: context,
    obj: root.root,
    scope: [],
    isNested: false
  });
};
exports.parse = parse;
var getParsedObjectName = function getParsedObjectName(ref, obj, scope) {
  var _scope = (0, _toConsumableArray2["default"])(scope);
  var root = (0, _utils.getRoot)(ref);
  var allButPackage = _scope.splice(root["package"].split('.').length);
  // pull off "this" name
  allButPackage.pop();
  return (0, _protoParser.getObjectName)(obj.name, [root["package"]].concat((0, _toConsumableArray2["default"])(allButPackage)));
};

// TODO potentially move this back to ast or proto bc the ast lib references MapEntries...
exports.getParsedObjectName = getParsedObjectName;
var makeKeyTypeObj = function makeKeyTypeObj(ref, field, scope) {
  var root = (0, _utils.getRoot)(ref);
  var scoped = (0, _toConsumableArray2["default"])(scope).splice(root["package"].split('.').length);
  var adhocObj = {
    type: 'Type',
    comment: undefined,
    fields: {
      key: {
        id: 1,
        type: field.keyType,
        scope: (0, _toConsumableArray2["default"])(scoped),
        parsedType: {
          name: field.keyType,
          type: field.keyType
        },
        comment: undefined,
        options: undefined
      },
      value: {
        id: 2,
        type: field.parsedType.name,
        scope: (0, _toConsumableArray2["default"])(scoped),
        parsedType: {
          name: field.type,
          type: field.parsedType.type
        },
        comment: undefined,
        options: undefined
      }
    }
  };
  return adhocObj;
};
var parseType = function parseType(context, obj, scope) {
  var isNested = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  obj.keyTypes.forEach(function (field) {
    var keyTypeObject = makeKeyTypeObj(context.ref, field, (0, _toConsumableArray2["default"])(scope));
    var name = getParsedObjectName(context.ref, {
      name: (0, _ast.getKeyTypeEntryName)(obj.name, field.name)
    }, (0, _toConsumableArray2["default"])(scope));
    context.addType(name, keyTypeObject, true);
  });

  // parse nested names
  var name = obj.name;
  if (isNested) {
    name = getParsedObjectName(context.ref, obj, (0, _toConsumableArray2["default"])(scope));
  }
  context.addType(name, obj, isNested);

  // render nested LAST
  if (obj.nested) {
    Object.keys(obj.nested).forEach(function (key) {
      // isNested = true;
      parseRecur({
        context: context,
        obj: obj.nested[key],
        scope: [].concat((0, _toConsumableArray2["default"])(scope), [key]),
        isNested: true
      });
    });
  }
};
exports.parseType = parseType;
var parseEnum = function parseEnum(context, obj, scope) {
  var isNested = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var name = obj.name;
  // parse nested names
  if (isNested) {
    name = getParsedObjectName(context.ref, obj, scope);
  }
  context.addType(name, obj, isNested);
};
exports.parseEnum = parseEnum;
var parseService = function parseService(context, obj, scope) {
  var isNested = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var methodHash = obj.methods;
  if (!_types.ALLOWED_RPC_SERVICES.includes(obj.name)) {
    return;
  }
  Object.entries(methodHash).forEach(function (_ref) {
    var _lookup$import, _lookupResponse$impor;
    var _ref2 = (0, _slicedToArray2["default"])(_ref, 2),
      key = _ref2[0],
      value = _ref2[1];
    var lookup = context.store.get(context.ref, value.requestType);
    if (!lookup) {
      console.warn("cannot find ".concat(value.requestType));
      throw new Error('undefined symbol for service.');
    }
    var lookupResponse = context.store.get(context.ref, value.responseType);
    if (!lookupResponse) {
      console.warn("cannot find ".concat(value.requestType));
      throw new Error('undefined symbol for service.');
    }
    var serviceInfo = {
      methodName: key,
      "package": context.ref.proto["package"],
      message: lookup.importedName,
      messageImport: (_lookup$import = lookup["import"]) !== null && _lookup$import !== void 0 ? _lookup$import : context.ref.filename,
      response: lookupResponse.importedName,
      responseImport: (_lookupResponse$impor = lookupResponse["import"]) !== null && _lookupResponse$impor !== void 0 ? _lookupResponse$impor : context.ref.filename,
      comment: value.comment
    };
    switch (obj.name) {
      case 'Msg':
        context.addMutation(serviceInfo);
        break;
      case 'Query':
        context.addQuery(serviceInfo);
        break;
      default:
        context.addService(serviceInfo);
        break;
    }
  });
};
exports.parseService = parseService;
var parseRecur = function parseRecur(_ref3) {
  var context = _ref3.context,
    obj = _ref3.obj,
    scope = _ref3.scope,
    isNested = _ref3.isNested;
  switch (obj.type) {
    case 'Type':
      return parseType(context, obj, scope, isNested);
    case 'Enum':
      return parseEnum(context, obj, scope, isNested);
    case 'Service':
      return parseService(context, obj, scope, isNested);
    case 'Field':
      console.log(obj);
      return;
    case 'Root':
    case 'Namespace':
      if (obj.nested) {
        return Object.keys(obj.nested).forEach(function (key) {
          parseRecur({
            context: context,
            obj: obj.nested[key],
            scope: [].concat((0, _toConsumableArray2["default"])(scope), [key]),
            isNested: isNested
          });
        });
      } else {
        throw new Error('parseRecur() cannot find protobufjs Type');
      }
    default:
    // if (obj.type === 'string') return;
    // if (obj.type === 'bool') return;
    // if (obj.type === 'HttpRule') return;
    // if (obj.type === 'InterfaceDescriptor') return;
    // if (obj.type === 'ScalarDescriptor') return;
    // if (obj.type === 'ModuleDescriptor') return;
    // if (obj.type === 'TableDescriptor') return;
    // if (obj.type === 'SingletonDescriptor') return;
    // if (obj.type === 'ModuleSchemaDescriptor') return;
    // if (obj.type === 'google.api.FieldBehavior') return;
    // if (obj.type === 'google.api.ResourceReference') return;
    // if (obj.type === 'google.api.ResourceDescriptor') return;
    // if (obj.type === 'google.api.RoutingRule') return;
    // if (obj.type === 'google.api.VisibilityRule') return;
    // if (obj.type === 'google.longrunning.OperationInfo') return;
    // throw new Error('parseRecur() cannot find protobufjs Type')
  }
};
exports.parseRecur = parseRecur;