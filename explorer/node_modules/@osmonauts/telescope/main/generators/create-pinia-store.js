"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.plugin = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _imports = require("../imports");
var _parse = require("../parse");
var _protoParser = require("@osmonauts/proto-parser");
var _ast = require("@osmonauts/ast");
var plugin = function plugin(builder, bundler) {
  var _builder$options$pini, _builder$options$lcdC;
  if (!((_builder$options$pini = builder.options.pinia) !== null && _builder$options$pini !== void 0 && _builder$options$pini.enabled)) {
    return;
  }

  // get mapping of packages and rpc query filenames.

  if (!((_builder$options$lcdC = builder.options.lcdClients) !== null && _builder$options$lcdC !== void 0 && _builder$options$lcdC.enabled)) {
    return;
  }
  var queryContexts = bundler.contexts.filter(function (context) {
    return context.queries.length > 0 || context.services.length > 0;
  });
  if (queryContexts.length > 0) {
    var piniaBundlerFiles = [];

    // [x] write out one registry helper for all contexts w/mutations
    queryContexts.forEach(function (c) {
      var enabled = c.proto.pluginValue('lcdClients.enabled');
      if (!enabled) return;
      var includePinia = c.proto.pluginValue('pinia.enabled') && (0, _protoParser.isRefIncluded)(c.ref, c.proto.pluginValue('pinia.include'));
      if (!includePinia) return;
      if (c.proto.isExcluded()) return;
      var ctx = bundler.getFreshContext(c);

      // get mutations, services
      (0, _parse.parse)(ctx);
      var proto = (0, _protoParser.getNestedProto)(c.ref.traversed);

      //// Anything except Msg Service OK...
      var allowedRpcServices = builder.options.rpcClients.enabledServices.filter(function (a) {
        return a !== 'Msg';
      });
      var name, getImportsFrom;

      // get imports
      allowedRpcServices.forEach(function (svcKey) {
        if (proto[svcKey]) {
          if (svcKey === 'Query') {
            getImportsFrom = ctx.queries;
          } else {
            getImportsFrom = ctx.services;
          }
          name = svcKey;
        }
      });
      var localname = bundler.getLocalFilename(c.ref, 'pinia.store');
      var filename = bundler.getFilename(localname);
      var bundlerFile = {
        "package": c.ref.proto["package"],
        localname: localname,
        filename: filename
      };
      var ast = null;
      allowedRpcServices.forEach(function (svcKey) {
        if (proto[svcKey]) {
          ast = (0, _ast.createPiniaStore)(ctx.generic, proto[svcKey]);
        }
      });
      if (!ast) {
        return;
      }
      piniaBundlerFiles.push(bundlerFile);
      var serviceImports = (0, _imports.getDepsFromQueries)(getImportsFrom, localname);
      var imports = (0, _imports.buildAllImports)(ctx, serviceImports, localname);
      var piniaImport = (0, _imports.getImportStatements)('pinia', [{
        type: 'import',
        name: 'defineStore',
        path: 'pinia'
      }, {
        type: 'import',
        name: 'LCDQueryClient',
        path: './query.lcd'
      }]);
      var prog = [].concat([].concat((0, _toConsumableArray2["default"])(imports), (0, _toConsumableArray2["default"])(piniaImport))).concat(ctx.body).concat(ast);
      bundler.writeAst(prog, filename);
      bundler.addToBundle(c, localname);
    });
    bundler.addStateManagers('pinia', piniaBundlerFiles);
  }
};
exports.plugin = plugin;