"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.plugin = void 0;
var _imports = require("../imports");
var _ast = require("@osmonauts/ast");
var _protoParser = require("@osmonauts/proto-parser");
var _parse = require("../parse");
var plugin = function plugin(builder, bundler) {
  var reactQueryBundlerFiles = [];
  var mobxBundlerFiles = [];
  var clients = bundler.contexts.map(function (c) {
    var _builder$options$rpcC, _builder$options$rpcC2, _builder$options$rpcC3;
    var enabled = c.proto.pluginValue('rpcClients.enabled');
    if (!enabled) return;
    var inline = c.proto.pluginValue('rpcClients.inline');
    if (inline) return;
    if (c.proto.isExcluded()) return;
    var ctx = bundler.getFreshContext(c);

    // get mutations, services
    (0, _parse.parse)(ctx);
    var proto = (0, _protoParser.getNestedProto)(c.ref.traversed);

    //// Anything except Msg Service OK...
    var allowedRpcServices = (_builder$options$rpcC = (_builder$options$rpcC2 = builder.options.rpcClients) === null || _builder$options$rpcC2 === void 0 ? void 0 : (_builder$options$rpcC3 = _builder$options$rpcC2.enabledServices) === null || _builder$options$rpcC3 === void 0 ? void 0 : _builder$options$rpcC3.filter(function (a) {
      return a !== 'Msg';
    })) !== null && _builder$options$rpcC !== void 0 ? _builder$options$rpcC : [];
    var found = allowedRpcServices.some(function (svc) {
      var _proto$svc;
      return (proto === null || proto === void 0 ? void 0 : proto[svc]) && ((_proto$svc = proto[svc]) === null || _proto$svc === void 0 ? void 0 : _proto$svc.type) === 'Service';
    });
    if (!found) {
      return;
    }
    ///

    var name, getImportsFrom;
    allowedRpcServices.forEach(function (svcKey) {
      if (proto[svcKey]) {
        if (svcKey === 'Query') {
          getImportsFrom = ctx.queries;
        } else {
          getImportsFrom = ctx.services;
        }
        name = svcKey;
      }
    });
    var localname = bundler.getLocalFilename(c.ref, "rpc.".concat(name));
    var filename = bundler.getFilename(localname);
    var bundlerFile = {
      "package": c.ref.proto["package"],
      localname: localname,
      filename: filename
    };
    var asts = [];
    switch (c.proto.pluginValue('rpcClients.type')) {
      case 'grpc-gateway':
        allowedRpcServices.forEach(function (svcKey) {
          if (proto[svcKey]) {
            var svc = proto[svcKey];
            asts.push((0, _ast.createGRPCGatewayQueryClass)(ctx.generic, svc));
          }
        });
        break;
      case 'grpc-web':
        allowedRpcServices.forEach(function (svcKey) {
          if (proto[svcKey]) {
            var svc = proto[svcKey];
            asts.push((0, _ast.createGrpcWebQueryInterface)(ctx.generic, svc));
            asts.push((0, _ast.createGrpcWebQueryClass)(ctx.generic, svc));
            asts.push((0, _ast.GetDesc)(ctx.generic, proto[svcKey]));
            var Desces = (0, _ast.getMethodDesc)(ctx.generic, proto[svcKey]);
            for (var i = 0; i < Desces.length; i++) {
              var element = Desces[i];
              asts.push(element);
            }
            asts.push((0, _ast.grpcWebRpcInterface)());
            asts.push((0, _ast.getGrpcWebImpl)(ctx.generic));
          }
        });
        break;
      case 'tendermint':
      default:
        allowedRpcServices.forEach(function (svcKey) {
          if (proto[svcKey]) {
            var svc = proto[svcKey];
            asts.push((0, _ast.createRpcClientInterface)(ctx.generic, svc));
            asts.push((0, _ast.createRpcClientClass)(ctx.generic, svc));
            if (c.proto.pluginValue('rpcClients.extensions')) {
              asts.push((0, _ast.createRpcQueryExtension)(ctx.generic, svc));
            }

            // see if current file has been reactQuery enabled and included
            var includeReactQueryHooks = c.proto.pluginValue('reactQuery.enabled') && (0, _protoParser.isRefIncluded)(c.ref, c.proto.pluginValue('reactQuery.include'));

            // react query
            // generate react query parts if included.
            // eg: __fixtures__/output1/akash/audit/v1beta2/query.rpc.Query.ts
            // export interface UseAuditorAttributesQuery<TData> ...
            // const _queryClients: WeakMap ...
            // const getQueryService = ...
            // export const createRpcQueryHooks = ...
            // TODO use the imports and make separate files
            if (includeReactQueryHooks) {
              [].push.apply(asts, (0, _ast.createRpcQueryHookInterfaces)(ctx.generic, svc));
              [].push.apply(asts, (0, _ast.createRpcQueryHookClientMap)(ctx.generic, svc));
              asts.push((0, _ast.createRpcQueryHooks)(ctx.generic, proto[svcKey]));
              reactQueryBundlerFiles.push(bundlerFile);
            }

            // whether mobx plugin is enabled has been dealt with inside createMobxQueryStores
            var mobxQueryStoreAst = (0, _ast.createMobxQueryStores)(ctx.generic, proto[svcKey]);
            if (mobxQueryStoreAst) {
              asts.push(mobxQueryStoreAst);
              mobxBundlerFiles.push(bundlerFile);
            }
          }
        });
    }
    if (!asts.length) {
      return;
    }
    var serviceImports = (0, _imports.getDepsFromQueries)(getImportsFrom, localname);

    // TODO we do NOT need all imports...
    var imports = (0, _imports.buildAllImports)(ctx, serviceImports, localname);
    var prog = [].concat(imports).concat(ctx.body).concat(asts);
    bundler.writeAst(prog, filename);
    bundler.addToBundle(c, localname);
    return bundlerFile;
  }).filter(Boolean);
  bundler.addRPCQueryClients(clients);
  bundler.addStateManagers("reactQuery", reactQueryBundlerFiles);
  bundler.addStateManagers("mobx", mobxBundlerFiles);
};
exports.plugin = plugin;