"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getImportsFromQueries = exports.getImportsFromMutations = exports.getImportStatements = exports.getDepsFromQueries = exports.getDepsFromMutations = exports.buildAllImportsFromGenericContext = exports.buildAllImports = exports.aggregateImports = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var t = _interopRequireWildcard(require("@babel/types"));
var _ast = require("@osmonauts/ast");
var _utils = require("./utils");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var importHashToArray = function importHashToArray(hash) {
  return Object.entries(hash !== null && hash !== void 0 ? hash : {}).reduce(function (m, _ref) {
    var _ref2 = (0, _slicedToArray2["default"])(_ref, 2),
      path = _ref2[0],
      names = _ref2[1];
    names.forEach(function (name) {
      m.push({
        type: 'import',
        name: name,
        path: path
      });
    });
    return m;
  }, []);
};
var getProtoImports = function getProtoImports(context, filename) {
  return context.proto.imports.map(function (usage) {
    if (filename === usage["import"]) return;
    var importPath = (0, _utils.getRelativePath)(filename, usage["import"]);
    return {
      type: 'import',
      name: usage.name,
      importAs: usage.importedAs,
      path: importPath
    };
  }).filter(Boolean);
};
var getAminoImports = function getAminoImports(context, filename) {
  return context.amino.imports.map(function (usage) {
    if (filename === usage["import"]) return;
    var importPath = (0, _utils.getRelativePath)(filename, usage["import"]);
    return {
      type: 'import',
      name: usage.name,
      importAs: usage.importedAs,
      path: importPath
    };
  }).filter(Boolean);
};
var getGenericImports = function getGenericImports(context, filename) {
  return context.generic.imports.map(function (usage) {
    if (filename === usage["import"]) return;
    var importPath = (0, _utils.getRelativePath)(filename, usage["import"]);
    return {
      type: 'import',
      name: usage.name,
      importAs: usage.importedAs,
      path: importPath
    };
  }).filter(Boolean);
};
var getParsedImports = function getParsedImports(context, parsedImports, filename) {
  var imports = [];
  Object.entries(parsedImports !== null && parsedImports !== void 0 ? parsedImports : {}).forEach(function (_ref3) {
    var _context$ref, _context$ref$traverse, _context$ref$traverse2;
    var _ref4 = (0, _slicedToArray2["default"])(_ref3, 2),
      path = _ref4[0],
      names = _ref4[1];
    if (filename === path) return;
    var importPath = (0, _utils.getRelativePath)(filename, path);
    var aliases = (_context$ref = context.ref) === null || _context$ref === void 0 ? void 0 : (_context$ref$traverse = _context$ref.traversed) === null || _context$ref$traverse === void 0 ? void 0 : (_context$ref$traverse2 = _context$ref$traverse.importNames) === null || _context$ref$traverse2 === void 0 ? void 0 : _context$ref$traverse2[path];
    names.forEach(function (name) {
      var importAs = name;
      if (aliases && aliases[name]) {
        importAs = aliases[name];
      }
      imports.push({
        type: 'import',
        name: name,
        importAs: importAs,
        path: importPath
      });
    });
  });
  return imports;
};
var importAs = function importAs(name, _importAs, importPath) {
  return t.importDeclaration([t.importSpecifier(t.identifier(_importAs), t.identifier(name))], t.stringLiteral(importPath));
};

// __helpers__
var getImportStatements = function getImportStatements(filepath, list) {
  // swap helpers with helpers file...
  var modifiedImports = list.map(function (imp) {
    if (_utils.UTIL_HELPERS.includes(imp.path)) {
      var name = imp.path.replace(/__/g, '');
      return _objectSpread(_objectSpread({}, imp), {}, {
        path: (0, _utils.getRelativePath)(filepath, "./".concat(name))
      });
    }
    return imp;
  });
  var imports = modifiedImports.reduce(function (m, obj) {
    m[obj.path] = m[obj.path] || [];
    var exists = m[obj.path].find(function (el) {
      return el.type === obj.type && el.path === obj.path && el.name === obj.name;
    });

    // MARKED AS NOT DRY [google.protobuf names]
    // TODO some have google.protobuf.Any shows up... figure out the better way to handle this
    if (/\./.test(obj.name)) {
      obj.name = obj.name.split('.')[obj.name.split('.').length - 1];
    }
    if (!exists) {
      m[obj.path].push(obj);
    }
    return m;
  }, {});
  return Object.entries(imports).reduce(function (m, _ref5) {
    var _ref6 = (0, _slicedToArray2["default"])(_ref5, 2),
      importPath = _ref6[0],
      imports = _ref6[1];
    var defaultImports = imports.filter(function (a) {
      return a.type === 'default';
    });
    if (defaultImports.length) {
      if (defaultImports.length > 1) throw new Error('more than one default name NOT allowed.');
      m.push(t.importDeclaration([t.importDefaultSpecifier(t.identifier(defaultImports[0].name))], t.stringLiteral(defaultImports[0].path)));
    }
    var namedImports = imports.filter(function (a) {
      return a.type === 'import' && (!a.importAs || a.name === a.importAs);
    });
    if (namedImports.length) {
      m.push((0, _ast.importStmt)(namedImports.map(function (i) {
        return i.name;
      }), namedImports[0].path));
    }
    var aliasNamedImports = imports.filter(function (a) {
      return a.type === 'import' && a.importAs && a.name !== a.importAs;
    });
    aliasNamedImports.forEach(function (imp) {
      m.push(importAs(imp.name, imp.importAs, imp.path));
    });
    var namespaced = imports.filter(function (a) {
      return a.type === 'namespace';
    });
    if (namespaced.length) {
      if (namespaced.length > 1) throw new Error('more than one namespaced name NOT allowed.');
      m.push(t.importDeclaration([t.importNamespaceSpecifier(t.identifier(namespaced[0].name))], t.stringLiteral(namespaced[0].path)));
    }
    return m;
  }, []);
};
exports.getImportStatements = getImportStatements;
var convertUtilsToImports = function convertUtilsToImports(context) {
  var list = [];
  var utils = Object.keys(_objectSpread(_objectSpread(_objectSpread({}, context.amino.utils), context.proto.utils), context.generic.utils));
  utils.forEach(function (util) {
    if (!_utils.UTILS.hasOwnProperty(util)) throw new Error('missing Util! ::' + util);
    if (typeof _utils.UTILS[util] === 'string') {
      list.push({
        type: 'import',
        path: _utils.UTILS[util],
        name: util
      });
    } else {
      list.push(_utils.UTILS[util]);
    }
  });
  return list;
};
var convertUtilsToImportsGenric = function convertUtilsToImportsGenric(context) {
  var list = [];
  var utils = Object.keys(_objectSpread({}, context.utils));

  // MARKED AS NOT DRY - duplicate of above
  utils.forEach(function (util) {
    if (!_utils.UTILS.hasOwnProperty(util)) throw new Error('missing Util! ::' + util);
    if (typeof _utils.UTILS[util] === 'string') {
      list.push({
        type: 'import',
        path: _utils.UTILS[util],
        name: util
      });
    } else {
      list.push(_utils.UTILS[util]);
    }
  });
  return list;
};
var buildAllImports = function buildAllImports(context, allImports, filepath) {
  var imports = aggregateImports(context, allImports, filepath);
  var importStmts = getImportStatements(filepath, imports);
  return importStmts;
};
exports.buildAllImports = buildAllImports;
var buildAllImportsFromGenericContext = function buildAllImportsFromGenericContext(context, filepath) {
  var imports = convertUtilsToImportsGenric(context);
  var importStmts = getImportStatements(filepath, imports);
  return importStmts;
};
exports.buildAllImportsFromGenericContext = buildAllImportsFromGenericContext;
var addDerivativeTypesToImports = function addDerivativeTypesToImports(context, imports) {
  var ref = context.ref;
  return imports.reduce(function (m, obj) {
    // SDKType
    // probably wont need this until we start generating osmonauts/helpers inline
    if (obj.type === 'import' && obj.path.startsWith('.')) {
      var lookup = null;
      try {
        lookup = context.store.getImportFromRef(ref, obj.name);
      } catch (e) {}
      var appendSuffix = function appendSuffix(obj, baseType) {
        var _obj$importAs;
        return _objectSpread(_objectSpread({}, obj), {}, {
          orig: obj.name,
          name: _ast.SymbolNames[baseType](obj.name),
          importAs: _ast.SymbolNames[baseType]((_obj$importAs = obj.importAs) !== null && _obj$importAs !== void 0 ? _obj$importAs : obj.name)
        });
      };

      // MARKED AS NOT DRY [google.protobuf names]
      // TODO some have google.protobuf.Any shows up... figure out the better way to handle this
      var removeProtoPrefix = function removeProtoPrefix(obj) {
        if (/\./.test(obj.name)) {
          obj.name = obj.name.split('.')[obj.name.split('.').length - 1];
          obj.importAs = obj.importAs.split('.')[obj.importAs.split('.').length - 1];
        }
        return obj;
      };
      var SDKTypeObject = removeProtoPrefix(appendSuffix(obj, 'SDKType'));
      var AminoTypeObject = removeProtoPrefix(appendSuffix(obj, 'Amino'));
      var EncodedTypeObject = removeProtoPrefix(appendSuffix(obj, 'ProtoMsg'));
      // const AminoTypeUrlObject = removeProtoPrefix(appendSuffix(obj, 'AminoType'));

      if (lookup && ['Type', 'Enum'].includes(lookup.obj.type)) {
        var arr = [].concat((0, _toConsumableArray2["default"])(m), [obj]);
        if (context.options.aminoEncoding.useRecursiveV2encoding) {
          // check and see if this derived import has been required...
          var foundEnc = context.proto.derivedImports.find(function (a) {
            if (a.type !== 'ProtoMsg') return false;
            if (EncodedTypeObject.orig === a.symbol.symbolName) {
              // UNTIL you fix the ImportObjs to have ref...
              var rel = (0, _utils.getRelativePath)(a.symbol.ref, a.symbol.source);
              if (rel === EncodedTypeObject.path) {
                return true;
              }
            }
          });
          var foundAmino = context.proto.derivedImports.find(function (a) {
            if (a.type !== 'Amino') return false;
            if (AminoTypeObject.orig === a.symbol.symbolName) {
              // UNTIL you fix the ImportObjs to have ref...
              var rel = (0, _utils.getRelativePath)(a.symbol.ref, a.symbol.source);
              if (rel === AminoTypeObject.path) {
                return true;
              }
            }
          });

          // we need Any types as defaults...
          if (foundEnc || EncodedTypeObject.orig === 'Any') {
            arr.push(EncodedTypeObject);
          }
          if (foundAmino || AminoTypeObject.orig === 'Any') {
            arr.push(AminoTypeObject);
          }
        }
        if (context.options.useSDKTypes) {
          // issue in output1 (probably legacy v1 amino transpiler)
          // ProposalSDKType wasn't being found in QueryProposalResponseSDKType
          arr.push(SDKTypeObject);
          // const foundSDK = context.proto.derivedImports.find(a => {
          //     if (a.type !== 'SDKType') return false;

          //     if (SDKTypeObject.orig === a.symbol.symbolName) {
          //         // UNTIL you fix the ImportObjs to have ref...
          //         let rel = getRelativePath(a.symbol.ref, a.symbol.source);
          //         if (rel === SDKTypeObject.path) {
          //             return true;
          //         }
          //     }
          // });

          // if (foundSDK) {
          //     arr.push(SDKTypeObject);
          // }
        }

        return arr;
      }
    }
    return [].concat((0, _toConsumableArray2["default"])(m), [obj]);
  }, []);
};
var aggregateImports = function aggregateImports(context, allImports, filepath) {
  var protoImports = getProtoImports(context, filepath);
  var aminoImports = getAminoImports(context, filepath);
  var genericImports = getGenericImports(context, filepath);
  var parsedImports = getParsedImports(context, context.amino.ref.traversed.parsedImports, filepath);
  var additionalImports = importHashToArray(allImports);
  var utilities = convertUtilsToImports(context);
  var list = [].concat(parsedImports).concat(utilities).concat(protoImports).concat(aminoImports).concat(genericImports).concat(additionalImports);
  if (context.options.useSDKTypes || context.options.aminoEncoding.useRecursiveV2encoding) {
    return addDerivativeTypesToImports(context, list);
  } else {
    return list;
  }
};
exports.aggregateImports = aggregateImports;
var getImportsFromMutations = function getImportsFromMutations(mutations) {
  return mutations.map(function (mutation) {
    return {
      "import": mutation.messageImport,
      name: mutation.message
    };
  });
};

// TODO implement ServiceQuery type (it is the same)
exports.getImportsFromMutations = getImportsFromMutations;
var getImportsFromQueries = function getImportsFromQueries(queries) {
  return queries.reduce(function (m, query) {
    var req = {
      "import": query.messageImport,
      name: query.message
    };
    var res = {
      "import": query.responseImport,
      name: query.response
    };
    return [].concat((0, _toConsumableArray2["default"])(m), [req, res]);
  }, []);
};
exports.getImportsFromQueries = getImportsFromQueries;
var getDepsFromMutations = function getDepsFromMutations(mutations, filename) {
  return getImportsFromMutations(mutations).map(function (imp) {
    var f = filename;
    var f2 = imp["import"];
    if (f === f2) return;
    var importPath = (0, _utils.getRelativePath)(f, f2);
    return _objectSpread(_objectSpread({}, imp), {}, {
      importPath: importPath
    });
  }).filter(Boolean).reduce(function (m, v) {
    var _m$v$importPath;
    m[v.importPath] = (_m$v$importPath = m[v.importPath]) !== null && _m$v$importPath !== void 0 ? _m$v$importPath : [];
    if (!m[v.importPath].includes(v.name)) {
      m[v.importPath].push(v.name);
    }
    return m;
  }, {});
};
exports.getDepsFromMutations = getDepsFromMutations;
var getDepsFromQueries = function getDepsFromQueries(queries, filename) {
  return getImportsFromQueries(queries).map(function (imp) {
    var f = filename;
    var f2 = imp["import"];
    if (f === f2) return;
    var importPath = (0, _utils.getRelativePath)(f, f2);
    return _objectSpread(_objectSpread({}, imp), {}, {
      importPath: importPath
    });
  }).filter(Boolean).reduce(function (m, v) {
    var _m$v$importPath2;
    m[v.importPath] = (_m$v$importPath2 = m[v.importPath]) !== null && _m$v$importPath2 !== void 0 ? _m$v$importPath2 : [];
    if (!m[v.importPath].includes(v.name)) {
      m[v.importPath].push(v.name);
    }
    return m;
  }, {});
};
exports.getDepsFromQueries = getDepsFromQueries;