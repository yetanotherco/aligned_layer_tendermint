"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMutations = exports.getAminoProtos = exports.buildEnums = exports.buildBaseTypeScriptInterface = exports.buildBaseTypeScriptClass = exports.TelescopeParseContext = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _ast = require("@osmonauts/ast");
var getMutations = function getMutations(mutations) {
  return mutations.map(function (mutation) {
    return {
      typeUrl: "/".concat(mutation["package"], ".").concat(mutation.message),
      TypeName: mutation.message,
      methodName: mutation.methodName
    };
  });
};
exports.getMutations = getMutations;
var getAminoProtos = function getAminoProtos(mutations, store) {
  return mutations.map(function (mutation) {
    var ref = store.findProto(mutation.messageImport);
    return store.get(ref, mutation.message).obj;
  });
};
exports.getAminoProtos = getAminoProtos;
var buildBaseTypeScriptClass = function buildBaseTypeScriptClass(context, name, obj) {
  if (context.options.prototypes.enabled) {
    context.body.push((0, _ast.createCreateProtoType)(context.proto, name, obj));
    context.body.push((0, _ast.createObjectWithMethods)(context.proto, name, obj));
  }
};
exports.buildBaseTypeScriptClass = buildBaseTypeScriptClass;
var buildBaseTypeScriptInterface = function buildBaseTypeScriptInterface(context, name, obj) {
  context.body.push((0, _ast.createProtoType)(context.proto, name, obj));
  if (context.options.aminoEncoding.useRecursiveV2encoding) {
    context.body.push((0, _ast.createProtoTypeType)(context.proto, name, obj));
    // conditional type
    var interfaceType = (0, _ast.createProtoInterfaceEncodedType)(context.proto, name, obj);
    if (interfaceType) {
      context.body.push(interfaceType);
    }
    context.body.push((0, _ast.createAminoType)(context.proto, name, obj));

    // TODO optimization:
    // maybe in future, we can only print AminoTypeType if it's needed, 
    // for example, if it's used in msgs, or inside of a implements/accepts
    context.body.push((0, _ast.createAminoTypeType)(context.proto, name, obj));
  }
  if (context.options.useSDKTypes) {
    context.body.push((0, _ast.createSDKType)(context.proto, name, obj));
  }
};
exports.buildBaseTypeScriptInterface = buildBaseTypeScriptInterface;
var buildEnums = function buildEnums(context, name, obj) {
  context.body.push((0, _ast.createProtoEnum)(context.proto, name, obj));
  if (context.options.useSDKTypes) {
    context.body.push((0, _ast.createEnumSDKType)(context.proto, name, obj));
  }
  if (context.options.aminoEncoding.useRecursiveV2encoding) {
    context.body.push((0, _ast.createEnumAminoType)(context.proto, name, obj));
  }
  context.body.push((0, _ast.createProtoEnumFromJSON)(context.proto, name, obj));
  context.body.push((0, _ast.createProtoEnumToJSON)(context.proto, name, obj));
};
exports.buildEnums = buildEnums;
var TelescopeParseContext = /*#__PURE__*/function () {
  function TelescopeParseContext(ref, store, options) {
    (0, _classCallCheck2["default"])(this, TelescopeParseContext);
    this.generic = new _ast.GenericParseContext(ref, store, options);
    this.proto = new _ast.ProtoParseContext(ref, store, options);
    this.amino = new _ast.AminoParseContext(ref, store, options);
    this.options = options;
    this.ref = ref;
    this.store = store;
    this.parsedImports = {};
    this.body = [];
    this.queries = [];
    this.services = [];
    this.mutations = [];
    this.types = [];
  }
  (0, _createClass2["default"])(TelescopeParseContext, [{
    key: "hasMutations",
    value: function hasMutations() {
      return this.mutations.length > 0;
    }
  }, {
    key: "addType",
    value: function addType(name, obj, isNested) {
      this.types.push({
        name: name,
        obj: obj,
        isNested: isNested
      });
    }
  }, {
    key: "addMutation",
    value: function addMutation(mutation) {
      this.mutations.push(mutation);
    }
  }, {
    key: "addQuery",
    value: function addQuery(query) {
      this.queries.push(query);
    }
  }, {
    key: "addService",
    value: function addService(query) {
      this.services.push(query);
    }
    // build main Class with methods
  }, {
    key: "buildBase",
    value: function buildBase() {
      var _this = this;
      this.types.forEach(function (typeReg) {
        var name = typeReg.name,
          obj = typeReg.obj;
        if (obj.type === 'Enum') {
          buildEnums(_this, name, obj);
        }
      });
      this.types.forEach(function (typeReg) {
        var name = typeReg.name,
          obj = typeReg.obj;
        if (obj.type === 'Type') {
          buildBaseTypeScriptInterface(_this, name, obj);
        }
      });
      this.types.forEach(function (typeReg) {
        var name = typeReg.name,
          obj = typeReg.obj;
        if (obj.type === 'Type') {
          buildBaseTypeScriptClass(_this, name, obj);
        }
      });

      // interfaces
      if (this.options.interfaces.enabled) {
        var _this$ref$traversed$a;
        var interfaces = Object.keys((_this$ref$traversed$a = this.ref.traversed.acceptsInterface) !== null && _this$ref$traversed$a !== void 0 ? _this$ref$traversed$a : {});
        if (interfaces.length) {
          interfaces.forEach(function (interfaceName) {
            _this.body.push((0, _ast.createInterfaceDecoder)(_this.proto, _this.ref, interfaceName));
            if (_this.options.aminoEncoding.enabled && _this.options.aminoEncoding.useRecursiveV2encoding) {
              _this.body.push((0, _ast.createInterfaceFromAmino)(_this.proto, _this.ref, interfaceName));
              _this.body.push((0, _ast.createInterfaceToAmino)(_this.proto, _this.ref, interfaceName));
            }
          });
        }
      }
    }
  }, {
    key: "buildRegistry",
    value: function buildRegistry() {
      this.body.push((0, _ast.createTypeRegistry)(this.amino, getMutations(this.mutations)));
    }
  }, {
    key: "buildRegistryLoader",
    value: function buildRegistryLoader() {
      this.body.push((0, _ast.createRegistryLoader)(this.amino));
    }
  }, {
    key: "buildAminoInterfaces",
    value: function buildAminoInterfaces() {
      var _this2 = this;
      if (this.options.aminoEncoding.useRecursiveV2encoding) return;
      //
      var protos = getAminoProtos(this.mutations, this.store);
      protos.forEach(function (proto) {
        _this2.body.push((0, _ast.makeAminoTypeInterface)({
          context: _this2.amino,
          proto: proto
        }));
      });
    }
  }, {
    key: "buildAminoConverter",
    value: function buildAminoConverter() {
      this.body.push((0, _ast.createAminoConverter)({
        name: 'AminoConverter',
        context: this.amino,
        root: this.ref.traversed,
        protos: getAminoProtos(this.mutations, this.store)
      }));
    }
  }, {
    key: "buildHelperObject",
    value: function buildHelperObject() {
      // add methods
      this.body.push((0, _ast.createHelperObject)({
        context: this.amino,
        name: 'MessageComposer',
        mutations: getMutations(this.mutations)
      }));
    }
  }]);
  return TelescopeParseContext;
}();
exports.TelescopeParseContext = TelescopeParseContext;